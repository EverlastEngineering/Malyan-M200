###############################################################################
#
# IAR ANSI C/C++ Compiler V8.22.2.15995/W32 for ARM       21/May/2018  11:54:52
# Copyright 1999-2018 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\ff.c
#    Command line =  
#        -f C:\Users\yongzong\AppData\Local\Temp\EW6B45.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\ff.c
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.0\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.0\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =  
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\ff.lst
#    Object file  =  
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\ff.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\ff.c
      1          /*----------------------------------------------------------------------------/
      2          /  FatFs - FAT file system module  R0.12                 (C)ChaN, 2016        /
      3          /-----------------------------------------------------------------------------/
      4          / FatFs module is a free software that opened under license policy of
      5          / following conditions.
      6          /
      7          / Copyright (C) 2016, ChaN, all right reserved.
      8          /
      9          / 1. Redistributions of source code must retain the above copyright notice,
     10          /    this condition and the following disclaimer.
     11          /
     12          / This software is provided by the copyright holder and contributors "AS IS"
     13          / and any warranties related to this software are DISCLAIMED.
     14          / The copyright owner or contributors be NOT LIABLE for any damages caused
     15          / by use of this software.
     16          /----------------------------------------------------------------------------*/
     17          
     18          
     19          #include "ff.h"			/* Declarations of FatFs API */
     20          #include "diskio.h"		/* Declarations of disk I/O functions */
     21          
     22          
     23          /*--------------------------------------------------------------------------
     24          
     25             Module Private Definitions
     26          
     27          ---------------------------------------------------------------------------*/
     28          
     29          #if _FATFS != 88100	/* Revision ID */
     30          #error Wrong include file (ff.h).
     31          #endif
     32          
     33          
     34          /* Reentrancy related */
     35          #if _FS_REENTRANT
     36          #if _USE_LFN == 1
     37          #error Static LFN work area cannot be used at thread-safe configuration
     38          #endif
     39          #define	ENTER_FF(fs)		{ if (!lock_fs(fs)) return FR_TIMEOUT; }
     40          #define	LEAVE_FF(fs, res)	{ unlock_fs(fs, res); return res; }
     41          #else
     42          #define	ENTER_FF(fs)
     43          #define LEAVE_FF(fs, res)	return res
     44          #endif
     45          
     46          #define	ABORT(fs, res)		{ fp->err = (BYTE)(res); LEAVE_FF(fs, res); }
     47          
     48          
     49          /* Definitions of sector size */
     50          #if (_MAX_SS < _MIN_SS) || (_MAX_SS != 512 && _MAX_SS != 1024 && _MAX_SS != 2048 && _MAX_SS != 4096) || (_MIN_SS != 512 && _MIN_SS != 1024 && _MIN_SS != 2048 && _MIN_SS != 4096)
     51          #error Wrong sector size configuration
     52          #endif
     53          #if _MAX_SS == _MIN_SS
     54          #define	SS(fs)	((UINT)_MAX_SS)	/* Fixed sector size */
     55          #else
     56          #define	SS(fs)	((fs)->ssize)	/* Variable sector size */
     57          #endif
     58          
     59          
     60          /* Timestamp */
     61          #if _FS_NORTC == 1
     62          #if _NORTC_YEAR < 1980 || _NORTC_YEAR > 2107 || _NORTC_MON < 1 || _NORTC_MON > 12 || _NORTC_MDAY < 1 || _NORTC_MDAY > 31
     63          #error Invalid _FS_NORTC settings
     64          #endif
     65          #define GET_FATTIME()	((DWORD)(_NORTC_YEAR - 1980) << 25 | (DWORD)_NORTC_MON << 21 | (DWORD)_NORTC_MDAY << 16)
     66          #else
     67          #define GET_FATTIME()	get_fattime()
     68          #endif
     69          
     70          
     71          /* File lock controls */
     72          #if _FS_LOCK != 0
     73          #if _FS_READONLY
     74          #error _FS_LOCK must be 0 at read-only configuration
     75          #endif
     76          typedef struct {
     77          	FATFS *fs;		/* Object ID 1, volume (NULL:blank entry) */
     78          	DWORD clu;		/* Object ID 2, directory (0:root) */
     79          	DWORD ofs;		/* Object ID 3, directory offset */
     80          	WORD ctr;		/* Object open counter, 0:none, 0x01..0xFF:read mode open count, 0x100:write mode */
     81          } FILESEM;
     82          #endif
     83          
     84          
     85          
     86          /* DBCS code ranges and SBCS upper conversion tables */
     87          
     88          #if _CODE_PAGE == 932	/* Japanese Shift-JIS */
     89          #define _DF1S	0x81	/* DBC 1st byte range 1 start */
     90          #define _DF1E	0x9F	/* DBC 1st byte range 1 end */
     91          #define _DF2S	0xE0	/* DBC 1st byte range 2 start */
     92          #define _DF2E	0xFC	/* DBC 1st byte range 2 end */
     93          #define _DS1S	0x40	/* DBC 2nd byte range 1 start */
     94          #define _DS1E	0x7E	/* DBC 2nd byte range 1 end */
     95          #define _DS2S	0x80	/* DBC 2nd byte range 2 start */
     96          #define _DS2E	0xFC	/* DBC 2nd byte range 2 end */
     97          
     98          #elif _CODE_PAGE == 936	/* Simplified Chinese GBK */
     99          #define _DF1S	0x81
    100          #define _DF1E	0xFE
    101          #define _DS1S	0x40
    102          #define _DS1E	0x7E
    103          #define _DS2S	0x80
    104          #define _DS2E	0xFE
    105          
    106          #elif _CODE_PAGE == 949	/* Korean */
    107          #define _DF1S	0x81
    108          #define _DF1E	0xFE
    109          #define _DS1S	0x41
    110          #define _DS1E	0x5A
    111          #define _DS2S	0x61
    112          #define _DS2E	0x7A
    113          #define _DS3S	0x81
    114          #define _DS3E	0xFE
    115          
    116          #elif _CODE_PAGE == 950	/* Traditional Chinese Big5 */
    117          #define _DF1S	0x81
    118          #define _DF1E	0xFE
    119          #define _DS1S	0x40
    120          #define _DS1E	0x7E
    121          #define _DS2S	0xA1
    122          #define _DS2E	0xFE
    123          
    124          #elif _CODE_PAGE == 437	/* U.S. */
    125          #define _DF1S	0
    126          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    127          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    128          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    129          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    130          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    131          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    132          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    133          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    134          
    135          #elif _CODE_PAGE == 720	/* Arabic */
    136          #define _DF1S	0
    137          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    138          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    139          				0xA0,0xA1,0xA2,0xA3,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    140          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    141          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    142          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    143          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    144          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    145          
    146          #elif _CODE_PAGE == 737	/* Greek */
    147          #define _DF1S	0
    148          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    149          				0x90,0x92,0x92,0x93,0x94,0x95,0x96,0x97,0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87, \
    150          				0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F,0x90,0x91,0xAA,0x92,0x93,0x94,0x95,0x96, \
    151          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    152          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    153          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    154          				0x97,0xEA,0xEB,0xEC,0xE4,0xED,0xEE,0xEF,0xF5,0xF0,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    155          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    156          
    157          #elif _CODE_PAGE == 771	/* KBL */
    158          #define _DF1S	0
    159          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    160          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    161          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    162          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    163          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    164          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDC,0xDE,0xDE, \
    165          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    166          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFE,0xFF}
    167          
    168          #elif _CODE_PAGE == 775	/* Baltic */
    169          #define _DF1S	0
    170          #define _EXCVT {0x80,0x9A,0x91,0xA0,0x8E,0x95,0x8F,0x80,0xAD,0xED,0x8A,0x8A,0xA1,0x8D,0x8E,0x8F, \
    171          				0x90,0x92,0x92,0xE2,0x99,0x95,0x96,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    172          				0xA0,0xA1,0xE0,0xA3,0xA3,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    173          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    174          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    175          				0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xA5,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    176          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE3,0xE8,0xE8,0xEA,0xEA,0xEE,0xED,0xEE,0xEF, \
    177          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    178          
    179          #elif _CODE_PAGE == 850	/* Latin 1 */
    180          #define _DF1S	0
    181          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x41,0x43,0x45,0x45,0x45,0x49,0x49,0x49,0x41,0x41, \
    182          				0x45,0x92,0x92,0x4F,0x4F,0x4F,0x55,0x55,0x59,0x4F,0x55,0x4F,0x9C,0x4F,0x9E,0x9F, \
    183          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    184          				0xB0,0xB1,0xB2,0xB3,0xB4,0x41,0x41,0x41,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    185          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0x41,0x41,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    186          				0xD1,0xD1,0x45,0x45,0x45,0x49,0x49,0x49,0x49,0xD9,0xDA,0xDB,0xDC,0xDD,0x49,0xDF, \
    187          				0x4F,0xE1,0x4F,0x4F,0x4F,0x4F,0xE6,0xE8,0xE8,0x55,0x55,0x55,0x59,0x59,0xEE,0xEF, \
    188          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    189          
    190          #elif _CODE_PAGE == 852	/* Latin 2 */
    191          #define _DF1S	0
    192          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xDE,0x8F,0x80,0x9D,0xD3,0x8A,0x8A,0xD7,0x8D,0x8E,0x8F, \
    193          				0x90,0x91,0x91,0xE2,0x99,0x95,0x95,0x97,0x97,0x99,0x9A,0x9B,0x9B,0x9D,0x9E,0xAC, \
    194          				0xB5,0xD6,0xE0,0xE9,0xA4,0xA4,0xA6,0xA6,0xA8,0xA8,0xAA,0x8D,0xAC,0xB8,0xAE,0xAF, \
    195          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBD,0xBF, \
    196          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC6,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    197          				0xD1,0xD1,0xD2,0xD3,0xD2,0xD5,0xD6,0xD7,0xB7,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    198          				0xE0,0xE1,0xE2,0xE3,0xE3,0xD5,0xE6,0xE6,0xE8,0xE9,0xE8,0xEB,0xED,0xED,0xDD,0xEF, \
    199          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xEB,0xFC,0xFC,0xFE,0xFF}
    200          
    201          #elif _CODE_PAGE == 855	/* Cyrillic */
    202          #define _DF1S	0
    203          #define _EXCVT {0x81,0x81,0x83,0x83,0x85,0x85,0x87,0x87,0x89,0x89,0x8B,0x8B,0x8D,0x8D,0x8F,0x8F, \
    204          				0x91,0x91,0x93,0x93,0x95,0x95,0x97,0x97,0x99,0x99,0x9B,0x9B,0x9D,0x9D,0x9F,0x9F, \
    205          				0xA1,0xA1,0xA3,0xA3,0xA5,0xA5,0xA7,0xA7,0xA9,0xA9,0xAB,0xAB,0xAD,0xAD,0xAE,0xAF, \
    206          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB6,0xB6,0xB8,0xB8,0xB9,0xBA,0xBB,0xBC,0xBE,0xBE,0xBF, \
    207          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    208          				0xD1,0xD1,0xD3,0xD3,0xD5,0xD5,0xD7,0xD7,0xDD,0xD9,0xDA,0xDB,0xDC,0xDD,0xE0,0xDF, \
    209          				0xE0,0xE2,0xE2,0xE4,0xE4,0xE6,0xE6,0xE8,0xE8,0xEA,0xEA,0xEC,0xEC,0xEE,0xEE,0xEF, \
    210          				0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF8,0xFA,0xFA,0xFC,0xFC,0xFD,0xFE,0xFF}
    211          
    212          #elif _CODE_PAGE == 857	/* Turkish */
    213          #define _DF1S	0
    214          #define _EXCVT {0x80,0x9A,0x90,0xB6,0x8E,0xB7,0x8F,0x80,0xD2,0xD3,0xD4,0xD8,0xD7,0x49,0x8E,0x8F, \
    215          				0x90,0x92,0x92,0xE2,0x99,0xE3,0xEA,0xEB,0x98,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9E, \
    216          				0xB5,0xD6,0xE0,0xE9,0xA5,0xA5,0xA6,0xA6,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    217          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    218          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC7,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    219          				0xD0,0xD1,0xD2,0xD3,0xD4,0x49,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    220          				0xE0,0xE1,0xE2,0xE3,0xE5,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xDE,0xED,0xEE,0xEF, \
    221          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    222          
    223          #elif _CODE_PAGE == 860	/* Portuguese */
    224          #define _DF1S	0
    225          #define _EXCVT {0x80,0x9A,0x90,0x8F,0x8E,0x91,0x86,0x80,0x89,0x89,0x92,0x8B,0x8C,0x98,0x8E,0x8F, \
    226          				0x90,0x91,0x92,0x8C,0x99,0xA9,0x96,0x9D,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    227          				0x86,0x8B,0x9F,0x96,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    228          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    229          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    230          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    231          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    232          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    233          
    234          #elif _CODE_PAGE == 861	/* Icelandic */
    235          #define _DF1S	0
    236          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x8B,0x8B,0x8D,0x8E,0x8F, \
    237          				0x90,0x92,0x92,0x4F,0x99,0x8D,0x55,0x97,0x97,0x99,0x9A,0x9D,0x9C,0x9D,0x9E,0x9F, \
    238          				0xA4,0xA5,0xA6,0xA7,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    239          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    240          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    241          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    242          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    243          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    244          
    245          #elif _CODE_PAGE == 862	/* Hebrew */
    246          #define _DF1S	0
    247          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    248          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    249          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    250          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    251          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    252          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    253          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    254          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    255          
    256          #elif _CODE_PAGE == 863	/* Canadian-French */
    257          #define _DF1S	0
    258          #define _EXCVT {0x43,0x55,0x45,0x41,0x41,0x41,0x86,0x43,0x45,0x45,0x45,0x49,0x49,0x8D,0x41,0x8F, \
    259          				0x45,0x45,0x45,0x4F,0x45,0x49,0x55,0x55,0x98,0x4F,0x55,0x9B,0x9C,0x55,0x55,0x9F, \
    260          				0xA0,0xA1,0x4F,0x55,0xA4,0xA5,0xA6,0xA7,0x49,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    261          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    262          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    263          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    264          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    265          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    266          
    267          #elif _CODE_PAGE == 864	/* Arabic */
    268          #define _DF1S	0
    269          #define _EXCVT {0x80,0x9A,0x45,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    270          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    271          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    272          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    273          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    274          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    275          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    276          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    277          
    278          #elif _CODE_PAGE == 865	/* Nordic */
    279          #define _DF1S	0
    280          #define _EXCVT {0x80,0x9A,0x90,0x41,0x8E,0x41,0x8F,0x80,0x45,0x45,0x45,0x49,0x49,0x49,0x8E,0x8F, \
    281          				0x90,0x92,0x92,0x4F,0x99,0x4F,0x55,0x55,0x59,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    282          				0x41,0x49,0x4F,0x55,0xA5,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    283          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    284          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    285          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    286          				0xE0,0xE1,0xE2,0xE3,0xE4,0xE5,0xE6,0xE7,0xE8,0xE9,0xEA,0xEB,0xEC,0xED,0xEE,0xEF, \
    287          				0xF0,0xF1,0xF2,0xF3,0xF4,0xF5,0xF6,0xF7,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    288          
    289          #elif _CODE_PAGE == 866	/* Russian */
    290          #define _DF1S	0
    291          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    292          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    293          				0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    294          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    295          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    296          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xD6,0xD7,0xD8,0xD9,0xDA,0xDB,0xDC,0xDD,0xDE,0xDF, \
    297          				0x90,0x91,0x92,0x93,0x9d,0x95,0x96,0x97,0x98,0x99,0x9A,0x9B,0x9C,0x9D,0x9E,0x9F, \
    298          				0xF0,0xF0,0xF2,0xF2,0xF4,0xF4,0xF6,0xF6,0xF8,0xF9,0xFA,0xFB,0xFC,0xFD,0xFE,0xFF}
    299          
    300          #elif _CODE_PAGE == 869	/* Greek 2 */
    301          #define _DF1S	0
    302          #define _EXCVT {0x80,0x81,0x82,0x83,0x84,0x85,0x86,0x87,0x88,0x89,0x8A,0x8B,0x8C,0x8D,0x8E,0x8F, \
    303          				0x90,0x91,0x92,0x93,0x94,0x95,0x96,0x97,0x98,0x99,0x9A,0x86,0x9C,0x8D,0x8F,0x90, \
    304          				0x91,0x90,0x92,0x95,0xA4,0xA5,0xA6,0xA7,0xA8,0xA9,0xAA,0xAB,0xAC,0xAD,0xAE,0xAF, \
    305          				0xB0,0xB1,0xB2,0xB3,0xB4,0xB5,0xB6,0xB7,0xB8,0xB9,0xBA,0xBB,0xBC,0xBD,0xBE,0xBF, \
    306          				0xC0,0xC1,0xC2,0xC3,0xC4,0xC5,0xC6,0xC7,0xC8,0xC9,0xCA,0xCB,0xCC,0xCD,0xCE,0xCF, \
    307          				0xD0,0xD1,0xD2,0xD3,0xD4,0xD5,0xA4,0xA5,0xA6,0xD9,0xDA,0xDB,0xDC,0xA7,0xA8,0xDF, \
    308          				0xA9,0xAA,0xAC,0xAD,0xB5,0xB6,0xB7,0xB8,0xBD,0xBE,0xC6,0xC7,0xCF,0xCF,0xD0,0xEF, \
    309          				0xF0,0xF1,0xD1,0xD2,0xD3,0xF5,0xD4,0xF7,0xF8,0xF9,0xD5,0x96,0x95,0x98,0xFE,0xFF}
    310          
    311          #elif _CODE_PAGE == 1	/* ASCII (for only non-LFN cfg) */
    312          #if _USE_LFN != 0
    313          #error Cannot enable LFN without valid code page.
    314          #endif
    315          #define _DF1S	0
    316          
    317          #else
    318          #error Unknown code page
    319          
    320          #endif
    321          
    322          
    323          /* Character code support macros */
    324          #define IsUpper(c)	(((c)>='A')&&((c)<='Z'))
    325          #define IsLower(c)	(((c)>='a')&&((c)<='z'))
    326          #define IsDigit(c)	(((c)>='0')&&((c)<='9'))
    327          
    328          #if _DF1S != 0	/* Code page is DBCS */
    329          
    330          #ifdef _DF2S	/* Two 1st byte areas */
    331          #define IsDBCS1(c)	(((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E) || ((BYTE)(c) >= _DF2S && (BYTE)(c) <= _DF2E))
    332          #else			/* One 1st byte area */
    333          #define IsDBCS1(c)	((BYTE)(c) >= _DF1S && (BYTE)(c) <= _DF1E)
    334          #endif
    335          
    336          #ifdef _DS3S	/* Three 2nd byte areas */
    337          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E) || ((BYTE)(c) >= _DS3S && (BYTE)(c) <= _DS3E))
    338          #else			/* Two 2nd byte areas */
    339          #define IsDBCS2(c)	(((BYTE)(c) >= _DS1S && (BYTE)(c) <= _DS1E) || ((BYTE)(c) >= _DS2S && (BYTE)(c) <= _DS2E))
    340          #endif
    341          
    342          #else			/* Code page is SBCS */
    343          
    344          #define IsDBCS1(c)	0
    345          #define IsDBCS2(c)	0
    346          
    347          #endif /* _DF1S */
    348          
    349          
    350          /* Name status flags */
    351          #define NSFLAG		11		/* Index of name status byte in fn[] */
    352          #define NS_LOSS		0x01	/* Out of 8.3 format */
    353          #define NS_LFN		0x02	/* Force to create LFN entry */
    354          #define NS_LAST		0x04	/* Last segment */
    355          #define NS_BODY		0x08	/* Lower case flag (body) */
    356          #define NS_EXT		0x10	/* Lower case flag (ext) */
    357          #define NS_DOT		0x20	/* Dot entry */
    358          #define NS_NONAME	0x80	/* Not followed */
    359          
    360          
    361          /* Limits and Boundaries (Differ from specs but correct for real DOS/Windows) */
    362          #define MIN_FAT16	4086U			/* Minimum number of clusters of FAT16 */
    363          #define	MIN_FAT32	65526U			/* Minimum number of clusters of FAT32 */
    364          #define MAX_DIR		0x200000		/* Maximum size of FAT directory */
    365          #define MAX_DIR_EX	0x10000000		/* Maximum size of exFAT directory */
    366          
    367          
    368          /* FatFs refers the members in the FAT structures as byte array instead of
    369          / structure members because the structure is not binary compatible between
    370          / different platforms */
    371          
    372          #define BS_jmpBoot			0		/* x86 jump instruction (3-byte) */
    373          #define BS_OEMName			3		/* OEM name (8-byte) */
    374          #define BPB_BytsPerSec		11		/* Sector size [byte] (WORD) */
    375          #define BPB_SecPerClus		13		/* Cluster size [sector] (BYTE) */
    376          #define BPB_RsvdSecCnt		14		/* Size of reserved area [sector] (WORD) */
    377          #define BPB_NumFATs			16		/* Number of FATs (BYTE) */
    378          #define BPB_RootEntCnt		17		/* Size of root directory area for FAT12/16 [entry] (WORD) */
    379          #define BPB_TotSec16		19		/* Volume size (16-bit) [sector] (WORD) */
    380          #define BPB_Media			21		/* Media descriptor (BYTE) */
    381          #define BPB_FATSz16			22		/* FAT size (16-bit) [sector] (WORD) */
    382          #define BPB_SecPerTrk		24		/* Track size for int13h [sector] (WORD) */
    383          #define BPB_NumHeads		26		/* Number of heads for int13h (WORD) */
    384          #define BPB_HiddSec			28		/* Volume offset from top of the drive (DWORD) */
    385          #define BPB_TotSec32		32		/* Volume size (32-bit) [sector] (DWORD) */
    386          #define BS_DrvNum			36		/* Physical drive number for int13h (BYTE) */
    387          #define BS_NTres			37		/* Error flag (BYTE) */
    388          #define BS_BootSig			38		/* Extended boot signature (BYTE) */
    389          #define BS_VolID			39		/* Volume serial number (DWORD) */
    390          #define BS_VolLab			43		/* Volume label string (8-byte) */
    391          #define BS_FilSysType		54		/* File system type string (8-byte) */
    392          #define BPB_FATSz32			36		/* FAT size (32-bit) [sector] (DWORD) */
    393          #define BPB_ExtFlags		40		/* Extended flags (WORD) */
    394          
    395          #define BPB_FSVer32			42		/* FAT32: File system version (WORD) */
    396          #define BPB_RootClus32		44		/* FAT32: Root directory cluster (DWORD) */
    397          #define BPB_FSInfo32		48		/* FAT32: Offset of FSINFO sector (WORD) */
    398          #define BPB_BkBootSec32		50		/* FAT32: Offset of backup boot sector (WORD) */
    399          #define BS_DrvNum32			64		/* FAT32: Physical drive number for int13h (BYTE) */
    400          #define BS_NTres32			65		/* FAT32: Error flag (BYTE) */
    401          #define BS_BootSig32		66		/* FAT32: Extended boot signature (BYTE) */
    402          #define BS_VolID32			67		/* FAT32: Volume serial number (DWORD) */
    403          #define BS_VolLab32			71		/* FAT32: Volume label string (8-byte) */
    404          #define BS_FilSysType32		82		/* FAT32: File system type string (8-byte) */
    405          
    406          #define BPB_ZeroedEx		11		/* exFAT: Must be zero (35-byte) */
    407          #define BPB_VolOfsEx		64		/* exFAT: Volume offset from top of the drive [sector] (QWORD) */
    408          #define BPB_TotSecEx		72		/* exFAT: Volume size [sector] (QWORD) */
    409          #define BPB_FatOfsEx		80		/* exFAT: FAT offset from top of the volume [sector] (DWORD) */
    410          #define BPB_FatSzEx			84		/* exFAT: FAT size [sector] (DWORD) */
    411          #define BPB_DataOfsEx		88		/* exFAT: Data offset from top of the volume [sector] (DWORD) */
    412          #define BPB_NumClusEx		92		/* exFAT: Number of clusters (DWORD) */
    413          #define BPB_RootClusEx		96		/* exFAT: Root directory cluster (DWORD) */
    414          #define BPB_VolIDEx			100		/* exFAT: Volume serial number (DWORD) */
    415          #define BPB_FSVerEx			104		/* exFAT: File system version (WORD) */
    416          #define BPB_VolFlagEx		106		/* exFAT: Volume flags (BYTE) */
    417          #define BPB_ActFatEx		107		/* exFAT: Active FAT flags (BYTE) */
    418          #define BPB_BytsPerSecEx	108		/* exFAT: Log2 of sector size in byte (BYTE) */
    419          #define BPB_SecPerClusEx	109		/* exFAT: Log2 of cluster size in sector (BYTE) */
    420          #define BPB_NumFATsEx		110		/* exFAT: Number of FATs (BYTE) */
    421          #define BPB_DrvNumEx		111		/* exFAT: Physical drive number for int13h (BYTE) */
    422          #define BPB_PercInUseEx		112		/* exFAT: Percent in use (BYTE) */
    423          
    424          #define	FSI_LeadSig			0		/* FAT32 FSI: Leading signature (DWORD) */
    425          #define	FSI_StrucSig		484		/* FAT32 FSI: Structure signature (DWORD) */
    426          #define	FSI_Free_Count		488		/* FAT32 FSI: Number of free clusters (DWORD) */
    427          #define	FSI_Nxt_Free		492		/* FAT32 FSI: Last allocated cluster (DWORD) */
    428          
    429          #define MBR_Table			446		/* MBR: Partition table offset */
    430          #define	SZ_PTE				16		/* MBR: Size of a partition table entry */
    431          
    432          #define BS_55AA				510		/* Signature word (WORD) */
    433          
    434          #define	DIR_Name			0		/* Short file name (11) */
    435          #define	DIR_Attr			11		/* Attribute (1) */
    436          #define	DIR_NTres			12		/* Lower case flag (1) */
    437          #define DIR_CrtTime10		13		/* Created time sub-second (1) */
    438          #define	DIR_CrtTime			14		/* Created time (2) */
    439          #define	DIR_CrtDate			16		/* Created date (2) */
    440          #define DIR_LstAccDate		18		/* Last accessed date (2) */
    441          #define	DIR_FstClusHI		20		/* Higher 16-bit of first cluster (WORD) */
    442          #define	DIR_WrtTime			22		/* Modified time (2) */
    443          #define	DIR_WrtDate			24		/* Modified date (2) */
    444          #define	DIR_FstClusLO		26		/* Lower 16-bit of first cluster (WORD) */
    445          #define	DIR_FileSize		28		/* File size (DWORD) */
    446          #define	LDIR_Ord			0		/* LFN entry order and LLE flag (1) */
    447          #define	LDIR_Attr			11		/* LFN attribute (1) */
    448          #define	LDIR_Type			12		/* LFN type (1) */
    449          #define	LDIR_Chksum			13		/* Checksum of the SFN entry */
    450          #define	LDIR_FstClusLO		26		/* Must be zero (WORD) */
    451          #define	XDIR_Type			0		/* Type of exFAT directory entry (BYTE) */
    452          #define	XDIR_NumLabel		1		/* Number of volume label characters (BYTE) */
    453          #define	XDIR_Label			2		/* Volume label (11-WORD) */
    454          #define	XDIR_CaseSum		4		/* Sum of case conversion table (DWORD) */
    455          #define	XDIR_NumSec			1		/* Number of secondary entries (BYTE) */
    456          #define	XDIR_SetSum			2		/* Sum of the set of directory entries (WORD) */
    457          #define	XDIR_Attr			4		/* File attribute (WORD) */
    458          #define	XDIR_CrtTime		8		/* Created time (4) */
    459          #define	XDIR_ModTime		12		/* Modified time (4) */
    460          #define	XDIR_AccTime		16		/* Last accessed time (4) */
    461          #define	XDIR_CrtTime10		20		/* Created time subsecond (1) */
    462          #define	XDIR_ModTime10		21		/* Modified time subsecond (1) */
    463          #define	XDIR_CrtTZ			22		/* Created timezone (1) */
    464          #define	XDIR_ModTZ			23		/* Modified timezone (1) */
    465          #define	XDIR_AccTZ			24		/* Last accessed timezone (1) */
    466          #define	XDIR_GenFlags		33		/* Gneral flags (1) */
    467          #define	XDIR_NumName		35		/* Number of file name characters (BYTE) */
    468          #define	XDIR_NameHash		36		/* Hash of file name (WORD) */
    469          #define XDIR_ValidFileSize	40		/* Valid file size (QWORD) */
    470          #define	XDIR_FstClus		52		/* First cluster of the File/Directory (DWORD) */
    471          #define	XDIR_FileSize		56		/* File/Directory size (QWORD) */
    472          
    473          #define	SZDIRE				32		/* Size of a directory entry */
    474          #define	LLEF				0x40	/* Last long entry flag in LDIR_Ord */
    475          #define	DDEM				0xE5	/* Deleted directory entry mark at DIR_Name[0] */
    476          #define	RDDEM				0x05	/* Replacement of the character collides with DDEM */
    477          
    478          
    479          
    480          
    481          
    482          /*--------------------------------------------------------------------------
    483          
    484             Module Private Work Area
    485          
    486          ---------------------------------------------------------------------------*/
    487          
    488          /* Remark: Variables here without initial value shall be guaranteed zero/null
    489          /  at start-up. If not, either the linker or start-up routine being used is
    490          /  not compliance with C standard. */
    491          
    492          #if _VOLUMES < 1 || _VOLUMES > 9
    493          #error Wrong _VOLUMES setting
    494          #endif
    495          static FATFS *FatFs[_VOLUMES];	/* Pointer to the file system objects (logical drives) */
    496          static WORD Fsid;				/* File system mount ID */
    497          
    498          #if _FS_RPATH != 0 && _VOLUMES >= 2
    499          static BYTE CurrVol;			/* Current drive */
    500          #endif
    501          
    502          #if _FS_LOCK != 0
    503          static FILESEM Files[_FS_LOCK];	/* Open object lock semaphores */
    504          #endif
    505          
    506          #if _USE_LFN == 0			/* Non-LFN configuration */
    507          #define	DEF_NAMBUF			BYTE sfn[12]
    508          #define INIT_NAMBUF(dobj)	(dobj).fn = sfn
    509          #define	FREE_NAMBUF()
    510          #define	DEF_DIRBUF
    511          #define INIT_DIRBUF(fs)
    512          #define	FREE_DIRBUF()
    513          #else
    514          #if _MAX_LFN < 12 || _MAX_LFN > 255
    515          #error Wrong _MAX_LFN setting
    516          #endif
    517          
    518          #if _USE_LFN == 1		/* LFN enabled with static working buffer */
    519          #if _FS_EXFAT
    520          static BYTE	DirBuf[SZDIRE*19];	/* Directory entry block scratchpad buffer (19 entries in size) */
    521          #endif
    522          static WCHAR LfnBuf[_MAX_LFN+1];	/* LFN enabled with static working buffer */
    523          #define	DEF_NAMBUF		BYTE sfn[12]
    524          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = LfnBuf; }
    525          #define	FREE_NAMBUF()
    526          #define	DEF_DIRBUF
    527          #define INIT_DIRBUF(fs)
    528          #define	FREE_DIRBUF()
    529          
    530          #elif _USE_LFN == 2 	/* LFN enabled with dynamic working buffer on the stack */
    531          #if _FS_EXFAT
    532          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]; BYTE dbuf[SZDIRE*19]
    533          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; (dj).obj.fs->dirbuf = dbuf; }
    534          #define	FREE_NAMBUF()
    535          #define	DEF_DIRBUF		BYTE dbuf[SZDIRE*19]
    536          #define INIT_DIRBUF(fs)	fs->dirbuf = dbuf
    537          #define	FREE_DIRBUF()
    538          #else
    539          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR lbuf[_MAX_LFN+1]
    540          #define INIT_NAMBUF(dj)	{ (dj).fn = sfn; (dj).lfn = lbuf; }
    541          #define	FREE_NAMBUF()
    542          #define	DEF_DIRBUF
    543          #define INIT_DIRBUF(fs)
    544          #define	FREE_DIRBUF()
    545          #endif
    546          
    547          #elif _USE_LFN == 3 	/* LFN enabled with dynamic working buffer on the heap */
    548          #if _FS_EXFAT
    549          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
    550          #define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2 + SZDIRE*19); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; (dj).obj.fs->dirbuf = (BYTE*)(lfn+_MAX_LFN+1); }
    551          #define	FREE_NAMBUF()	ff_memfree(lfn)
    552          #define	DEF_DIRBUF		BYTE *dirb
    553          #define INIT_DIRBUF(fs)	{ dirb = ff_memalloc(SZDIRE*19); if (!dirb) LEAVE_FF(fs, FR_NOT_ENOUGH_CORE); fs->dirbuf = dirb; }
    554          #define	FREE_DIRBUF()	ff_memfree(dirb)
    555          #else
    556          #define	DEF_NAMBUF		BYTE sfn[12]; WCHAR *lfn
    557          #define INIT_NAMBUF(dj)	{ lfn = ff_memalloc((_MAX_LFN+1)*2); if (!lfn) LEAVE_FF((dj).obj.fs, FR_NOT_ENOUGH_CORE); (dj).fn = sfn; (dj).lfn = lfn; }
    558          #define	FREE_NAMBUF()	ff_memfree(lfn)
    559          #define	DEF_DIRBUF
    560          #define INIT_DIRBUF(fs)
    561          #define	FREE_DIRBUF()
    562          #endif
    563          
    564          #else
    565          #error Wrong _USE_LFN setting
    566          #endif
    567          #endif
    568          
    569          #ifdef _EXCVT
    570          static const BYTE ExCvt[] = _EXCVT;	/* Upper conversion table for SBCS extended characters */
    571          #endif
    572          
    573          
    574          
    575          
    576          
    577          
    578          /*--------------------------------------------------------------------------
    579          
    580             Module Private Functions
    581          
    582          ---------------------------------------------------------------------------*/
    583          
    584          
    585          /*-----------------------------------------------------------------------*/
    586          /* Load/Store multi-byte word in the FAT structure                       */
    587          /*-----------------------------------------------------------------------*/
    588          
    589          static
    590          WORD ld_word (const BYTE* ptr)	/*	 Load a 2-byte little-endian word */
    591          {
    592          	WORD rv;
    593          
    594          	rv = ptr[1];
    595          	rv = rv << 8 | ptr[0];
    596          	return rv;
    597          }
    598          
    599          static
    600          DWORD ld_dword (const BYTE* ptr)	/* Load a 4-byte little-endian word */
    601          {
    602          	DWORD rv;
    603          
    604          	rv = ptr[3];
    605          	rv = rv << 8 | ptr[2];
    606          	rv = rv << 8 | ptr[1];
    607          	rv = rv << 8 | ptr[0];
    608          	return rv;
    609          }
    610          
    611          #if _FS_EXFAT
    612          static
    613          QWORD ld_qword (const BYTE* ptr)	/* Load an 8-byte little-endian word */
    614          {
    615          	QWORD rv;
    616          
    617          	rv = ptr[7];
    618          	rv = rv << 8 | ptr[6];
    619          	rv = rv << 8 | ptr[5];
    620          	rv = rv << 8 | ptr[4];
    621          	rv = rv << 8 | ptr[3];
    622          	rv = rv << 8 | ptr[2];
    623          	rv = rv << 8 | ptr[1];
    624          	rv = rv << 8 | ptr[0];
    625          	return rv;
    626          }
    627          #endif
    628          
    629          #if !_FS_READONLY
    630          static
    631          void st_word (BYTE* ptr, WORD val)	/* Store a 2-byte word in little-endian */
    632          {
    633          	*ptr++ = (BYTE)val; val >>= 8;
    634          	*ptr++ = (BYTE)val;
    635          }
    636          
    637          static
    638          void st_dword (BYTE* ptr, DWORD val)	/* Store a 4-byte word in little-endian */
    639          {
    640          	*ptr++ = (BYTE)val; val >>= 8;
    641          	*ptr++ = (BYTE)val; val >>= 8;
    642          	*ptr++ = (BYTE)val; val >>= 8;
    643          	*ptr++ = (BYTE)val;
    644          }
    645          
    646          #if _FS_EXFAT
    647          static
    648          void st_qword (BYTE* ptr, QWORD val)	/* Store an 8-byte word in little-endian */
    649          {
    650          	*ptr++ = (BYTE)val; val >>= 8;
    651          	*ptr++ = (BYTE)val; val >>= 8;
    652          	*ptr++ = (BYTE)val; val >>= 8;
    653          	*ptr++ = (BYTE)val; val >>= 8;
    654          	*ptr++ = (BYTE)val; val >>= 8;
    655          	*ptr++ = (BYTE)val; val >>= 8;
    656          	*ptr++ = (BYTE)val; val >>= 8;
    657          	*ptr++ = (BYTE)val;
    658          }
    659          #endif
    660          #endif	/* !_FS_READONLY */
    661          
    662          
    663          
    664          /*-----------------------------------------------------------------------*/
    665          /* String functions                                                      */
    666          /*-----------------------------------------------------------------------*/
    667          
    668          /* Copy memory to memory */
    669          static
    670          void mem_cpy (void* dst, const void* src, UINT cnt) {
    671          	BYTE *d = (BYTE*)dst;
    672          	const BYTE *s = (const BYTE*)src;
    673          
    674          	if (cnt) {
    675          		do *d++ = *s++; while (--cnt);
    676          	}
    677          }
    678          
    679          /* Fill memory block */
    680          static
    681          void mem_set (void* dst, int val, UINT cnt) {
    682          	BYTE *d = (BYTE*)dst;
    683          
    684          	do *d++ = (BYTE)val; while (--cnt);
    685          }
    686          
    687          /* Compare memory block */
    688          static
    689          int mem_cmp (const void* dst, const void* src, UINT cnt) {	/* ZR:same, NZ:different */
    690          	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
    691          	int r = 0;
    692          
    693          	do {
    694          		r = *d++ - *s++;
    695          	} while (--cnt && r == 0);
    696          
    697          	return r;
    698          }
    699          
    700          /* Check if chr is contained in the string */
    701          static
    702          int chk_chr (const char* str, int chr) {	/* NZ:contained, ZR:not contained */
    703          	while (*str && *str != chr) str++;
    704          	return *str;
    705          }
    706          
    707          
    708          
    709          
    710          /*-----------------------------------------------------------------------*/
    711          /* Request/Release grant to access the volume                            */
    712          /*-----------------------------------------------------------------------*/
    713          #if _FS_REENTRANT
    714          static
    715          int lock_fs (
    716          	FATFS* fs		/* File system object */
    717          )
    718          {
    719          	return ff_req_grant(fs->sobj);
    720          }
    721          
    722          
    723          static
    724          void unlock_fs (
    725          	FATFS* fs,		/* File system object */
    726          	FRESULT res		/* Result code to be returned */
    727          )
    728          {
    729          	if (fs && res != FR_NOT_ENABLED && res != FR_INVALID_DRIVE && res != FR_TIMEOUT) {
    730          		ff_rel_grant(fs->sobj);
    731          	}
    732          }
    733          #endif
    734          
    735          
    736          
    737          
    738          /*-----------------------------------------------------------------------*/
    739          /* File lock control functions                                           */
    740          /*-----------------------------------------------------------------------*/
    741          #if _FS_LOCK != 0
    742          
    743          static
    744          FRESULT chk_lock (	/* Check if the file can be accessed */
    745          	DIR* dp,		/* Directory object pointing the file to be checked */
    746          	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
    747          )
    748          {
    749          	UINT i, be;
    750          
    751          	/* Search file semaphore table */
    752          	for (i = be = 0; i < _FS_LOCK; i++) {
    753          		if (Files[i].fs) {	/* Existing entry */
    754          			if (Files[i].fs == dp->obj.fs &&	 	/* Check if the object matched with an open object */
    755          				Files[i].clu == dp->obj.sclust &&
    756          				Files[i].ofs == dp->dptr) break;
    757          		} else {			/* Blank entry */
    758          			be = 1;
    759          		}
    760          	}
    761          	if (i == _FS_LOCK) {	/* The object is not opened */
    762          		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
    763          	}
    764          
    765          	/* The object has been opened. Reject any open against writing file and all write mode open */
    766          	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
    767          }
    768          
    769          
    770          static
    771          int enq_lock (void)	/* Check if an entry is available for a new object */
    772          {
    773          	UINT i;
    774          
    775          	for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    776          	return (i == _FS_LOCK) ? 0 : 1;
    777          }
    778          
    779          
    780          static
    781          UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
    782          	DIR* dp,	/* Directory object pointing the file to register or increment */
    783          	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
    784          )
    785          {
    786          	UINT i;
    787          
    788          
    789          	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
    790          		if (Files[i].fs == dp->obj.fs &&
    791          			Files[i].clu == dp->obj.sclust &&
    792          			Files[i].ofs == dp->dptr) break;
    793          	}
    794          
    795          	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
    796          		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
    797          		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
    798          		Files[i].fs = dp->obj.fs;
    799          		Files[i].clu = dp->obj.sclust;
    800          		Files[i].ofs = dp->dptr;
    801          		Files[i].ctr = 0;
    802          	}
    803          
    804          	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
    805          
    806          	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
    807          
    808          	return i + 1;
    809          }
    810          
    811          
    812          static
    813          FRESULT dec_lock (	/* Decrement object open counter */
    814          	UINT i			/* Semaphore index (1..) */
    815          )
    816          {
    817          	WORD n;
    818          	FRESULT res;
    819          
    820          
    821          	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
    822          		n = Files[i].ctr;
    823          		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
    824          		if (n > 0) n--;				/* Decrement read mode open count */
    825          		Files[i].ctr = n;
    826          		if (n == 0) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
    827          		res = FR_OK;
    828          	} else {
    829          		res = FR_INT_ERR;			/* Invalid index nunber */
    830          	}
    831          	return res;
    832          }
    833          
    834          
    835          static
    836          void clear_lock (	/* Clear lock entries of the volume */
    837          	FATFS *fs
    838          )
    839          {
    840          	UINT i;
    841          
    842          	for (i = 0; i < _FS_LOCK; i++) {
    843          		if (Files[i].fs == fs) Files[i].fs = 0;
    844          	}
    845          }
    846          #endif
    847          
    848          
    849          
    850          
    851          /*-----------------------------------------------------------------------*/
    852          /* Move/Flush disk access window in the file system object               */
    853          /*-----------------------------------------------------------------------*/
    854          #if !_FS_READONLY
    855          static
    856          FRESULT sync_window (	/* Returns FR_OK or FR_DISK_ERROR */
    857          	FATFS* fs			/* File system object */
    858          )
    859          {
    860          	DWORD wsect;
    861          	UINT nf;
    862          	FRESULT res = FR_OK;
    863          
    864          
    865          	if (fs->wflag) {	/* Write back the sector if it is dirty */
    866          		wsect = fs->winsect;	/* Current sector number */
    867          		if (disk_write(fs->drv, fs->win, wsect, 1) != RES_OK) {
    868          			res = FR_DISK_ERR;
    869          		} else {
    870          			fs->wflag = 0;
    871          			if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
    872          				for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
    873          					wsect += fs->fsize;
    874          					disk_write(fs->drv, fs->win, wsect, 1);
    875          				}
    876          			}
    877          		}
    878          	}
    879          	return res;
    880          }
    881          #endif
    882          
    883          
    884          static
    885          FRESULT move_window (	/* Returns FR_OK or FR_DISK_ERROR */
    886          	FATFS* fs,			/* File system object */
    887          	DWORD sector		/* Sector number to make appearance in the fs->win[] */
    888          )
    889          {
    890          	FRESULT res = FR_OK;
    891          
    892          
    893          	if (sector != fs->winsect) {	/* Window offset changed? */
    894          #if !_FS_READONLY
    895          		res = sync_window(fs);		/* Write-back changes */
    896          #endif
    897          		if (res == FR_OK) {			/* Fill sector window with new data */
    898          			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK) {
    899          				sector = 0xFFFFFFFF;	/* Invalidate window if data is not reliable */
    900          				res = FR_DISK_ERR;
    901          			}
    902          			fs->winsect = sector;
    903          		}
    904          	}
    905          	return res;
    906          }
    907          
    908          
    909          
    910          
    911          /*-----------------------------------------------------------------------*/
    912          /* Synchronize file system and strage device                             */
    913          /*-----------------------------------------------------------------------*/
    914          #if !_FS_READONLY
    915          static
    916          FRESULT sync_fs (	/* FR_OK:succeeded, !=0:error */
    917          	FATFS* fs		/* File system object */
    918          )
    919          {
    920          	FRESULT res;
    921          
    922          
    923          	res = sync_window(fs);
    924          	if (res == FR_OK) {
    925          		/* Update FSInfo sector if needed */
    926          		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
    927          			/* Create FSInfo structure */
    928          			mem_set(fs->win, 0, SS(fs));
    929          			st_word(fs->win + BS_55AA, 0xAA55);
    930          			st_dword(fs->win + FSI_LeadSig, 0x41615252);
    931          			st_dword(fs->win + FSI_StrucSig, 0x61417272);
    932          			st_dword(fs->win + FSI_Free_Count, fs->free_clst);
    933          			st_dword(fs->win + FSI_Nxt_Free, fs->last_clst);
    934          			/* Write it into the FSInfo sector */
    935          			fs->winsect = fs->volbase + 1;
    936          			disk_write(fs->drv, fs->win, fs->winsect, 1);
    937          			fs->fsi_flag = 0;
    938          		}
    939          		/* Make sure that no pending write process in the physical drive */
    940          		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK) res = FR_DISK_ERR;
    941          	}
    942          
    943          	return res;
    944          }
    945          #endif
    946          
    947          
    948          
    949          
    950          /*-----------------------------------------------------------------------*/
    951          /* Get sector# from cluster#                                             */
    952          /*-----------------------------------------------------------------------*/
    953          
    954          static
    955          DWORD clust2sect (	/* !=0:Sector number, 0:Failed (invalid cluster#) */
    956          	FATFS* fs,		/* File system object */
    957          	DWORD clst		/* Cluster# to be converted */
    958          )
    959          {
    960          	clst -= 2;
    961          	if (clst >= fs->n_fatent - 2) return 0;		/* Invalid cluster# */
    962          	return clst * fs->csize + fs->database;
    963          }
    964          
    965          
    966          
    967          
    968          /*-----------------------------------------------------------------------*/
    969          /* FAT access - Read value of a FAT entry                                */
    970          /*-----------------------------------------------------------------------*/
    971          
    972          static
    973          DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, 2..0x7FFFFFFF:Cluster status */
    974          	_FDID* obj,	/* Corresponding object */
    975          	DWORD clst	/* Cluster number to get the value */
    976          )
    977          {
    978          	UINT wc, bc;
    979          	DWORD val;
    980          	FATFS *fs = obj->fs;
    981          
    982          
    983          	if (clst < 2 || clst >= fs->n_fatent) {	/* Check if in valid range */
    984          		val = 1;	/* Internal error */
    985          
    986          	} else {
    987          		val = 0xFFFFFFFF;	/* Default value falls on disk error */
    988          
    989          		switch (fs->fs_type) {
    990          		case FS_FAT12 :
    991          			bc = (UINT)clst; bc += bc / 2;
    992          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    993          			wc = fs->win[bc++ % SS(fs)];
    994          			if (move_window(fs, fs->fatbase + (bc / SS(fs))) != FR_OK) break;
    995          			wc |= fs->win[bc % SS(fs)] << 8;
    996          			val = clst & 1 ? wc >> 4 : (wc & 0xFFF);
    997          			break;
    998          
    999          		case FS_FAT16 :
   1000          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2))) != FR_OK) break;
   1001          			val = ld_word(&fs->win[clst * 2 % SS(fs)]);
   1002          			break;
   1003          
   1004          		case FS_FAT32 :
   1005          			if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   1006          			val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x0FFFFFFF;
   1007          			break;
   1008          #if _FS_EXFAT
   1009          		case FS_EXFAT :
   1010          			if (obj->objsize) {
   1011          				DWORD cofs = clst - obj->sclust;	/* Offset from start cluster */
   1012          				DWORD clen = (DWORD)((obj->objsize - 1) / SS(fs)) / fs->csize;	/* Number of clusters - 1 */
   1013          
   1014          				if (obj->stat == 2) {	/* Is there no valid chain on the FAT? */
   1015          					if (cofs <= clen) {
   1016          						val = (cofs == clen) ? 0x7FFFFFFF : clst + 1;	/* Generate the value */
   1017          						break;
   1018          					}
   1019          				}
   1020          				if (obj->stat == 3 && cofs < obj->n_cont) {	/* Is it in the contiguous part? */
   1021          					val = clst + 1; 	/* Generate the value */
   1022          					break;
   1023          				}
   1024          				if (obj->stat != 2) {	/* Get value from FAT if FAT chain is valid */
   1025          					if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4))) != FR_OK) break;
   1026          					val = ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0x7FFFFFFF;
   1027          					break;
   1028          				}
   1029          			}
   1030          			/* Go default */
   1031          #endif
   1032          		default:
   1033          			val = 1;	/* Internal error */
   1034          		}
   1035          	}
   1036          
   1037          	return val;
   1038          }
   1039          
   1040          
   1041          
   1042          
   1043          /*-----------------------------------------------------------------------*/
   1044          /* FAT access - Change value of a FAT entry                              */
   1045          /*-----------------------------------------------------------------------*/
   1046          
   1047          #if !_FS_READONLY
   1048          static
   1049          FRESULT put_fat (	/* FR_OK(0):succeeded, !=0:error */
   1050          	FATFS* fs,		/* Corresponding object */
   1051          	DWORD clst,		/* FAT index number (cluster number) to be changed */
   1052          	DWORD val		/* New value to be set to the entry */
   1053          )
   1054          {
   1055          	UINT bc;
   1056          	BYTE *p;
   1057          	FRESULT res = FR_INT_ERR;
   1058          
   1059          
   1060          	if (clst >= 2 && clst < fs->n_fatent) {	/* Check if in valid range */
   1061          		switch (fs->fs_type) {
   1062          		case FS_FAT12 :	/* Bitfield items */
   1063          			bc = (UINT)clst; bc += bc / 2;
   1064          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1065          			if (res != FR_OK) break;
   1066          			p = &fs->win[bc++ % SS(fs)];
   1067          			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
   1068          			fs->wflag = 1;
   1069          			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
   1070          			if (res != FR_OK) break;
   1071          			p = &fs->win[bc % SS(fs)];
   1072          			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
   1073          			fs->wflag = 1;
   1074          			break;
   1075          
   1076          		case FS_FAT16 :	/* WORD aligned items */
   1077          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
   1078          			if (res != FR_OK) break;
   1079          			st_word(&fs->win[clst * 2 % SS(fs)], (WORD)val);
   1080          			fs->wflag = 1;
   1081          			break;
   1082          
   1083          		case FS_FAT32 :	/* DWORD aligned items */
   1084          #if _FS_EXFAT
   1085          		case FS_EXFAT :
   1086          #endif
   1087          			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
   1088          			if (res != FR_OK) break;
   1089          			if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1090          				val = (val & 0x0FFFFFFF) | (ld_dword(&fs->win[clst * 4 % SS(fs)]) & 0xF0000000);
   1091          			}
   1092          			st_dword(&fs->win[clst * 4 % SS(fs)], val);
   1093          			fs->wflag = 1;
   1094          			break;
   1095          		}
   1096          	}
   1097          	return res;
   1098          }
   1099          #endif /* !_FS_READONLY */
   1100          
   1101          
   1102          
   1103          
   1104          #if _FS_EXFAT && !_FS_READONLY
   1105          /*-----------------------------------------------------------------------*/
   1106          /* exFAT: Accessing FAT and Allocation Bitmap                            */
   1107          /*-----------------------------------------------------------------------*/
   1108          
   1109          /*---------------------------------------------*/
   1110          /* exFAT: Find a contiguous free cluster block */
   1111          /*---------------------------------------------*/
   1112          static
   1113          DWORD find_bitmap (	/* 0:No free cluster, 2..:Free cluster found, 0xFFFFFFFF:Disk error */
   1114          	FATFS* fs,	/* File system object */
   1115          	DWORD clst,	/* Cluster number to scan from */
   1116          	DWORD ncl	/* Number of contiguous clusters to find (1..) */
   1117          )
   1118          {
   1119          	BYTE bm, bv;
   1120          	UINT i;
   1121          	DWORD val, scl, ctr;
   1122          
   1123          
   1124          	clst -= 2;	/* The first bit in the bitmap corresponds to cluster #2 */
   1125          	if (clst >= fs->n_fatent - 2) clst = 0;
   1126          	scl = val = clst; ctr = 0;
   1127          	for (;;) {
   1128          		if (move_window(fs, fs->database + val / 8 / SS(fs)) != FR_OK) return 0xFFFFFFFF;
   1129          		i = val / 8 & (SS(fs) - 1); bm = 1 << (val % 8);
   1130          		do {
   1131          			do {
   1132          				bv = fs->win[i] & bm; bm <<= 1;		/* Get bit value */
   1133          				if (++val >= fs->n_fatent - 2) {	/* Next cluster (with wrap-around) */
   1134          					val = 0; bm = 0; i = 4096;
   1135          				}
   1136          				if (!bv) {	/* Is it a free cluster? */
   1137          					if (++ctr == ncl) return scl + 2;	/* Check run length */
   1138          				} else {
   1139          					scl = val; ctr = 0;		/* Encountered a live cluster, restart to scan */
   1140          				}
   1141          				if (val == clst) return 0;	/* All cluster scanned? */
   1142          			} while (bm);
   1143          			bm = 1;
   1144          		} while (++i < SS(fs));
   1145          	}
   1146          }
   1147          
   1148          /*------------------------------------*/
   1149          /* exFAT: Set/Clear a block of bitmap */
   1150          /*------------------------------------*/
   1151          static
   1152          FRESULT change_bitmap (
   1153          	FATFS* fs,	/* File system object */
   1154          	DWORD clst,	/* Cluster number to change from */
   1155          	DWORD ncl,	/* Number of clusters to be changed */
   1156          	int bv		/* bit value to be set (0 or 1) */
   1157          )
   1158          {
   1159          	BYTE bm;
   1160          	UINT i;
   1161          	DWORD sect;
   1162          
   1163          
   1164          	clst -= 2;	/* The first bit corresponds to cluster #2 */
   1165          	sect = fs->database + clst / 8 / SS(fs);	/* Sector address */
   1166          	i = clst / 8 & (SS(fs) - 1);				/* Byte offset in the sector */
   1167          	bm = 1 << (clst % 8);						/* Bit mask in the byte */
   1168          	for (;;) {
   1169          		if (move_window(fs, sect++) != FR_OK) return FR_DISK_ERR;
   1170          		do {
   1171          			do {
   1172          				if (bv == (int)((fs->win[i] & bm) != 0)) return FR_INT_ERR;	/* Is the bit expected value? */
   1173          				fs->win[i] ^= bm;	/* Flip the bit */
   1174          				fs->wflag = 1;
   1175          				if (--ncl == 0) return FR_OK;	/* All bits processed? */
   1176          			} while (bm <<= 1);		/* Next bit */
   1177          			bm = 1;
   1178          		} while (++i < SS(fs));		/* Next byte */
   1179          	}
   1180          }
   1181          
   1182          
   1183          /*---------------------------------------------*/
   1184          /* Complement contiguous part of the FAT chain */
   1185          /*---------------------------------------------*/
   1186          static
   1187          FRESULT fill_fat_chain (
   1188          	_FDID* obj	/* Pointer to the corresponding object */
   1189          )
   1190          {
   1191          	FRESULT res;
   1192          	DWORD cl, n;
   1193          
   1194          	if (obj->stat == 3) {	/* Has the object got fragmented? */
   1195          		for (cl = obj->sclust, n = obj->n_cont; n; cl++, n--) {	/* Create cluster chain on the FAT */
   1196          			res = put_fat(obj->fs, cl, cl + 1);
   1197          			if (res != FR_OK) return res;
   1198          		}
   1199          		obj->stat = 0;	/* Change status 'FAT chain is valid' */
   1200          	}
   1201          	return FR_OK;
   1202          }
   1203          
   1204          #endif
   1205          
   1206          
   1207          
   1208          /*-----------------------------------------------------------------------*/
   1209          /* FAT handling - Remove a cluster chain                                 */
   1210          /*-----------------------------------------------------------------------*/
   1211          #if !_FS_READONLY
   1212          static
   1213          FRESULT remove_chain (	/* FR_OK(0):succeeded, !=0:error */
   1214          	_FDID* obj,			/* Corresponding object */
   1215          	DWORD clst,			/* Cluster to remove a chain from */
   1216          	DWORD pclst			/* Previous cluster of clst (0:an entire chain) */
   1217          )
   1218          {
   1219          	FRESULT res = FR_OK;
   1220          	DWORD nxt;
   1221          	FATFS *fs = obj->fs;
   1222          #if _FS_EXFAT || _USE_TRIM
   1223          	DWORD scl = clst, ecl = clst;
   1224          #endif
   1225          #if _USE_TRIM
   1226          	DWORD rt[2];
   1227          #endif
   1228          
   1229          	if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Check if in valid range */
   1230          
   1231          	/* Mark the previous cluster 'EOC' on the FAT if it exists */
   1232          	if (pclst && (!_FS_EXFAT || fs->fs_type != FS_EXFAT || obj->stat != 2)) {
   1233          		res = put_fat(fs, pclst, 0xFFFFFFFF);
   1234          		if (res != FR_OK) return res;
   1235          	}
   1236          
   1237          	/* Remove the chain */
   1238          	do {
   1239          		nxt = get_fat(obj, clst);			/* Get cluster status */
   1240          		if (nxt == 0) break;				/* Empty cluster? */
   1241          		if (nxt == 1) return FR_INT_ERR;	/* Internal error? */
   1242          		if (nxt == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error? */
   1243          		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   1244          			res = put_fat(fs, clst, 0);		/* Mark the cluster 'free' on the FAT */
   1245          			if (res != FR_OK) return res;
   1246          		}
   1247          		if (fs->free_clst != 0xFFFFFFFF) {	/* Update FSINFO */
   1248          			fs->free_clst++;
   1249          			fs->fsi_flag |= 1;
   1250          		}
   1251          #if _FS_EXFAT || _USE_TRIM
   1252          		if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
   1253          			ecl = nxt;
   1254          		} else {				/* End of contiguous cluster block */
   1255          #if _FS_EXFAT
   1256          			if (fs->fs_type == FS_EXFAT) {
   1257          				res = change_bitmap(fs, scl, ecl - scl + 1, 0);	/* Mark the cluster block 'free' on the bitmap */
   1258          				if (res != FR_OK) return res;
   1259          			}
   1260          #endif
   1261          #if _USE_TRIM
   1262          			rt[0] = clust2sect(fs, scl);					/* Start sector */
   1263          			rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
   1264          			disk_ioctl(fs->drv, CTRL_TRIM, rt);				/* Inform device the block can be erased */
   1265          #endif
   1266          			scl = ecl = nxt;
   1267          		}
   1268          #endif
   1269          		clst = nxt;					/* Next cluster */
   1270          	} while (clst < fs->n_fatent);	/* Repeat while not the last link */
   1271          
   1272          #if _FS_EXFAT
   1273          	if (fs->fs_type == FS_EXFAT) {
   1274          		if (pclst == 0) {	/* Does object have no chain? */
   1275          			obj->stat = 0;		/* Change the object status 'initial' */
   1276          		} else {
   1277          			if (obj->stat == 3 && pclst >= obj->sclust && pclst <= obj->sclust + obj->n_cont) {	/* Did the chain got contiguous? */
   1278          				obj->stat = 2;	/* Change the object status 'contiguous' */
   1279          			}
   1280          		}
   1281          	}
   1282          #endif
   1283          	return FR_OK;
   1284          }
   1285          #endif
   1286          
   1287          
   1288          
   1289          
   1290          /*-----------------------------------------------------------------------*/
   1291          /* FAT handling - Stretch a chain or Create a new chain                  */
   1292          /*-----------------------------------------------------------------------*/
   1293          #if !_FS_READONLY
   1294          static
   1295          DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
   1296          	_FDID* obj,			/* Corresponding object */
   1297          	DWORD clst			/* Cluster# to stretch, 0:Create a new chain */
   1298          )
   1299          {
   1300          	DWORD cs, ncl, scl;
   1301          	FRESULT res;
   1302          	FATFS *fs = obj->fs;
   1303          
   1304          
   1305          	if (clst == 0) {	/* Create a new chain */
   1306          		scl = fs->last_clst;				/* Get suggested cluster to start at */
   1307          		if (scl == 0 || scl >= fs->n_fatent) scl = 1;
   1308          	}
   1309          	else {				/* Stretch current chain */
   1310          		cs = get_fat(obj, clst);			/* Check the cluster status */
   1311          		if (cs < 2) return 1;				/* Invalid value */
   1312          		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
   1313          		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
   1314          		scl = clst;
   1315          	}
   1316          
   1317          #if _FS_EXFAT
   1318          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   1319          		ncl = find_bitmap(fs, scl, 1);				/* Find a free cluster */
   1320          		if (ncl == 0 || ncl == 0xFFFFFFFF) return ncl;	/* No free cluster or hard error? */
   1321          		res = change_bitmap(fs, ncl, 1, 1);			/* Mark the cluster 'in use' */
   1322          		if (res == FR_INT_ERR) return 1;
   1323          		if (res == FR_DISK_ERR) return 0xFFFFFFFF;
   1324          		if (clst == 0) {							/* Is it a new chain? */
   1325          			obj->stat = 2;							/* Set status 'contiguous chain' */
   1326          		} else {									/* This is a stretched chain */
   1327          			if (obj->stat == 2 && ncl != scl + 1) {	/* Is the chain got fragmented? */
   1328          				obj->n_cont = scl - obj->sclust;	/* Set size of the contiguous part */
   1329          				obj->stat = 3;						/* Change status 'just fragmented' */
   1330          			}
   1331          		}
   1332          	} else
   1333          #endif
   1334          	{	/* At the FAT12/16/32 */
   1335          		ncl = scl;	/* Start cluster */
   1336          		for (;;) {
   1337          			ncl++;							/* Next cluster */
   1338          			if (ncl >= fs->n_fatent) {		/* Check wrap-around */
   1339          				ncl = 2;
   1340          				if (ncl > scl) return 0;	/* No free cluster */
   1341          			}
   1342          			cs = get_fat(obj, ncl);			/* Get the cluster status */
   1343          			if (cs == 0) break;				/* Found a free cluster */
   1344          			if (cs == 1 || cs == 0xFFFFFFFF) return cs;	/* An error occurred */
   1345          			if (ncl == scl) return 0;		/* No free cluster */
   1346          		}
   1347          	}
   1348          
   1349          	if (_FS_EXFAT && fs->fs_type == FS_EXFAT && obj->stat == 2) {	/* Is it a contiguous chain? */
   1350          		res = FR_OK;						/* FAT does not need to be written */
   1351          	} else {
   1352          		res = put_fat(fs, ncl, 0xFFFFFFFF);	/* Mark the new cluster 'EOC' */
   1353          		if (res == FR_OK && clst) {
   1354          			res = put_fat(fs, clst, ncl);	/* Link it from the previous one if needed */
   1355          		}
   1356          	}
   1357          
   1358          	if (res == FR_OK) {			/* Update FSINFO if function succeeded. */
   1359          		fs->last_clst = ncl;
   1360          		if (fs->free_clst < fs->n_fatent - 2) fs->free_clst--;
   1361          		fs->fsi_flag |= 1;
   1362          	} else {
   1363          		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;	/* Failed. Create error status */
   1364          	}
   1365          
   1366          	return ncl;		/* Return new cluster number or error status */
   1367          }
   1368          #endif /* !_FS_READONLY */
   1369          
   1370          
   1371          
   1372          
   1373          /*-----------------------------------------------------------------------*/
   1374          /* FAT handling - Convert offset into cluster with link map table        */
   1375          /*-----------------------------------------------------------------------*/
   1376          
   1377          #if _USE_FASTSEEK
   1378          static
   1379          DWORD clmt_clust (	/* <2:Error, >=2:Cluster number */
   1380          	FIL* fp,		/* Pointer to the file object */
   1381          	DWORD ofs		/* File offset to be converted to cluster# */
   1382          )
   1383          {
   1384          	DWORD cl, ncl, *tbl;
   1385          	FATFS *fs = fp->obj.fs;
   1386          
   1387          
   1388          	tbl = fp->cltbl + 1;	/* Top of CLMT */
   1389          	cl = ofs / SS(fs) / fs->csize;	/* Cluster order from top of the file */
   1390          	for (;;) {
   1391          		ncl = *tbl++;			/* Number of cluters in the fragment */
   1392          		if (ncl == 0) return 0;	/* End of table? (error) */
   1393          		if (cl < ncl) break;	/* In this fragment? */
   1394          		cl -= ncl; tbl++;		/* Next fragment */
   1395          	}
   1396          	return cl + *tbl;	/* Return the cluster number */
   1397          }
   1398          #endif	/* _USE_FASTSEEK */
   1399          
   1400          
   1401          
   1402          /*-----------------------------------------------------------------------*/
   1403          /* Directory handling - Set directory index                              */
   1404          /*-----------------------------------------------------------------------*/
   1405          
   1406          static
   1407          FRESULT dir_sdi (	/* FR_OK(0):succeeded, !=0:error */
   1408          	DIR* dp,		/* Pointer to directory object */
   1409          	DWORD ofs		/* Offset of directory table */
   1410          )
   1411          {
   1412          	DWORD csz, clst;
   1413          	FATFS *fs = dp->obj.fs;
   1414          
   1415          
   1416          	if (ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR) || ofs % SZDIRE) {	/* Check range of offset and alignment */
   1417          		return FR_INT_ERR;
   1418          	}
   1419          	dp->dptr = ofs;				/* Set current offset */
   1420          	clst = dp->obj.sclust;		/* Table start cluster (0:root) */
   1421          	if (clst == 0 && fs->fs_type >= FS_FAT32) {	/* Replace cluster# 0 with root cluster# */
   1422          		clst = fs->dirbase;
   1423          		if (_FS_EXFAT) dp->obj.stat = 0;	/* exFAT: Root dir has an FAT chain */
   1424          	}
   1425          
   1426          	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
   1427          		if (ofs / SZDIRE >= fs->n_rootdir)	return FR_INT_ERR;	/* Is index out of range? */
   1428          		dp->sect = fs->dirbase;
   1429          
   1430          	} else {			/* Dynamic table (sub-directory or root-directory in FAT32+) */
   1431          		csz = (DWORD)fs->csize * SS(fs);	/* Bytes per cluster */
   1432          		while (ofs >= csz) {				/* Follow cluster chain */
   1433          			clst = get_fat(&dp->obj, clst);				/* Get next cluster */
   1434          			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1435          			if (clst < 2 || clst >= fs->n_fatent) return FR_INT_ERR;	/* Reached to end of table or internal error */
   1436          			ofs -= csz;
   1437          		}
   1438          		dp->sect = clust2sect(fs, clst);
   1439          	}
   1440          	dp->clust = clst;					/* Current cluster# */
   1441          	if (!dp->sect) return FR_INT_ERR;
   1442          	dp->sect += ofs / SS(fs);			/* Sector# of the directory entry */
   1443          	dp->dir = fs->win + (ofs % SS(fs));	/* Pointer to the entry in the win[] */
   1444          
   1445          	return FR_OK;
   1446          }
   1447          
   1448          
   1449          
   1450          
   1451          /*-----------------------------------------------------------------------*/
   1452          /* Directory handling - Move directory table index next                  */
   1453          /*-----------------------------------------------------------------------*/
   1454          
   1455          static
   1456          FRESULT dir_next (	/* FR_OK(0):succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
   1457          	DIR* dp,		/* Pointer to the directory object */
   1458          	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
   1459          )
   1460          {
   1461          	DWORD ofs, clst;
   1462          	FATFS *fs = dp->obj.fs;
   1463          #if !_FS_READONLY
   1464          	UINT n;
   1465          #endif
   1466          
   1467          	ofs = dp->dptr + SZDIRE;	/* Next entry */
   1468          	if (!dp->sect || ofs >= (DWORD)((_FS_EXFAT && fs->fs_type == FS_EXFAT) ? MAX_DIR_EX : MAX_DIR)) return FR_NO_FILE;	/* Report EOT when offset has reached max value */
   1469          
   1470          	if (ofs % SS(fs) == 0) {	/* Sector changed? */
   1471          		dp->sect++;				/* Next sector */
   1472          
   1473          		if (!dp->clust) {		/* Static table */
   1474          			if (ofs / SZDIRE >= fs->n_rootdir) {	/* Report EOT if it reached end of static table */
   1475          				dp->sect = 0; return FR_NO_FILE;
   1476          			}
   1477          		}
   1478          		else {					/* Dynamic table */
   1479          			if ((ofs / SS(fs) & (fs->csize - 1)) == 0) {		/* Cluster changed? */
   1480          				clst = get_fat(&dp->obj, dp->clust);			/* Get next cluster */
   1481          				if (clst <= 1) return FR_INT_ERR;				/* Internal error */
   1482          				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;		/* Disk error */
   1483          				if (clst >= fs->n_fatent) {						/* Reached end of dynamic table */
   1484          #if !_FS_READONLY
   1485          					if (!stretch) {								/* If no stretch, report EOT */
   1486          						dp->sect = 0; return FR_NO_FILE;
   1487          					}
   1488          					clst = create_chain(&dp->obj, dp->clust);	/* Allocate a cluster */
   1489          					if (clst == 0) return FR_DENIED;			/* No free cluster */
   1490          					if (clst == 1) return FR_INT_ERR;			/* Internal error */
   1491          					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
   1492          					/* Clean-up the stretched table */
   1493          					if (_FS_EXFAT) dp->obj.stat |= 4;			/* The directory needs to be updated */
   1494          					if (sync_window(fs) != FR_OK) return FR_DISK_ERR;	/* Flush disk access window */
   1495          					mem_set(fs->win, 0, SS(fs));				/* Clear window buffer */
   1496          					for (n = 0, fs->winsect = clust2sect(fs, clst); n < fs->csize; n++, fs->winsect++) {	/* Fill the new cluster with 0 */
   1497          						fs->wflag = 1;
   1498          						if (sync_window(fs) != FR_OK) return FR_DISK_ERR;
   1499          					}
   1500          					fs->winsect -= n;							/* Restore window offset */
   1501          #else
   1502          					if (!stretch) dp->sect = 0;					/* If no stretch, report EOT (this is to suppress warning) */
   1503          					dp->sect = 0; return FR_NO_FILE;			/* Report EOT */
   1504          #endif
   1505          				}
   1506          				dp->clust = clst;		/* Initialize data for new cluster */
   1507          				dp->sect = clust2sect(fs, clst);
   1508          			}
   1509          		}
   1510          	}
   1511          	dp->dptr = ofs;						/* Current entry */
   1512          	dp->dir = &fs->win[ofs % SS(fs)];	/* Pointer to the entry in the win[] */
   1513          
   1514          	return FR_OK;
   1515          }
   1516          
   1517          
   1518          
   1519          
   1520          /*-----------------------------------------------------------------------*/
   1521          /* Directory handling - Reserve a block of directory entries             */
   1522          /*-----------------------------------------------------------------------*/
   1523          
   1524          #if !_FS_READONLY
   1525          static
   1526          FRESULT dir_alloc (	/* FR_OK(0):succeeded, !=0:error */
   1527          	DIR* dp,		/* Pointer to the directory object */
   1528          	UINT nent		/* Number of contiguous entries to allocate */
   1529          )
   1530          {
   1531          	FRESULT res;
   1532          	UINT n;
   1533          	FATFS *fs = dp->obj.fs;
   1534          
   1535          
   1536          	res = dir_sdi(dp, 0);
   1537          	if (res == FR_OK) {
   1538          		n = 0;
   1539          		do {
   1540          			res = move_window(fs, dp->sect);
   1541          			if (res != FR_OK) break;
   1542          #if _FS_EXFAT
   1543          			if (fs->fs_type == FS_EXFAT ? (int)((dp->dir[XDIR_Type] & 0x80) == 0) : (int)(dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0)) {
   1544          #else
   1545          			if (dp->dir[DIR_Name] == DDEM || dp->dir[DIR_Name] == 0) {
   1546          #endif
   1547          				if (++n == nent) break;	/* A block of contiguous free entries is found */
   1548          			} else {
   1549          				n = 0;					/* Not a blank entry. Restart to search */
   1550          			}
   1551          			res = dir_next(dp, 1);
   1552          		} while (res == FR_OK);	/* Next entry with table stretch enabled */
   1553          	}
   1554          
   1555          	if (res == FR_NO_FILE) res = FR_DENIED;	/* No directory entry to allocate */
   1556          	return res;
   1557          }
   1558          #endif
   1559          
   1560          
   1561          
   1562          
   1563          /*-----------------------------------------------------------------------*/
   1564          /* FAT: Directory handling - Load/Store start cluster number             */
   1565          /*-----------------------------------------------------------------------*/
   1566          
   1567          static
   1568          DWORD ld_clust (	/* Returns the top cluster value of the SFN entry */
   1569          	FATFS* fs,		/* Pointer to the fs object */
   1570          	const BYTE* dir	/* Pointer to the key entry */
   1571          )
   1572          {
   1573          	DWORD cl;
   1574          
   1575          	cl = ld_word(dir + DIR_FstClusLO);
   1576          	if (fs->fs_type == FS_FAT32) {
   1577          		cl |= (DWORD)ld_word(dir + DIR_FstClusHI) << 16;
   1578          	}
   1579          
   1580          	return cl;
   1581          }
   1582          
   1583          
   1584          #if !_FS_READONLY
   1585          static
   1586          void st_clust (
   1587          	FATFS* fs,	/* Pointer to the fs object */
   1588          	BYTE* dir,	/* Pointer to the key entry */
   1589          	DWORD cl	/* Value to be set */
   1590          )
   1591          {
   1592          	st_word(dir + DIR_FstClusLO, (WORD)cl);
   1593          	if (fs->fs_type == FS_FAT32) {
   1594          		st_word(dir + DIR_FstClusHI, (WORD)(cl >> 16));
   1595          	}
   1596          }
   1597          #endif
   1598          
   1599          
   1600          
   1601          
   1602          /*------------------------------------------------------------------------*/
   1603          /* FAT-LFN: LFN handling                                                  */
   1604          /*------------------------------------------------------------------------*/
   1605          #if _USE_LFN != 0
   1606          static
   1607          const BYTE LfnOfs[] = {1,3,5,7,9,14,16,18,20,22,24,28,30};	/* Offset of LFN characters in the directory entry */
   1608          
   1609          /*--------------------------------------------------------*/
   1610          /* FAT-LFN: Compare a part of file name with an LFN entry */
   1611          /*--------------------------------------------------------*/
   1612          static
   1613          int cmp_lfn (				/* 1:matched, 0:not matched */
   1614          	const WCHAR* lfnbuf,	/* Pointer to the LFN working buffer to be compared */
   1615          	BYTE* dir				/* Pointer to the directory entry containing the part of LFN */
   1616          )
   1617          {
   1618          	UINT i, s;
   1619          	WCHAR wc, uc;
   1620          
   1621          
   1622          	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1623          
   1624          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1625          
   1626          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1627          		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
   1628          		if (wc) {
   1629          			if (i >= _MAX_LFN || ff_wtoupper(uc) != ff_wtoupper(lfnbuf[i++])) {	/* Compare it */
   1630          				return 0;					/* Not matched */
   1631          			}
   1632          			wc = uc;
   1633          		} else {
   1634          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1635          		}
   1636          	}
   1637          
   1638          	if ((dir[LDIR_Ord] & LLEF) && wc && lfnbuf[i]) return 0;	/* Last segment matched but different length */
   1639          
   1640          	return 1;		/* The part of LFN matched */
   1641          }
   1642          
   1643          
   1644          
   1645          #if _FS_MINIMIZE <= 1 || _FS_EXFAT
   1646          /*-----------------------------------------------------*/
   1647          /* FAT-LFN: Pick a part of file name from an LFN entry */
   1648          /*-----------------------------------------------------*/
   1649          static
   1650          int pick_lfn (			/* 1:succeeded, 0:buffer overflow or invalid LFN entry */
   1651          	WCHAR* lfnbuf,		/* Pointer to the LFN working buffer */
   1652          	BYTE* dir			/* Pointer to the LFN entry */
   1653          )
   1654          {
   1655          	UINT i, s;
   1656          	WCHAR wc, uc;
   1657          
   1658          
   1659          	if (ld_word(dir + LDIR_FstClusLO) != 0) return 0;	/* Check LDIR_FstClusLO */
   1660          
   1661          	i = ((dir[LDIR_Ord] & 0x3F) - 1) * 13;	/* Offset in the LFN buffer */
   1662          
   1663          	for (wc = 1, s = 0; s < 13; s++) {		/* Process all characters in the entry */
   1664          		uc = ld_word(dir + LfnOfs[s]);		/* Pick an LFN character */
   1665          		if (wc) {
   1666          			if (i >= _MAX_LFN) return 0;	/* Buffer overflow? */
   1667          			lfnbuf[i++] = wc = uc;			/* Store it */
   1668          		} else {
   1669          			if (uc != 0xFFFF) return 0;		/* Check filler */
   1670          		}
   1671          	}
   1672          
   1673          	if (dir[LDIR_Ord] & LLEF) {				/* Put terminator if it is the last LFN part */
   1674          		if (i >= _MAX_LFN) return 0;		/* Buffer overflow? */
   1675          		lfnbuf[i] = 0;
   1676          	}
   1677          
   1678          	return 1;		/* The part of LFN is valid */
   1679          }
   1680          #endif
   1681          
   1682          #if !_FS_READONLY
   1683          /*-----------------------------------------*/
   1684          /* FAT-LFN: Create an entry of LFN entries */
   1685          /*-----------------------------------------*/
   1686          static
   1687          void put_lfn (
   1688          	const WCHAR* lfn,	/* Pointer to the LFN */
   1689          	BYTE* dir,			/* Pointer to the LFN entry to be created */
   1690          	BYTE ord,			/* LFN order (1-20) */
   1691          	BYTE sum			/* Checksum of the corresponding SFN */
   1692          )
   1693          {
   1694          	UINT i, s;
   1695          	WCHAR wc;
   1696          
   1697          
   1698          	dir[LDIR_Chksum] = sum;			/* Set checksum */
   1699          	dir[LDIR_Attr] = AM_LFN;		/* Set attribute. LFN entry */
   1700          	dir[LDIR_Type] = 0;
   1701          	st_word(dir + LDIR_FstClusLO, 0);
   1702          
   1703          	i = (ord - 1) * 13;				/* Get offset in the LFN working buffer */
   1704          	s = wc = 0;
   1705          	do {
   1706          		if (wc != 0xFFFF) wc = lfn[i++];	/* Get an effective character */
   1707          		st_word(dir + LfnOfs[s], wc);		/* Put it */
   1708          		if (wc == 0) wc = 0xFFFF;		/* Padding characters for left locations */
   1709          	} while (++s < 13);
   1710          	if (wc == 0xFFFF || !lfn[i]) ord |= LLEF;	/* Last LFN part is the start of LFN sequence */
   1711          	dir[LDIR_Ord] = ord;			/* Set the LFN order */
   1712          }
   1713          
   1714          #endif
   1715          #endif
   1716          
   1717          
   1718          
   1719          /*-----------------------------------------------------------------------*/
   1720          /* FAT-LFN: Create a Numbered SFN                                        */
   1721          /*-----------------------------------------------------------------------*/
   1722          #if _USE_LFN != 0 && !_FS_READONLY
   1723          static
   1724          void gen_numname (
   1725          	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
   1726          	const BYTE* src,	/* Pointer to SFN */
   1727          	const WCHAR* lfn,	/* Pointer to LFN */
   1728          	UINT seq			/* Sequence number */
   1729          )
   1730          {
   1731          	BYTE ns[8], c;
   1732          	UINT i, j;
   1733          	WCHAR wc;
   1734          	DWORD sr;
   1735          
   1736          
   1737          	mem_cpy(dst, src, 11);
   1738          
   1739          	if (seq > 5) {	/* In case of many collisions, generate a hash number instead of sequential number */
   1740          		sr = seq;
   1741          		while (*lfn) {	/* Create a CRC */
   1742          			wc = *lfn++;
   1743          			for (i = 0; i < 16; i++) {
   1744          				sr = (sr << 1) + (wc & 1);
   1745          				wc >>= 1;
   1746          				if (sr & 0x10000) sr ^= 0x11021;
   1747          			}
   1748          		}
   1749          		seq = (UINT)sr;
   1750          	}
   1751          
   1752          	/* itoa (hexdecimal) */
   1753          	i = 7;
   1754          	do {
   1755          		c = (seq % 16) + '0';
   1756          		if (c > '9') c += 7;
   1757          		ns[i--] = c;
   1758          		seq /= 16;
   1759          	} while (seq);
   1760          	ns[i] = '~';
   1761          
   1762          	/* Append the number */
   1763          	for (j = 0; j < i && dst[j] != ' '; j++) {
   1764          		if (IsDBCS1(dst[j])) {
   1765          			if (j == i - 1) break;
   1766          			j++;
   1767          		}
   1768          	}
   1769          	do {
   1770          		dst[j++] = (i < 8) ? ns[i++] : ' ';
   1771          	} while (j < 8);
   1772          }
   1773          #endif
   1774          
   1775          
   1776          
   1777          /*-----------------------------------------------------------------------*/
   1778          /* FAT-LFN: Calculate checksum of an SFN entry                           */
   1779          /*-----------------------------------------------------------------------*/
   1780          #if _USE_LFN != 0
   1781          static
   1782          BYTE sum_sfn (
   1783          	const BYTE* dir		/* Pointer to the SFN entry */
   1784          )
   1785          {
   1786          	BYTE sum = 0;
   1787          	UINT n = 11;
   1788          
   1789          	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
   1790          	return sum;
   1791          }
   1792          #endif
   1793          
   1794          
   1795          
   1796          
   1797          #if _FS_EXFAT
   1798          /*-----------------------------------------------------------------------*/
   1799          /* exFAT: Directory handling - Load/Store a block of directory entries   */
   1800          /*-----------------------------------------------------------------------*/
   1801          
   1802          static
   1803          WORD xdir_sum (			/* Get checksum of the directoly block */
   1804          	const BYTE* dir		/* Directory entry block to be calculated */
   1805          )
   1806          {
   1807          	UINT i, szblk;
   1808          	WORD sum;
   1809          
   1810          
   1811          	szblk = (dir[XDIR_NumSec] + 1) * SZDIRE;
   1812          	for (i = sum = 0; i < szblk; i++) {
   1813          		if (i == XDIR_SetSum) {	/* Skip sum field */
   1814          			i++;
   1815          		} else {
   1816          			sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + dir[i];
   1817          		}
   1818          	}
   1819          	return sum;
   1820          }
   1821          
   1822          
   1823          
   1824          static
   1825          WORD xname_sum (		/* Get check sum (to be used as hash) of the name */
   1826          	const WCHAR* name	/* File name to be calculated */
   1827          )
   1828          {
   1829          	WCHAR chr;
   1830          	WORD sum = 0;
   1831          
   1832          
   1833          	while ((chr = *name++) != 0) {
   1834          		chr = ff_wtoupper(chr);		/* File name needs to be ignored case */
   1835          		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr & 0xFF);
   1836          		sum = ((sum & 1) ? 0x8000 : 0) + (sum >> 1) + (chr >> 8);
   1837          	}
   1838          	return sum;
   1839          }
   1840          
   1841          
   1842          /*------------------------------------------------------*/
   1843          /* exFAT: Get object information from a directory block */
   1844          /*------------------------------------------------------*/
   1845          static
   1846          void get_xdir_info (
   1847          	BYTE* dirb,			/* Pointer to the direcotry entry block 85+C0+C1s */
   1848          	FILINFO* fno		/* Buffer to store the extracted file information */
   1849          )
   1850          {
   1851          	UINT di, si, nc;
   1852          	WCHAR w;
   1853          
   1854          	/* Get file name */
   1855          #if _LFN_UNICODE
   1856          	if (dirb[XDIR_NumName] <= _MAX_LFN) {
   1857          		for (si = SZDIRE * 2, di = 0; di < dirb[XDIR_NumName]; si += 2, di++) {
   1858          			if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
   1859          			w = ld_word(dirb + si);				/* Get a character */
   1860          			fno->fname[di] = w;					/* Store it */
   1861          		}
   1862          	} else {
   1863          		di = 0;	/* Buffer overflow and inaccessible object */
   1864          	}
   1865          #else
   1866          	for (si = SZDIRE * 2, di = nc = 0; nc < dirb[XDIR_NumName]; si += 2, nc++) {
   1867          		if ((si % SZDIRE) == 0) si += 2;	/* Skip entry type field */
   1868          		w = ld_word(dirb + si);				/* Get a character */
   1869          		w = ff_convert(w, 0);				/* Unicode -> OEM */
   1870          		if (w == 0) { di = 0; break; }		/* Could not be converted and inaccessible object */
   1871          		if (_DF1S && w >= 0x100) {			/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
   1872          			fno->fname[di++] = (char)(w >> 8);
   1873          		}
   1874          		if (di >= _MAX_LFN) { di = 0; break; }	/* Buffer overflow and inaccessible object */
   1875          		fno->fname[di++] = (char)w;
   1876          	}
   1877          #endif
   1878          	if (di == 0) fno->fname[di++] = '?';	/* Inaccessible object? */
   1879          	fno->fname[di] = 0;						/* Terminate file name */
   1880          
   1881          	fno->altname[0] = 0;							/* No SFN */
   1882          	fno->fattrib = dirb[XDIR_Attr];					/* Attribute */
   1883          	fno->fsize = (fno->fattrib & AM_DIR) ? 0 : ld_qword(dirb + XDIR_FileSize);	/* Size */
   1884          	fno->ftime = ld_word(dirb + XDIR_ModTime + 0);	/* Time */
   1885          	fno->fdate = ld_word(dirb + XDIR_ModTime + 2);	/* Date */
   1886          }
   1887          
   1888          
   1889          /*-----------------------------------*/
   1890          /* exFAT: Get a directry entry block */
   1891          /*-----------------------------------*/
   1892          static
   1893          FRESULT load_xdir (	/* FR_INT_ERR: invalid entry block */
   1894          	DIR* dp			/* Pointer to the reading direcotry object pointing the 85 entry */
   1895          )
   1896          {
   1897          	FRESULT res;
   1898          	UINT i, nent;
   1899          	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the on-memory direcotry entry block 85+C0+C1s */
   1900          
   1901          
   1902          	/* Load 85 entry */
   1903          	res = move_window(dp->obj.fs, dp->sect);
   1904          	if (res != FR_OK) return res;
   1905          	if (dp->dir[XDIR_Type] != 0x85) return FR_INT_ERR;
   1906          	mem_cpy(&dirb[0], dp->dir, SZDIRE);
   1907          	nent = dirb[XDIR_NumSec] + 1;
   1908          
   1909          	/* Load C0 entry */
   1910          	res = dir_next(dp, 0);
   1911          	if (res != FR_OK) return res;
   1912          	res = move_window(dp->obj.fs, dp->sect);
   1913          	if (res != FR_OK) return res;
   1914          	if (dp->dir[XDIR_Type] != 0xC0) return FR_INT_ERR;
   1915          	mem_cpy(dirb + SZDIRE, dp->dir, SZDIRE);
   1916          
   1917          	/* Load C1 entries */
   1918          	if (nent < 3 || nent > 19) return FR_NO_FILE;
   1919          	i = SZDIRE * 2; nent *= SZDIRE;
   1920          	do {
   1921          		res = dir_next(dp, 0);
   1922          		if (res != FR_OK) return res;
   1923          		res = move_window(dp->obj.fs, dp->sect);
   1924          		if (res != FR_OK) return res;
   1925          		if (dp->dir[XDIR_Type] != 0xC1) return FR_INT_ERR;
   1926          		mem_cpy(dirb + i, dp->dir, SZDIRE);
   1927          		i += SZDIRE;
   1928          	} while (i < nent);
   1929          
   1930          	/* Sanity check */
   1931          	if (xdir_sum(dirb) != ld_word(dirb + XDIR_SetSum)) return FR_INT_ERR;
   1932          
   1933          	return FR_OK;
   1934          }
   1935          
   1936          
   1937          #if !_FS_READONLY || _FS_RPATH != 0
   1938          /*------------------------------------------------*/
   1939          /* exFAT: Load the object's directory entry block */
   1940          /*------------------------------------------------*/
   1941          static
   1942          FRESULT load_obj_dir (
   1943          	DIR* dp,			/* Blank directory object to be used to access containing direcotry */
   1944          	const _FDID* obj	/* Object with containing directory information */
   1945          )
   1946          {
   1947          	FRESULT res;
   1948          
   1949          
   1950          	/* Open object containing directory */
   1951          	dp->obj.fs = obj->fs;
   1952          	dp->obj.sclust = obj->c_scl;
   1953          	dp->obj.stat = (BYTE)obj->c_size;
   1954          	dp->obj.objsize = obj->c_size & 0xFFFFFF00;
   1955          	dp->blk_ofs = obj->c_ofs;
   1956          
   1957          	res = dir_sdi(dp, dp->blk_ofs);	/* Goto the block location */
   1958          	if (res == FR_OK) {
   1959          		res = load_xdir(dp);		/* Load the object's entry block */
   1960          	}
   1961          	return res;
   1962          }
   1963          #endif
   1964          
   1965          
   1966          #if !_FS_READONLY
   1967          /*-----------------------------------------------*/
   1968          /* exFAT: Store the directory block to the media */
   1969          /*-----------------------------------------------*/
   1970          static
   1971          FRESULT store_xdir (
   1972          	DIR* dp				/* Pointer to the direcotry object */
   1973          )
   1974          {
   1975          	FRESULT res;
   1976          	UINT nent;
   1977          	WORD sum;
   1978          	BYTE* dirb = dp->obj.fs->dirbuf;	/* Pointer to the direcotry entry block 85+C0+C1s */
   1979          
   1980          	/* Create set sum */
   1981          	sum = xdir_sum(dirb);
   1982          	st_word(dirb + XDIR_SetSum, sum);
   1983          	nent = dirb[XDIR_NumSec] + 1;
   1984          
   1985          	res = dir_sdi(dp, dp->blk_ofs);
   1986          	while (res == FR_OK && (res = move_window(dp->obj.fs, dp->sect)) == FR_OK) {
   1987          		mem_cpy(dp->dir, dirb, SZDIRE);
   1988          		dp->obj.fs->wflag = 1;
   1989          		if (--nent == 0) break;
   1990          		dirb += SZDIRE;
   1991          		res = dir_next(dp, 0);
   1992          	}
   1993          	return (res == FR_OK || res == FR_DISK_ERR) ? res : FR_INT_ERR;
   1994          }
   1995          
   1996          
   1997          /*-------------------------------------------*/
   1998          /* exFAT: Create a new directory enrty block */
   1999          /*-------------------------------------------*/
   2000          static
   2001          void create_xdir (
   2002          	BYTE* dirb,			/* Pointer to the direcotry entry block buffer */
   2003          	const WCHAR* lfn	/* Pointer to the nul terminated file name */
   2004          )
   2005          {
   2006          	UINT i;
   2007          	BYTE nb, nc;
   2008          	WCHAR chr;
   2009          	WORD hash;
   2010          
   2011          
   2012          	mem_set(dirb, 0, 2 * SZDIRE);			/* Initialize 85+C0 entry */
   2013          	dirb[XDIR_Type] = 0x85;
   2014          	dirb[XDIR_Type + SZDIRE] = 0xC0;
   2015          	hash = xname_sum(lfn);
   2016          	st_word(dirb + XDIR_NameHash, hash);	/* Set name hash */
   2017          
   2018          	i = SZDIRE * 2;	/* C1 offset */
   2019          	nc = 0; nb = 1; chr = 1;
   2020          	do {
   2021          		dirb[i++] = 0xC1; dirb[i++] = 0;	/* Entry type C1 */
   2022          		do {	/* Fill name field */
   2023          			if (chr && (chr = lfn[nc]) != 0) nc++;	/* Get a character if exist */
   2024          			st_word(dirb + i, chr); i += 2;	/* Store it */
   2025          		} while (i % SZDIRE);
   2026          		nb++;
   2027          	} while (lfn[nc]);	/* Fill next entry if any char follows */
   2028          
   2029          	dirb[XDIR_NumName] = nc;	/* Set name length */
   2030          	dirb[XDIR_NumSec] = nb;		/* Set number of C0+C1s */
   2031          }
   2032          #endif
   2033          #endif
   2034          
   2035          
   2036          
   2037          /*-----------------------------------------------------------------------*/
   2038          /* Read an object from the directory                                     */
   2039          /*-----------------------------------------------------------------------*/
   2040          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 || _USE_LABEL || _FS_EXFAT
   2041          static
   2042          FRESULT dir_read (
   2043          	DIR* dp,		/* Pointer to the directory object */
   2044          	int vol			/* Filtered by 0:file/directory or 1:volume label */
   2045          )
   2046          {
   2047          	FRESULT res = FR_NO_FILE;
   2048          	FATFS *fs = dp->obj.fs;
   2049          	BYTE a, c;
   2050          #if _USE_LFN != 0
   2051          	BYTE ord = 0xFF, sum = 0xFF;
   2052          #endif
   2053          
   2054          	while (dp->sect) {
   2055          		res = move_window(fs, dp->sect);
   2056          		if (res != FR_OK) break;
   2057          		c = dp->dir[DIR_Name];	/* Test for the entry type */
   2058          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of the directory */
   2059          #if _FS_EXFAT
   2060          		if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2061          			if (_USE_LABEL && vol) {
   2062          				if (c == 0x83) break;	/* Volume label entry? */
   2063          			} else {
   2064          				if (c == 0x85) {		/* Start of the entry block? */
   2065          					dp->blk_ofs = dp->dptr;	/* Set location of block */
   2066          					res = load_xdir(dp);	/* Load the entry block */
   2067          					if (res == FR_OK) {
   2068          						dp->obj.attr = fs->dirbuf[XDIR_Attr] & AM_MASK;	/* Get attribute */
   2069          					}
   2070          					break;
   2071          				}
   2072          			}
   2073          		} else
   2074          #endif
   2075          		{	/* At the FAT12/16/32 */
   2076          			dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;	/* Get attribute */
   2077          #if _USE_LFN != 0	/* LFN configuration */
   2078          			if (c == DDEM || c == '.' || (int)((a & ~AM_ARC) == AM_VOL) != vol) {	/* An entry without valid data */
   2079          				ord = 0xFF;
   2080          			} else {
   2081          				if (a == AM_LFN) {			/* An LFN entry is found */
   2082          					if (c & LLEF) {			/* Is it start of an LFN sequence? */
   2083          						sum = dp->dir[LDIR_Chksum];
   2084          						c &= ~LLEF; ord = c;
   2085          						dp->blk_ofs = dp->dptr;
   2086          					}
   2087          					/* Check LFN validity and capture it */
   2088          					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && pick_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
   2089          				} else {					/* An SFN entry is found */
   2090          					if (ord || sum != sum_sfn(dp->dir)) {	/* Is there a valid LFN? */
   2091          						dp->blk_ofs = 0xFFFFFFFF;			/* It has no LFN. */
   2092          					}
   2093          					break;
   2094          				}
   2095          			}
   2096          #else		/* Non LFN configuration */
   2097          			if (c != DDEM && c != '.' && a != AM_LFN && (int)((a & ~AM_ARC) == AM_VOL) == vol) {	/* Is it a valid entry? */
   2098          				break;
   2099          			}
   2100          #endif
   2101          		}
   2102          		res = dir_next(dp, 0);		/* Next entry */
   2103          		if (res != FR_OK) break;
   2104          	}
   2105          
   2106          	if (res != FR_OK) dp->sect = 0;		/* Terminate the read operation on error or EOT */
   2107          	return res;
   2108          }
   2109          #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
   2110          
   2111          
   2112          
   2113          /*-----------------------------------------------------------------------*/
   2114          /* Directory handling - Find an object in the directory                  */
   2115          /*-----------------------------------------------------------------------*/
   2116          
   2117          static
   2118          FRESULT dir_find (	/* FR_OK(0):succeeded, !=0:error */
   2119          	DIR* dp			/* Pointer to the directory object with the file name */
   2120          )
   2121          {
   2122          	FRESULT res;
   2123          	FATFS *fs = dp->obj.fs;
   2124          	BYTE c;
   2125          #if _USE_LFN != 0
   2126          	BYTE a, ord, sum;
   2127          #endif
   2128          
   2129          	res = dir_sdi(dp, 0);			/* Rewind directory object */
   2130          	if (res != FR_OK) return res;
   2131          #if _FS_EXFAT
   2132          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2133          		BYTE nc;
   2134          		UINT di, ni;
   2135          		WORD hash = xname_sum(dp->lfn);		/* Hash value of the name to find */
   2136          
   2137          		while ((res = dir_read(dp, 0)) == FR_OK) {	/* Read an item */
   2138          			if (ld_word(fs->dirbuf + XDIR_NameHash) != hash) continue;	/* Skip the comparison if hash value mismatched */
   2139          			for (nc = fs->dirbuf[XDIR_NumName], di = SZDIRE * 2, ni = 0; nc; nc--, di += 2, ni++) {	/* Compare the name */
   2140          				if ((di % SZDIRE) == 0) di += 2;
   2141          				if (ff_wtoupper(ld_word(fs->dirbuf + di)) != ff_wtoupper(dp->lfn[ni])) break;
   2142          			}
   2143          			if (nc == 0 && !dp->lfn[ni]) break;	/* Name matched? */
   2144          		}
   2145          		return res;
   2146          	}
   2147          #endif
   2148          	/* At the FAT12/16/32 */
   2149          #if _USE_LFN != 0
   2150          	ord = sum = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2151          #endif
   2152          	do {
   2153          		res = move_window(fs, dp->sect);
   2154          		if (res != FR_OK) break;
   2155          		c = dp->dir[DIR_Name];
   2156          		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
   2157          #if _USE_LFN != 0	/* LFN configuration */
   2158          		dp->obj.attr = a = dp->dir[DIR_Attr] & AM_MASK;
   2159          		if (c == DDEM || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
   2160          			ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2161          		} else {
   2162          			if (a == AM_LFN) {			/* An LFN entry is found */
   2163          				if (dp->lfn) {
   2164          					if (c & LLEF) {		/* Is it start of LFN sequence? */
   2165          						sum = dp->dir[LDIR_Chksum];
   2166          						c &= ~LLEF; ord = c;	/* LFN start order */
   2167          						dp->blk_ofs = dp->dptr;	/* Start offset of LFN */
   2168          					}
   2169          					/* Check validity of the LFN entry and compare it with given name */
   2170          					ord = (c == ord && sum == dp->dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dp->dir)) ? ord - 1 : 0xFF;
   2171          				}
   2172          			} else {					/* An SFN entry is found */
   2173          				if (!ord && sum == sum_sfn(dp->dir)) break;	/* LFN matched? */
   2174          				if (!(dp->fn[NSFLAG] & NS_LOSS) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* SFN matched? */
   2175          				ord = 0xFF; dp->blk_ofs = 0xFFFFFFFF;	/* Reset LFN sequence */
   2176          			}
   2177          		}
   2178          #else		/* Non LFN configuration */
   2179          		dp->obj.attr = dp->dir[DIR_Attr] & AM_MASK;
   2180          		if (!(dp->dir[DIR_Attr] & AM_VOL) && !mem_cmp(dp->dir, dp->fn, 11)) break;	/* Is it a valid entry? */
   2181          #endif
   2182          		res = dir_next(dp, 0);	/* Next entry */
   2183          	} while (res == FR_OK);
   2184          
   2185          	return res;
   2186          }
   2187          
   2188          
   2189          
   2190          
   2191          /*-----------------------------------------------------------------------*/
   2192          /* Register an object to the directory                                   */
   2193          /*-----------------------------------------------------------------------*/
   2194          #if !_FS_READONLY
   2195          static
   2196          FRESULT dir_register (	/* FR_OK:succeeded, FR_DENIED:no free entry or too many SFN collision, FR_DISK_ERR:disk error */
   2197          	DIR* dp				/* Target directory with object name to be created */
   2198          )
   2199          {
   2200          	FRESULT res;
   2201          	FATFS *fs = dp->obj.fs;
   2202          #if _USE_LFN != 0	/* LFN configuration */
   2203          	UINT n, nlen, nent;
   2204          	BYTE sn[12], *fn, sum;
   2205          	WCHAR *lfn;
   2206          
   2207          
   2208          	fn = dp->fn; lfn = dp->lfn;
   2209          	if (fn[NSFLAG] & (NS_DOT | NS_NONAME)) return FR_INVALID_NAME;	/* Check name validity */
   2210          	for (nlen = 0; lfn[nlen]; nlen++) ;	/* Get lfn length */
   2211          
   2212          #if _FS_EXFAT
   2213          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2214          		DIR dj;
   2215          
   2216          		nent = (nlen + 14) / 15 + 2;	/* Number of entries to allocate (85+C0+C1s) */
   2217          		res = dir_alloc(dp, nent);		/* Allocate entries */
   2218          		if (res != FR_OK) return res;
   2219          		dp->blk_ofs = dp->dptr - SZDIRE * (nent - 1);			/* Set block position */
   2220          
   2221          		if (dp->obj.stat & 4) {			/* Has the sub-directory been stretched? */
   2222          			dp->obj.stat &= 3;
   2223          			dp->obj.objsize += (DWORD)fs->csize * SS(fs);	/* Increase object size by cluster size */
   2224          			res = fill_fat_chain(&dp->obj);	/* Complement FAT chain if needed */
   2225          			if (res != FR_OK) return res;
   2226          			res = load_obj_dir(&dj, &dp->obj);
   2227          			if (res != FR_OK) return res;	/* Load the object status */
   2228          			st_qword(fs->dirbuf + XDIR_FileSize, dp->obj.objsize);		/* Update the allocation status */
   2229          			st_qword(fs->dirbuf + XDIR_ValidFileSize, dp->obj.objsize);
   2230          			fs->dirbuf[XDIR_GenFlags] = dp->obj.stat | 1;
   2231          			res = store_xdir(&dj);			/* Store the object status */
   2232          			if (res != FR_OK) return res;
   2233          		}
   2234          
   2235          		create_xdir(fs->dirbuf, lfn);	/* Create on-memory directory block to be written later */
   2236          		return FR_OK;
   2237          	}
   2238          #endif
   2239          	/* At the FAT12/16/32 */
   2240          	mem_cpy(sn, fn, 12);
   2241          	if (sn[NSFLAG] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
   2242          		fn[NSFLAG] = 0; dp->lfn = 0;		/* Find only SFN */
   2243          		for (n = 1; n < 100; n++) {
   2244          			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
   2245          			res = dir_find(dp);				/* Check if the name collides with existing SFN */
   2246          			if (res != FR_OK) break;
   2247          		}
   2248          		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
   2249          		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
   2250          		fn[NSFLAG] = sn[NSFLAG]; dp->lfn = lfn;
   2251          	}
   2252          
   2253          	/* Create an SFN with/without LFNs. */
   2254          	nent = (sn[NSFLAG] & NS_LFN) ? (nlen + 12) / 13 + 1 : 1;	/* Number of entries to allocate */
   2255          	res = dir_alloc(dp, nent);		/* Allocate entries */
   2256          	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
   2257          		res = dir_sdi(dp, dp->dptr - nent * SZDIRE);
   2258          		if (res == FR_OK) {
   2259          			sum = sum_sfn(dp->fn);	/* Checksum value of the SFN tied to the LFN */
   2260          			do {					/* Store LFN entries in bottom first */
   2261          				res = move_window(fs, dp->sect);
   2262          				if (res != FR_OK) break;
   2263          				put_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
   2264          				fs->wflag = 1;
   2265          				res = dir_next(dp, 0);	/* Next entry */
   2266          			} while (res == FR_OK && --nent);
   2267          		}
   2268          	}
   2269          
   2270          #else	/* Non LFN configuration */
   2271          	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
   2272          
   2273          #endif
   2274          
   2275          	/* Set SFN entry */
   2276          	if (res == FR_OK) {
   2277          		res = move_window(fs, dp->sect);
   2278          		if (res == FR_OK) {
   2279          			mem_set(dp->dir, 0, SZDIRE);	/* Clean the entry */
   2280          			mem_cpy(dp->dir + DIR_Name, dp->fn, 11);	/* Put SFN */
   2281          #if _USE_LFN != 0
   2282          			dp->dir[DIR_NTres] = dp->fn[NSFLAG] & (NS_BODY | NS_EXT);	/* Put NT flag */
   2283          #endif
   2284          			fs->wflag = 1;
   2285          		}
   2286          	}
   2287          
   2288          	return res;
   2289          }
   2290          #endif /* !_FS_READONLY */
   2291          
   2292          
   2293          
   2294          
   2295          /*-----------------------------------------------------------------------*/
   2296          /* Remove an object from the directory                                   */
   2297          /*-----------------------------------------------------------------------*/
   2298          #if !_FS_READONLY && !_FS_MINIMIZE
   2299          static
   2300          FRESULT dir_remove (	/* FR_OK:Succeeded, FR_DISK_ERR:A disk error */
   2301          	DIR* dp				/* Directory object pointing the entry to be removed */
   2302          )
   2303          {
   2304          	FRESULT res;
   2305          	FATFS *fs = dp->obj.fs;
   2306          #if _USE_LFN != 0	/* LFN configuration */
   2307          	DWORD last = dp->dptr;
   2308          
   2309          	res = dp->blk_ofs == 0xFFFFFFFF ? FR_OK : dir_sdi(dp, dp->blk_ofs);	/* Goto top of the entry block if LFN is exist */
   2310          	if (res == FR_OK) {
   2311          		do {
   2312          			res = move_window(fs, dp->sect);
   2313          			if (res != FR_OK) break;
   2314          			/* Mark an entry 'deleted' */
   2315          			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2316          				dp->dir[XDIR_Type] &= 0x7F;
   2317          			} else {									/* At the FAT12/16/32 */
   2318          				dp->dir[DIR_Name] = DDEM;
   2319          			}
   2320          			fs->wflag = 1;
   2321          			if (dp->dptr >= last) break;	/* If reached last entry then all entries of the object has been deleted. */
   2322          			res = dir_next(dp, 0);	/* Next entry */
   2323          		} while (res == FR_OK);
   2324          		if (res == FR_NO_FILE) res = FR_INT_ERR;
   2325          	}
   2326          #else			/* Non LFN configuration */
   2327          
   2328          	res = move_window(fs, dp->sect);
   2329          	if (res == FR_OK) {
   2330          		dp->dir[DIR_Name] = DDEM;
   2331          		fs->wflag = 1;
   2332          	}
   2333          #endif
   2334          
   2335          	return res;
   2336          }
   2337          #endif /* !_FS_READONLY */
   2338          
   2339          
   2340          
   2341          
   2342          /*-----------------------------------------------------------------------*/
   2343          /* Get file information from directory entry                             */
   2344          /*-----------------------------------------------------------------------*/
   2345          #if _FS_MINIMIZE <= 1 || _FS_RPATH >= 2
   2346          static
   2347          void get_fileinfo (		/* No return code */
   2348          	DIR* dp,			/* Pointer to the directory object */
   2349          	FILINFO* fno	 	/* Pointer to the file information to be filled */
   2350          )
   2351          {
   2352          	UINT i, j;
   2353          	TCHAR c;
   2354          #if _USE_LFN != 0
   2355          	WCHAR w, *lfn;
   2356          	WCHAR lfv;
   2357          #endif
   2358          
   2359          
   2360          	fno->fname[0] = 0;		/* Invaidate file info */
   2361          	if (!dp->sect) return;	/* Exit if read pointer has reached end of directory */
   2362          
   2363          #if _USE_LFN != 0	/* LFN configuration */
   2364          #if _FS_EXFAT
   2365          	if (dp->obj.fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   2366          		get_xdir_info(dp->obj.fs->dirbuf, fno);
   2367          		return;
   2368          	} else
   2369          #endif
   2370          	{	/* At the FAT12/16/32 */
   2371          		if (dp->blk_ofs != 0xFFFFFFFF) {	/* Get LFN if available */
   2372          			i = 0; lfn = dp->lfn;
   2373          			while ((w = *lfn++) != 0) {		/* Get an LFN character */
   2374          #if !_LFN_UNICODE
   2375          				w = ff_convert(w, 0);		/* Unicode -> OEM */
   2376          				if (w == 0) { i = 0; break; }	/* No LFN if it could not be converted */
   2377          				if (_DF1S && w >= 0x100) {	/* Put 1st byte if it is a DBC (always false at SBCS cfg) */
   2378          					fno->fname[i++] = (char)(w >> 8);
   2379          				}
   2380          #endif
   2381          				if (i >= _MAX_LFN) { i = 0; break; }	/* No LFN if buffer overflow */
   2382          				fno->fname[i++] = (char)w;
   2383          			}
   2384          			fno->fname[i] = 0;	/* Terminate the LFN */
   2385          		}
   2386          	}
   2387          
   2388          	i = j = 0;
   2389          	lfv = fno->fname[i];	/* LFN is exist if non-zero */
   2390          	while (i < 11) {		/* Copy name body and extension */
   2391          		c = (TCHAR)dp->dir[i++];
   2392          		if (c == ' ') continue;				/* Skip padding spaces */
   2393          		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   2394          		if (i == 9) {						/* Insert a . if extension is exist */
   2395          			if (!lfv) fno->fname[j] = '.';
   2396          			fno->altname[j++] = '.';
   2397          		}
   2398          #if _LFN_UNICODE
   2399          		if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dp->dir[i])) {
   2400          			c = c << 8 | dp->dir[i++];
   2401          		}
   2402          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   2403          		if (!c) c = '?';
   2404          #endif
   2405          		fno->altname[j] = c;
   2406          		if (!lfv) {
   2407          			if (IsUpper(c) && (dp->dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY))) {
   2408          				c += 0x20;			/* To lower */
   2409          			}
   2410          			fno->fname[j] = c;
   2411          		}
   2412          		j++;
   2413          	}
   2414          	if (!lfv) {
   2415          		fno->fname[j] = 0;
   2416          		if (!dp->dir[DIR_NTres]) j = 0;	/* Altname is no longer needed if neither LFN nor case info is exist. */
   2417          	}
   2418          	fno->altname[j] = 0;	/* Terminate the SFN */
   2419          
   2420          #else	/* Non-LFN configuration */
   2421          	i = j = 0;
   2422          	while (i < 11) {		/* Copy name body and extension */
   2423          		c = (TCHAR)dp->dir[i++];
   2424          		if (c == ' ') continue;				/* Skip padding spaces */
   2425          		if (c == RDDEM) c = (TCHAR)DDEM;	/* Restore replaced DDEM character */
   2426          		if (i == 9) fno->fname[j++] = '.';	/* Insert a . if extension is exist */
   2427          		fno->fname[j++] = c;
   2428          	}
   2429          	fno->fname[j] = 0;
   2430          #endif
   2431          
   2432          	fno->fattrib = dp->dir[DIR_Attr];				/* Attribute */
   2433          	fno->fsize = ld_dword(dp->dir + DIR_FileSize);	/* Size */
   2434          	fno->fdate = ld_word(dp->dir + DIR_WrtDate);	/* Date */
   2435          	fno->ftime = ld_word(dp->dir + DIR_WrtTime);	/* Time */
   2436          }
   2437          #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2 */
   2438          
   2439          
   2440          
   2441          
   2442          /*-----------------------------------------------------------------------*/
   2443          /* Pattern matching                                                      */
   2444          /*-----------------------------------------------------------------------*/
   2445          #if _USE_FIND && _FS_MINIMIZE <= 1
   2446          static
   2447          WCHAR get_achar (		/* Get a character and advances ptr 1 or 2 */
   2448          	const TCHAR** ptr	/* Pointer to pointer to the SBCS/DBCS/Unicode string */
   2449          )
   2450          {
   2451          #if !_LFN_UNICODE
   2452          	WCHAR chr;
   2453          
   2454          	chr = (BYTE)*(*ptr)++;					/* Get a byte */
   2455          	if (IsLower(chr)) chr -= 0x20;			/* To upper ASCII char */
   2456          #ifdef _EXCVT
   2457          	if (chr >= 0x80) chr = ExCvt[chr - 0x80];	/* To upper SBCS extended char */
   2458          #else
   2459          	if (IsDBCS1(chr) && IsDBCS2(**ptr)) {		/* Get DBC 2nd byte if needed */
   2460          		chr = chr << 8 | (BYTE)*(*ptr)++;
   2461          	}
   2462          #endif
   2463          	return chr;
   2464          #else
   2465          	return ff_wtoupper(*(*ptr)++);			/* Get a word and to upper */
   2466          #endif
   2467          }
   2468          
   2469          
   2470          static
   2471          int pattern_matching (	/* 0:not matched, 1:matched */
   2472          	const TCHAR* pat,	/* Matching pattern */
   2473          	const TCHAR* nam,	/* String to be tested */
   2474          	int skip,			/* Number of pre-skip chars (number of ?s) */
   2475          	int inf				/* Infinite search (* specified) */
   2476          )
   2477          {
   2478          	const TCHAR *pp, *np;
   2479          	WCHAR pc, nc;
   2480          	int nm, nx;
   2481          
   2482          
   2483          	while (skip--) {				/* Pre-skip name chars */
   2484          		if (!get_achar(&nam)) return 0;	/* Branch mismatched if less name chars */
   2485          	}
   2486          	if (!*pat && inf) return 1;		/* (short circuit) */
   2487          
   2488          	do {
   2489          		pp = pat; np = nam;			/* Top of pattern and name to match */
   2490          		for (;;) {
   2491          			if (*pp == '?' || *pp == '*') {	/* Wildcard? */
   2492          				nm = nx = 0;
   2493          				do {				/* Analyze the wildcard chars */
   2494          					if (*pp++ == '?') nm++; else nx = 1;
   2495          				} while (*pp == '?' || *pp == '*');
   2496          				if (pattern_matching(pp, np, nm, nx)) return 1;	/* Test new branch (recursions upto number of wildcard blocks in the pattern) */
   2497          				nc = *np; break;	/* Branch mismatched */
   2498          			}
   2499          			pc = get_achar(&pp);	/* Get a pattern char */
   2500          			nc = get_achar(&np);	/* Get a name char */
   2501          			if (pc != nc) break;	/* Branch mismatched? */
   2502          			if (pc == 0) return 1;	/* Branch matched? (matched at end of both strings) */
   2503          		}
   2504          		get_achar(&nam);			/* nam++ */
   2505          	} while (inf && nc);			/* Retry until end of name if infinite search is specified */
   2506          
   2507          	return 0;
   2508          }
   2509          #endif /* _USE_FIND && _FS_MINIMIZE <= 1 */
   2510          
   2511          
   2512          
   2513          
   2514          /*-----------------------------------------------------------------------*/
   2515          /* Pick a top segment and create the object name in directory form       */
   2516          /*-----------------------------------------------------------------------*/
   2517          
   2518          static
   2519          FRESULT create_name (	/* FR_OK: successful, FR_INVALID_NAME: could not create */
   2520          	DIR* dp,			/* Pointer to the directory object */
   2521          	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
   2522          )
   2523          {
   2524          #if _USE_LFN != 0	/* LFN configuration */
   2525          	BYTE b, cf;
   2526          	WCHAR w, *lfn;
   2527          	UINT i, ni, si, di;
   2528          	const TCHAR *p;
   2529          
   2530          	/* Create LFN in Unicode */
   2531          	p = *path; lfn = dp->lfn; si = di = 0;
   2532          	for (;;) {
   2533          		w = p[si++];					/* Get a character */
   2534          		if (w < ' ' || w == '/' || w == '\\') {		/* Break on end of segment */
   2535          			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
   2536          			break;
   2537          		}
   2538          		if (di >= _MAX_LFN) return FR_INVALID_NAME;	/* Reject too long name */
   2539          #if !_LFN_UNICODE
   2540          		w &= 0xFF;
   2541          		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
   2542          			b = (BYTE)p[si++];			/* Get 2nd byte */
   2543          			w = (w << 8) + b;			/* Create a DBC */
   2544          			if (!IsDBCS2(b)) return FR_INVALID_NAME;	/* Reject invalid sequence */
   2545          		}
   2546          		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
   2547          		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
   2548          #endif
   2549          		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) return FR_INVALID_NAME;	/* Reject illegal characters for LFN */
   2550          		lfn[di++] = w;					/* Store the Unicode character */
   2551          	}
   2552          	*path = &p[si];						/* Return pointer to the next segment */
   2553          	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2554          #if _FS_RPATH != 0
   2555          	if ((di == 1 && lfn[di - 1] == '.') ||
   2556          		(di == 2 && lfn[di - 1] == '.' && lfn[di - 2] == '.')) {	/* Is this segment a dot name? */
   2557          		lfn[di] = 0;
   2558          		for (i = 0; i < 11; i++)		/* Create dot name for SFN entry */
   2559          			dp->fn[i] = (i < di) ? '.' : ' ';
   2560          		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
   2561          		return FR_OK;
   2562          	}
   2563          #endif
   2564          	while (di) {						/* Snip off trailing spaces and dots if exist */
   2565          		w = lfn[di - 1];
   2566          		if (w != ' ' && w != '.') break;
   2567          		di--;
   2568          	}
   2569          	lfn[di] = 0;						/* LFN is created */
   2570          	if (di == 0) return FR_INVALID_NAME;	/* Reject nul name */
   2571          
   2572          	/* Create SFN in directory form */
   2573          	mem_set(dp->fn, ' ', 11);
   2574          	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
   2575          	if (si) cf |= NS_LOSS | NS_LFN;
   2576          	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
   2577          
   2578          	b = i = 0; ni = 8;
   2579          	for (;;) {
   2580          		w = lfn[si++];					/* Get an LFN character */
   2581          		if (!w) break;					/* Break on end of the LFN */
   2582          		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
   2583          			cf |= NS_LOSS | NS_LFN; continue;
   2584          		}
   2585          
   2586          		if (i >= ni || si == di) {		/* Extension or end of SFN */
   2587          			if (ni == 11) {				/* Long extension */
   2588          				cf |= NS_LOSS | NS_LFN; break;
   2589          			}
   2590          			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
   2591          			if (si > di) break;			/* No extension */
   2592          			si = di; i = 8; ni = 11;	/* Enter extension section */
   2593          			b <<= 2; continue;
   2594          		}
   2595          
   2596          		if (w >= 0x80) {				/* Non ASCII character */
   2597          #ifdef _EXCVT
   2598          			w = ff_convert(w, 0);		/* Unicode -> OEM code */
   2599          			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
   2600          #else
   2601          			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
   2602          #endif
   2603          			cf |= NS_LFN;				/* Force create LFN entry */
   2604          		}
   2605          
   2606          		if (_DF1S && w >= 0x100) {		/* Is this DBC? (always false at SBCS cfg) */
   2607          			if (i >= ni - 1) {
   2608          				cf |= NS_LOSS | NS_LFN; i = ni; continue;
   2609          			}
   2610          			dp->fn[i++] = (BYTE)(w >> 8);
   2611          		} else {						/* SBC */
   2612          			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
   2613          				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
   2614          			} else {
   2615          				if (IsUpper(w)) {		/* ASCII large capital */
   2616          					b |= 2;
   2617          				} else {
   2618          					if (IsLower(w)) {	/* ASCII small capital */
   2619          						b |= 1; w -= 0x20;
   2620          					}
   2621          				}
   2622          			}
   2623          		}
   2624          		dp->fn[i++] = (BYTE)w;
   2625          	}
   2626          
   2627          	if (dp->fn[0] == DDEM) dp->fn[0] = RDDEM;	/* If the first character collides with DDEM, replace it with RDDEM */
   2628          
   2629          	if (ni == 8) b <<= 2;
   2630          	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03) cf |= NS_LFN;	/* Create LFN entry when there are composite capitals */
   2631          	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
   2632          		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
   2633          		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
   2634          	}
   2635          
   2636          	dp->fn[NSFLAG] = cf;	/* SFN is created */
   2637          
   2638          	return FR_OK;
   2639          
   2640          
   2641          #else	/* Non-LFN configuration */
   2642          	BYTE b, c, d, *sfn;
   2643          	UINT ni, si, i;
   2644          	const char *p;
   2645          
   2646          	/* Create file name in directory form */
   2647          	p = *path; sfn = dp->fn;
   2648          	mem_set(sfn, ' ', 11);
   2649          	si = i = b = 0; ni = 8;
   2650          #if _FS_RPATH != 0
   2651          	if (p[si] == '.') { /* Is this a dot entry? */
   2652          		for (;;) {
   2653          			c = (BYTE)p[si++];
   2654          			if (c != '.' || si >= 3) break;
   2655          			sfn[i++] = c;
   2656          		}
   2657          		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
   2658          		*path = &p[si];									/* Return pointer to the next segment */
   2659          		sfn[NSFLAG] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
   2660          		return FR_OK;
   2661          	}
   2662          #endif
   2663          	for (;;) {
   2664          		c = (BYTE)p[si++];
   2665          		if (c <= ' ' || c == '/' || c == '\\') {	/* Break on end of segment */
   2666          			while (p[si] == '/' || p[si] == '\\') si++;	/* Skip duplicated separator */
   2667          			break;
   2668          		}
   2669          		if (c == '.' || i >= ni) {
   2670          			if (ni != 8 || c != '.') return FR_INVALID_NAME;
   2671          			i = 8; ni = 11;
   2672          			b <<= 2; continue;
   2673          		}
   2674          		if (c >= 0x80) {				/* Extended character? */
   2675          			b |= 3;						/* Eliminate NT flag */
   2676          #ifdef _EXCVT
   2677          			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
   2678          #else
   2679          #if !_DF1S
   2680          			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
   2681          #endif
   2682          #endif
   2683          		}
   2684          		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false at SBCS cfg.) */
   2685          			d = (BYTE)p[si++];			/* Get 2nd byte */
   2686          			if (!IsDBCS2(d) || i >= ni - 1) return FR_INVALID_NAME;	/* Reject invalid DBC */
   2687          			sfn[i++] = c;
   2688          			sfn[i++] = d;
   2689          		} else {						/* SBC */
   2690          			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c)) return FR_INVALID_NAME;	/* Reject illegal chrs for SFN */
   2691          			if (IsUpper(c)) {			/* ASCII large capital? */
   2692          				b |= 2;
   2693          			} else {
   2694          				if (IsLower(c)) {		/* ASCII small capital? */
   2695          					b |= 1; c -= 0x20;
   2696          				}
   2697          			}
   2698          			sfn[i++] = c;
   2699          		}
   2700          	}
   2701          	*path = &p[si];						/* Return pointer to the next segment */
   2702          	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
   2703          
   2704          	if (i == 0) return FR_INVALID_NAME;	/* Reject nul string */
   2705          	if (sfn[0] == DDEM) sfn[0] = RDDEM;	/* When first character collides with DDEM, replace it with RDDEM */
   2706          
   2707          	if (ni == 8) b <<= 2;
   2708          	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
   2709          	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
   2710          
   2711          	sfn[NSFLAG] = c;		/* Store NT flag, File name is created */
   2712          
   2713          	return FR_OK;
   2714          #endif
   2715          }
   2716          
   2717          
   2718          
   2719          
   2720          /*-----------------------------------------------------------------------*/
   2721          /* Follow a file path                                                    */
   2722          /*-----------------------------------------------------------------------*/
   2723          
   2724          static
   2725          FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
   2726          	DIR* dp,			/* Directory object to return last directory and found object */
   2727          	const TCHAR* path	/* Full-path string to find a file or directory */
   2728          )
   2729          {
   2730          	FRESULT res;
   2731          	BYTE ns;
   2732          	_FDID *obj = &dp->obj;
   2733          	FATFS *fs = obj->fs;
   2734          
   2735          
   2736          #if _FS_RPATH != 0
   2737          	if (*path != '/' && *path != '\\') {	/* Without heading separator */
   2738          		obj->sclust = fs->cdir;				/* Start from the current directory */
   2739          	} else
   2740          #endif
   2741          	{										/* With heading separator */
   2742          		while (*path == '/' || *path == '\\') path++;	/* Strip heading separator */
   2743          		obj->sclust = 0;					/* Start from the root directory */
   2744          	}
   2745          #if _FS_EXFAT && _FS_RPATH != 0
   2746          	if (fs->fs_type == FS_EXFAT && obj->sclust) {	/* Retrieve the sub-directory status if needed */
   2747          		DIR dj;
   2748          
   2749          		obj->c_scl = fs->cdc_scl;
   2750          		obj->c_size = fs->cdc_size;
   2751          		obj->c_ofs = fs->cdc_ofs;
   2752          		res = load_obj_dir(&dj, obj);
   2753          		if (res != FR_OK) return res;
   2754          		obj->objsize = ld_dword(fs->dirbuf + XDIR_FileSize);
   2755          		obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   2756          	}
   2757          #endif
   2758          
   2759          	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
   2760          		dp->fn[NSFLAG] = NS_NONAME;
   2761          		res = dir_sdi(dp, 0);
   2762          
   2763          	} else {								/* Follow path */
   2764          		for (;;) {
   2765          			res = create_name(dp, &path);	/* Get a segment name of the path */
   2766          			if (res != FR_OK) break;
   2767          			res = dir_find(dp);				/* Find an object with the segment name */
   2768          			ns = dp->fn[NSFLAG];
   2769          			if (res != FR_OK) {				/* Failed to find the object */
   2770          				if (res == FR_NO_FILE) {	/* Object is not found */
   2771          					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, stay there */
   2772          						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
   2773          						dp->fn[NSFLAG] = NS_NONAME;
   2774          						res = FR_OK;
   2775          					} else {							/* Could not find the object */
   2776          						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
   2777          					}
   2778          				}
   2779          				break;
   2780          			}
   2781          			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
   2782          			/* Get into the sub-directory */
   2783          			if (!(obj->attr & AM_DIR)) {		/* It is not a sub-directory and cannot follow */
   2784          				res = FR_NO_PATH; break;
   2785          			}
   2786          #if _FS_EXFAT
   2787          			if (fs->fs_type == FS_EXFAT) {
   2788          				obj->c_scl = obj->sclust;		/* Save containing directory information for next dir */
   2789          				obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
   2790          				obj->c_ofs = dp->blk_ofs;
   2791          				obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Open next directory */
   2792          				obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   2793          				obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   2794          			} else
   2795          #endif
   2796          			{
   2797          				obj->sclust = ld_clust(fs, &fs->win[dp->dptr % SS(fs)]);	/* Open next directory */
   2798          			}
   2799          		}
   2800          	}
   2801          
   2802          	return res;
   2803          }
   2804          
   2805          
   2806          
   2807          
   2808          /*-----------------------------------------------------------------------*/
   2809          /* Get logical drive number from path name                               */
   2810          /*-----------------------------------------------------------------------*/
   2811          
   2812          static
   2813          int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
   2814          	const TCHAR** path	/* Pointer to pointer to the path name */
   2815          )
   2816          {
   2817          	const TCHAR *tp, *tt;
   2818          	UINT i;
   2819          	int vol = -1;
   2820          #if _STR_VOLUME_ID		/* Find string drive id */
   2821          	static const char* const str[] = {_VOLUME_STRS};
   2822          	const char *sp;
   2823          	char c;
   2824          	TCHAR tc;
   2825          #endif
   2826          
   2827          
   2828          	if (*path) {	/* If the pointer is not a null */
   2829          		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
   2830          		if (*tt == ':') {	/* If a ':' is exist in the path name */
   2831          			tp = *path;
   2832          			i = *tp++ - '0';
   2833          			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
   2834          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2835          					vol = (int)i;
   2836          					*path = ++tt;
   2837          				}
   2838          			}
   2839          #if _STR_VOLUME_ID
   2840          			 else {	/* No numeric drive number, find string drive id */
   2841          				i = 0; tt++;
   2842          				do {
   2843          					sp = str[i]; tp = *path;
   2844          					do {	/* Compare a string drive id with path name */
   2845          						c = *sp++; tc = *tp++;
   2846          						if (IsLower(tc)) tc -= 0x20;
   2847          					} while (c && (TCHAR)c == tc);
   2848          				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
   2849          				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
   2850          					vol = (int)i;
   2851          					*path = tt;
   2852          				}
   2853          			}
   2854          #endif
   2855          			return vol;
   2856          		}
   2857          #if _FS_RPATH != 0 && _VOLUMES >= 2
   2858          		vol = CurrVol;	/* Current drive */
   2859          #else
   2860          		vol = 0;		/* Drive 0 */
   2861          #endif
   2862          	}
   2863          	return vol;
   2864          }
   2865          
   2866          
   2867          
   2868          
   2869          /*-----------------------------------------------------------------------*/
   2870          /* Load a sector and check if it is an FAT boot sector                   */
   2871          /*-----------------------------------------------------------------------*/
   2872          
   2873          static
   2874          BYTE check_fs (	/* 0:FAT, 1:exFAT, 2:Valid BS but not FAT, 3:Not a BS, 4:Disk error */
   2875          	FATFS* fs,	/* File system object */
   2876          	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
   2877          )
   2878          {
   2879          	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;		/* Invaidate window */
   2880          	if (move_window(fs, sect) != FR_OK) return 4;	/* Load boot record */
   2881          
   2882          	if (ld_word(&fs->win[BS_55AA]) != 0xAA55) return 3;	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
   2883          
   2884          	if ((ld_dword(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
   2885          	if ((ld_dword(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146) return 0;	/* Check "FAT" string */
   2886          #if _FS_EXFAT
   2887          	if (!mem_cmp(&fs->win[BS_OEMName], "EXFAT   ", 8)) return 1;
   2888          #endif
   2889          	return 2;
   2890          }
   2891          
   2892          
   2893          
   2894          
   2895          /*-----------------------------------------------------------------------*/
   2896          /* Find logical drive and check if the volume is mounted                 */
   2897          /*-----------------------------------------------------------------------*/
   2898          
   2899          static
   2900          FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
   2901          	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
   2902          	FATFS** rfs,		/* Pointer to pointer to the found file system object */
   2903          	BYTE mode			/* !=0: Check write protection for write access */
   2904          )
   2905          {
   2906          	BYTE fmt, *pt;
   2907          	int vol;
   2908          	DSTATUS stat;
   2909          	DWORD bsect, fasize, tsect, sysect, nclst, szbfat, br[4];
   2910          	WORD nrsv;
   2911          	FATFS *fs;
   2912          	UINT i;
   2913          
   2914          
   2915          	/* Get logical drive number from the path name */
   2916          	*rfs = 0;
   2917          	vol = get_ldnumber(path);
   2918          	if (vol < 0) return FR_INVALID_DRIVE;
   2919          
   2920          	/* Check if the file system object is valid or not */
   2921          	fs = FatFs[vol];					/* Get pointer to the file system object */
   2922          	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
   2923          
   2924          	ENTER_FF(fs);						/* Lock the volume */
   2925          	*rfs = fs;							/* Return pointer to the file system object */
   2926          
   2927          	mode &= ~FA_READ;					/* Desired access mode, write access or not */
   2928          	if (fs->fs_type) {					/* If the volume has been mounted */
   2929          		stat = disk_status(fs->drv);
   2930          		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
   2931          			if (!_FS_READONLY && mode && (stat & STA_PROTECT)) {	/* Check write protection if needed */
   2932          				return FR_WRITE_PROTECTED;
   2933          			}
   2934          			return FR_OK;				/* The file system object is valid */
   2935          		}
   2936          	}
   2937          
   2938          	/* The file system object is not valid. */
   2939          	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
   2940          
   2941          	fs->fs_type = 0;					/* Clear the file system object */
   2942          	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
   2943          	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
   2944          	if (stat & STA_NOINIT) { 			/* Check if the initialization succeeded */
   2945          		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
   2946          	}
   2947          	if (!_FS_READONLY && mode && (stat & STA_PROTECT)) { /* Check disk write protection if needed */
   2948          		return FR_WRITE_PROTECTED;
   2949          	}
   2950          #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
   2951          	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
   2952          		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
   2953          #endif
   2954          	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
   2955          	bsect = 0;
   2956          	fmt = check_fs(fs, bsect);			/* Load sector 0 and check if it is an FAT boot sector as SFD */
   2957          	if (fmt == 2 || (fmt < 2 && LD2PT(vol))) {	/* Not an FAT boot sector or forced partition number */
   2958          		for (i = 0; i < 4; i++) {			/* Get partition offset */
   2959          			pt = fs->win + MBR_Table + i * SZ_PTE;
   2960          			br[i] = pt[4] ? ld_dword(&pt[8]) : 0;
   2961          		}
   2962          		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
   2963          		if (i) i--;
   2964          		do {								/* Find an FAT volume */
   2965          			bsect = br[i];
   2966          			fmt = bsect ? check_fs(fs, bsect) : 3;	/* Check the partition */
   2967          		} while (!LD2PT(vol) && fmt >= 2 && ++i < 4);
   2968          	}
   2969          	if (fmt == 4) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
   2970          	if (fmt >= 2) return FR_NO_FILESYSTEM;	/* No FAT volume is found */
   2971          
   2972          	/* An FAT volume is found. Following code initializes the file system object */
   2973          
   2974          #if _FS_EXFAT
   2975          	if (fmt == 1) {
   2976          		QWORD maxlba;
   2977          
   2978          		for (i = BPB_ZeroedEx; i < BPB_ZeroedEx + 53 && !fs->win[i]; i++) ;	/* Check zero filler */
   2979          		if (i < BPB_ZeroedEx + 53) return FR_NO_FILESYSTEM;
   2980          
   2981          		if (ld_word(fs->win + BPB_FSVerEx) != 0x100) return FR_NO_FILESYSTEM;	/* Check exFAT revision (Must be 1.0) */
   2982          
   2983          		if (1 << fs->win[BPB_BytsPerSecEx] != SS(fs))	/* (BPB_BytsPerSecEx must be equal to the physical sector size) */
   2984          			return FR_NO_FILESYSTEM;
   2985          
   2986          		maxlba = ld_qword(fs->win + BPB_TotSecEx) + bsect;	/* Number of sectors on the volume */
   2987          		if (maxlba >= 0x100000000) return FR_NO_FILESYSTEM;	/* (It cannot be handled in 32-bit LBA) */
   2988          
   2989          		fs->fsize = ld_dword(fs->win + BPB_FatSzEx);	/* Number of sectors per FAT */
   2990          
   2991          		fs->n_fats = fs->win[BPB_NumFATsEx];			/* Number of FATs */
   2992          		if (fs->n_fats != 1) return FR_NO_FILESYSTEM;	/* (Must be 1) */
   2993          
   2994          		fs->csize = 1 << fs->win[BPB_SecPerClusEx];		/* Cluster size */
   2995          		if (fs->csize == 0)	return FR_NO_FILESYSTEM;	/* (Must be 1..32768) */
   2996          
   2997          		nclst = ld_dword(fs->win + BPB_NumClusEx);		/* Number of clusters */
   2998          		fs->n_fatent = nclst + 2;
   2999          		if (fs->n_fatent >= 0x80000000) return FR_NO_FILESYSTEM;	/* (Must be <= 0x7FFFFFFF) */
   3000          
   3001          		/* Boundaries and Limits */
   3002          		fs->volbase = bsect;
   3003          		fs->database = bsect + ld_dword(fs->win + BPB_DataOfsEx);
   3004          		fs->fatbase = bsect + ld_dword(fs->win + BPB_FatOfsEx);
   3005          		if (maxlba < fs->database + nclst * fs->csize) return FR_NO_FILESYSTEM;	/* (Volume size must not be smaller than the size requiered) */
   3006          		fs->dirbase = ld_dword(fs->win + BPB_RootClusEx);
   3007          
   3008          		/* Check if bitmap location is in assumption (at the first cluster) */
   3009          		if (move_window(fs, clust2sect(fs, fs->dirbase)) != FR_OK) return FR_DISK_ERR;
   3010          		for (i = 0; i < SS(fs); i += SZDIRE) {
   3011          			if (fs->win[i] == 0x81 && ld_dword(fs->win + i + 20) == 2) break;	/* 81 entry with cluster #2? */
   3012          		}
   3013          		if (i == SS(fs)) return FR_NO_FILESYSTEM;
   3014          #if !_FS_READONLY
   3015          		fs->last_clst = fs->free_clst = 0xFFFFFFFF;		/* Initialize cluster allocation information */
   3016          #endif
   3017          #if _USE_LFN == 1
   3018          		fs->dirbuf = DirBuf;	/* Static directory block working buuffer */
   3019          #endif
   3020          		fmt = FS_EXFAT;			/* FAT sub-type */
   3021          	} else
   3022          #endif
   3023          	{
   3024          		if (ld_word(fs->win + BPB_BytsPerSec) != SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_BytsPerSec must be equal to the physical sector size) */
   3025          
   3026          		fasize = ld_word(fs->win + BPB_FATSz16);			/* Number of sectors per FAT */
   3027          		if (fasize == 0) fasize = ld_dword(fs->win + BPB_FATSz32);
   3028          		fs->fsize = fasize;
   3029          
   3030          		fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FATs */
   3031          		if (fs->n_fats != 1 && fs->n_fats != 2) return FR_NO_FILESYSTEM;	/* (Must be 1 or 2) */
   3032          		fasize *= fs->n_fats;								/* Number of sectors for FAT area */
   3033          
   3034          		fs->csize = fs->win[BPB_SecPerClus];				/* Cluster size */
   3035          		if (fs->csize == 0 || (fs->csize & (fs->csize - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
   3036          
   3037          		fs->n_rootdir = ld_word(fs->win + BPB_RootEntCnt);	/* Number of root directory entries */
   3038          		if (fs->n_rootdir % (SS(fs) / SZDIRE)) return FR_NO_FILESYSTEM;	/* (Must be sector aligned) */
   3039          
   3040          		tsect = ld_word(fs->win + BPB_TotSec16);			/* Number of sectors on the volume */
   3041          		if (tsect == 0) tsect = ld_dword(fs->win + BPB_TotSec32);
   3042          
   3043          		nrsv = ld_word(fs->win + BPB_RsvdSecCnt);			/* Number of reserved sectors */
   3044          		if (nrsv == 0) return FR_NO_FILESYSTEM;				/* (Must not be 0) */
   3045          
   3046          		/* Determine the FAT sub type */
   3047          		sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZDIRE);	/* RSV + FAT + DIR */
   3048          		if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
   3049          		nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
   3050          		if (nclst == 0) return FR_NO_FILESYSTEM;			/* (Invalid volume size) */
   3051          		fmt = FS_FAT12;
   3052          		if (nclst >= MIN_FAT16) fmt = FS_FAT16;
   3053          		if (nclst >= MIN_FAT32) fmt = FS_FAT32;
   3054          
   3055          		/* Boundaries and Limits */
   3056          		fs->n_fatent = nclst + 2;							/* Number of FAT entries */
   3057          		fs->volbase = bsect;								/* Volume start sector */
   3058          		fs->fatbase = bsect + nrsv; 						/* FAT start sector */
   3059          		fs->database = bsect + sysect;						/* Data start sector */
   3060          		if (fmt == FS_FAT32) {
   3061          			if (ld_word(fs->win + BPB_FSVer32) != 0) return FR_NO_FILESYSTEM;	/* (Must be FAT32 revision 0.0) */
   3062          			if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
   3063          			fs->dirbase = ld_dword(fs->win + BPB_RootClus32);	/* Root directory start cluster */
   3064          			szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
   3065          		} else {
   3066          			if (fs->n_rootdir == 0)	return FR_NO_FILESYSTEM;/* (BPB_RootEntCnt must not be 0) */
   3067          			fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
   3068          			szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
   3069          				fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
   3070          		}
   3071          		if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs)) return FR_NO_FILESYSTEM;	/* (BPB_FATSz must not be less than the size needed) */
   3072          
   3073          #if !_FS_READONLY
   3074          		/* Initialize cluster allocation information */
   3075          		fs->last_clst = fs->free_clst = 0xFFFFFFFF;
   3076          
   3077          		/* Get FSINFO if available */
   3078          		fs->fsi_flag = 0x80;
   3079          #if (_FS_NOFSINFO & 3) != 3
   3080          		if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo32 == 1 */
   3081          			&& ld_word(fs->win + BPB_FSInfo32) == 1
   3082          			&& move_window(fs, bsect + 1) == FR_OK)
   3083          		{
   3084          			fs->fsi_flag = 0;
   3085          			if (ld_word(fs->win + BS_55AA) == 0xAA55	/* Load FSINFO data if available */
   3086          				&& ld_dword(fs->win + FSI_LeadSig) == 0x41615252
   3087          				&& ld_dword(fs->win + FSI_StrucSig) == 0x61417272)
   3088          			{
   3089          #if (_FS_NOFSINFO & 1) == 0
   3090          				fs->free_clst = ld_dword(fs->win + FSI_Free_Count);
   3091          #endif
   3092          #if (_FS_NOFSINFO & 2) == 0
   3093          				fs->last_clst = ld_dword(fs->win + FSI_Nxt_Free);
   3094          #endif
   3095          			}
   3096          		}
   3097          #endif
   3098          #endif
   3099          	}
   3100          
   3101          	fs->fs_type = fmt;	/* FAT sub-type */
   3102          	fs->id = ++Fsid;	/* File system mount ID */
   3103          #if _FS_RPATH != 0
   3104          	fs->cdir = 0;		/* Initialize current directory */
   3105          #endif
   3106          #if _FS_LOCK != 0		/* Clear file lock semaphores */
   3107          	clear_lock(fs);
   3108          #endif
   3109          	return FR_OK;
   3110          }
   3111          
   3112          
   3113          
   3114          
   3115          /*-----------------------------------------------------------------------*/
   3116          /* Check if the file/directory object is valid or not                    */
   3117          /*-----------------------------------------------------------------------*/
   3118          
   3119          static
   3120          FRESULT validate (	/* Returns FR_OK or FR_INVALID_OBJECT */
   3121          	void* dfp,		/* Pointer to the FIL/DIR object to check validity */
   3122          	FATFS** fs		/* Pointer to pointer to the owner file system object to return */
   3123          )
   3124          {
   3125          	_FDID *obj = (_FDID*)dfp;	/* Assuming .obj in the FIL/DIR is the first member */
   3126          	FRESULT res;
   3127          
   3128          
   3129          	if (!dfp || !obj->fs || !obj->fs->fs_type || obj->fs->id != obj->id || (disk_status(obj->fs->drv) & STA_NOINIT)) {
   3130          		*fs = 0;				/* The object is invalid */
   3131          		res = FR_INVALID_OBJECT;
   3132          	} else {
   3133          		*fs = obj->fs;			/* Owner file sytem object */
   3134          		ENTER_FF(obj->fs);		/* Lock file system */
   3135          		res = FR_OK;
   3136          	}
   3137          	return res;
   3138          }
   3139          
   3140          
   3141          
   3142          
   3143          /*---------------------------------------------------------------------------
   3144          
   3145             Public Functions (FatFs API)
   3146          
   3147          ----------------------------------------------------------------------------*/
   3148          
   3149          
   3150          
   3151          /*-----------------------------------------------------------------------*/
   3152          /* Mount/Unmount a Logical Drive                                         */
   3153          /*-----------------------------------------------------------------------*/
   3154          
   3155          FRESULT f_mount (
   3156          	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
   3157          	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
   3158          	BYTE opt			/* Mode option 0:Do not mount (delayed mount), 1:Mount immediately */
   3159          )
   3160          {
   3161          	FATFS *cfs;
   3162          	int vol;
   3163          	FRESULT res;
   3164          	const TCHAR *rp = path;
   3165          
   3166          
   3167          	vol = get_ldnumber(&rp);
   3168          	if (vol < 0) return FR_INVALID_DRIVE;
   3169          	cfs = FatFs[vol];					/* Pointer to fs object */
   3170          
   3171          	if (cfs) {
   3172          #if _FS_LOCK != 0
   3173          		clear_lock(cfs);
   3174          #endif
   3175          #if _FS_REENTRANT						/* Discard sync object of the current volume */
   3176          		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
   3177          #endif
   3178          		cfs->fs_type = 0;				/* Clear old fs object */
   3179          	}
   3180          
   3181          	if (fs) {
   3182          		fs->fs_type = 0;				/* Clear new fs object */
   3183          #if _FS_REENTRANT						/* Create sync object for the new volume */
   3184          		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
   3185          #endif
   3186          	}
   3187          	FatFs[vol] = fs;					/* Register new fs object */
   3188          
   3189          	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
   3190          
   3191          	res = find_volume(&path, &fs, 0);	/* Force mounted the volume */
   3192          	LEAVE_FF(fs, res);
   3193          }
   3194          
   3195          
   3196          
   3197          
   3198          /*-----------------------------------------------------------------------*/
   3199          /* Open or Create a File                                                 */
   3200          /*-----------------------------------------------------------------------*/
   3201          
   3202          FRESULT f_open (
   3203          	FIL* fp,			/* Pointer to the blank file object */
   3204          	const TCHAR* path,	/* Pointer to the file name */
   3205          	BYTE mode			/* Access mode and file open mode flags */
   3206          )
   3207          {
   3208          	FRESULT res;
   3209          	DIR dj;
   3210          	FATFS *fs;
   3211          #if !_FS_READONLY
   3212          	DWORD dw, cl;
   3213          #endif
   3214          	DEF_NAMBUF;
   3215          
   3216          
   3217          	if (!fp) return FR_INVALID_OBJECT;
   3218          	fp->obj.fs = 0;		/* Clear file object */
   3219          
   3220          	/* Get logical drive number */
   3221          	mode &= _FS_READONLY ? FA_READ : FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
   3222          	res = find_volume(&path, &fs, mode);
   3223          	if (res == FR_OK) {
   3224          		dj.obj.fs = fs;
   3225          		INIT_NAMBUF(dj);
   3226          		res = follow_path(&dj, path);	/* Follow the file path */
   3227          #if !_FS_READONLY	/* R/W configuration */
   3228          		if (res == FR_OK) {
   3229          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
   3230          				res = FR_INVALID_NAME;
   3231          			}
   3232          #if _FS_LOCK != 0
   3233          			else {
   3234          				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3235          			}
   3236          #endif
   3237          		}
   3238          		/* Create or Open a file */
   3239          		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
   3240          			if (res != FR_OK) {					/* No file, create new */
   3241          				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
   3242          #if _FS_LOCK != 0
   3243          					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
   3244          #else
   3245          					res = dir_register(&dj);
   3246          #endif
   3247          				mode |= FA_CREATE_ALWAYS;		/* File is created */
   3248          			}
   3249          			else {								/* Any object is already existing */
   3250          				if (dj.obj.attr & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
   3251          					res = FR_DENIED;
   3252          				} else {
   3253          					if (mode & FA_CREATE_NEW) res = FR_EXIST;	/* Cannot create as new file */
   3254          				}
   3255          			}
   3256          			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
   3257          				dw = GET_FATTIME();
   3258          #if _FS_EXFAT
   3259          				if (fs->fs_type == FS_EXFAT) {
   3260          					/* Get current allocation info */
   3261          					fp->obj.fs = fs;
   3262          					fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);
   3263          					fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   3264          					fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   3265          					/* Initialize directory entry block */
   3266          					st_dword(fs->dirbuf + XDIR_CrtTime, dw);	/* Set created time */
   3267          					fs->dirbuf[XDIR_CrtTime10] = 0;
   3268          					st_dword(fs->dirbuf + XDIR_ModTime, dw);	/* Set modified time */
   3269          					fs->dirbuf[XDIR_ModTime10] = 0;
   3270          					fs->dirbuf[XDIR_Attr] = AM_ARC;				/* Reset attribute */
   3271          					st_dword(fs->dirbuf + XDIR_FstClus, 0);		/* Reset file allocation info */
   3272          					st_qword(fs->dirbuf + XDIR_FileSize, 0);
   3273          					st_qword(fs->dirbuf + XDIR_ValidFileSize, 0);
   3274          					fs->dirbuf[XDIR_GenFlags] = 1;
   3275          					res = store_xdir(&dj);
   3276          					if (res == FR_OK && fp->obj.sclust) {		/* Remove the cluster chain if exist */
   3277          						res = remove_chain(&fp->obj, fp->obj.sclust, 0);
   3278          						fs->last_clst = fp->obj.sclust - 1;		/* Reuse the cluster hole */
   3279          					}
   3280          				} else
   3281          #endif
   3282          				{
   3283          					/* Clean directory info */
   3284          					st_dword(dj.dir + DIR_CrtTime, dw);	/* Set created time */
   3285          					st_dword(dj.dir + DIR_WrtTime, dw);	/* Set modified time */
   3286          					dj.dir[DIR_Attr] = AM_ARC;			/* Reset attribute */
   3287          					cl = ld_clust(fs, dj.dir);			/* Get cluster chain */
   3288          					st_clust(fs, dj.dir, 0);			/* Reset file allocation info */
   3289          					st_dword(dj.dir + DIR_FileSize, 0);
   3290          					fs->wflag = 1;
   3291          
   3292          					if (cl) {							/* Remove the cluster chain if exist */
   3293          						dw = fs->winsect;
   3294          						res = remove_chain(&dj.obj, cl, 0);
   3295          						if (res == FR_OK) {
   3296          							res = move_window(fs, dw);
   3297          							fs->last_clst = cl - 1;		/* Reuse the cluster hole */
   3298          						}
   3299          					}
   3300          				}
   3301          			}
   3302          		}
   3303          		else {	/* Open an existing file */
   3304          			if (res == FR_OK) {					/* Following succeeded */
   3305          				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
   3306          					res = FR_NO_FILE;
   3307          				} else {
   3308          					if ((mode & FA_WRITE) && (dj.obj.attr & AM_RDO)) { /* R/O violation */
   3309          						res = FR_DENIED;
   3310          					}
   3311          				}
   3312          			}
   3313          		}
   3314          		if (res == FR_OK) {
   3315          			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
   3316          				mode |= _FA_MODIFIED;
   3317          			fp->dir_sect = fs->winsect;			/* Pointer to the directory entry */
   3318          			fp->dir_ptr = dj.dir;
   3319          #if _FS_LOCK != 0
   3320          			fp->obj.lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
   3321          			if (!fp->obj.lockid) res = FR_INT_ERR;
   3322          #endif
   3323          		}
   3324          #else		/* R/O configuration */
   3325          		if (res == FR_OK) {
   3326          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* Origin directory itself? */
   3327          				res = FR_INVALID_NAME;
   3328          			} else {
   3329          				if (dj.obj.attr & AM_DIR) {		/* It is a directory */
   3330          					res = FR_NO_FILE;
   3331          				}
   3332          			}
   3333          		}
   3334          #endif
   3335          
   3336          		if (res == FR_OK) {
   3337          #if _FS_EXFAT
   3338          			if (fs->fs_type == FS_EXFAT) {
   3339          				fp->obj.sclust = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Get allocation info */
   3340          				fp->obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   3341          				fp->obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   3342          				fp->obj.c_scl = dj.obj.sclust;
   3343          				fp->obj.c_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
   3344          				fp->obj.c_ofs = dj.blk_ofs;
   3345          			} else
   3346          #endif
   3347          			{
   3348          				fp->obj.sclust = ld_clust(fs, dj.dir);				/* Get allocation info */
   3349          				fp->obj.objsize = ld_dword(dj.dir + DIR_FileSize);
   3350          			}
   3351          #if _USE_FASTSEEK
   3352          			fp->cltbl = 0;			/* Normal seek mode */
   3353          #endif
   3354          			fp->err = 0;			/* Clear error flag */
   3355          			fp->fptr = 0;			/* Set file pointer */
   3356          			fp->sect = 0;			/* Invalidate current data sector */
   3357          			fp->flag = mode;		/* File access mode */
   3358          			fp->obj.fs = fs;	 	/* Validate the file object */
   3359          			fp->obj.id = fs->id;
   3360          		}
   3361          
   3362          		FREE_NAMBUF();
   3363          	}
   3364          
   3365          	LEAVE_FF(dj.obj.fs, res);
   3366          }
   3367          
   3368          
   3369          
   3370          
   3371          /*-----------------------------------------------------------------------*/
   3372          /* Read File                                                             */
   3373          /*-----------------------------------------------------------------------*/
   3374          
   3375          FRESULT f_read (
   3376          	FIL* fp, 	/* Pointer to the file object */
   3377          	void* buff,	/* Pointer to data buffer */
   3378          	UINT btr,	/* Number of bytes to read */
   3379          	UINT* br	/* Pointer to number of bytes read */
   3380          )
   3381          {
   3382          	FRESULT res;
   3383          	FATFS *fs;
   3384          	DWORD clst, sect;
   3385          	FSIZE_t remain;
   3386          	UINT rcnt, cc, csect;
   3387          	BYTE *rbuff = (BYTE*)buff;
   3388          
   3389          
   3390          	*br = 0;	/* Clear read byte counter */
   3391          	res = validate(fp, &fs);
   3392          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3393          	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED); /* Check access mode */
   3394          	remain = fp->obj.objsize - fp->fptr;
   3395          	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
   3396          
   3397          	for ( ;  btr;								/* Repeat until all data read */
   3398          		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
   3399          		if ((fp->fptr % SS(fs)) == 0) {			/* On the sector boundary? */
   3400          			csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
   3401          			if (csect == 0) {					/* On the cluster boundary? */
   3402          				if (fp->fptr == 0) {			/* On the top of the file? */
   3403          					clst = fp->obj.sclust;		/* Follow cluster chain from the origin */
   3404          				} else {						/* Middle or end of the file */
   3405          #if _USE_FASTSEEK
   3406          					if (fp->cltbl) {
   3407          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3408          					} else
   3409          #endif
   3410          					{
   3411          						clst = get_fat(&fp->obj, fp->clust);	/* Follow cluster chain on the FAT */
   3412          					}
   3413          				}
   3414          				if (clst < 2) ABORT(fs, FR_INT_ERR);
   3415          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3416          				fp->clust = clst;				/* Update current cluster */
   3417          			}
   3418          			sect = clust2sect(fs, fp->clust);	/* Get current sector */
   3419          			if (!sect) ABORT(fs, FR_INT_ERR);
   3420          			sect += csect;
   3421          			cc = btr / SS(fs);					/* When remaining bytes >= sector size, */
   3422          			if (cc) {							/* Read maximum contiguous sectors directly */
   3423          				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
   3424          					cc = fs->csize - csect;
   3425          				}
   3426          				if (disk_read(fs->drv, rbuff, sect, cc) != RES_OK) {
   3427          					ABORT(fs, FR_DISK_ERR);
   3428          				}
   3429          #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
   3430          #if _FS_TINY
   3431          				if (fs->wflag && fs->winsect - sect < cc) {
   3432          					mem_cpy(rbuff + ((fs->winsect - sect) * SS(fs)), fs->win, SS(fs));
   3433          				}
   3434          #else
   3435          				if ((fp->flag & _FA_DIRTY) && fp->sect - sect < cc) {
   3436          					mem_cpy(rbuff + ((fp->sect - sect) * SS(fs)), fp->buf, SS(fs));
   3437          				}
   3438          #endif
   3439          #endif
   3440          				rcnt = SS(fs) * cc;				/* Number of bytes transferred */
   3441          				continue;
   3442          			}
   3443          #if !_FS_TINY
   3444          			if (fp->sect != sect) {			/* Load data sector if not in cache */
   3445          #if !_FS_READONLY
   3446          				if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
   3447          					if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3448          						ABORT(fs, FR_DISK_ERR);
   3449          					}
   3450          					fp->flag &= ~_FA_DIRTY;
   3451          				}
   3452          #endif
   3453          				if (disk_read(fs->drv, fp->buf, sect, 1) != RES_OK)	{	/* Fill sector cache */
   3454          					ABORT(fs, FR_DISK_ERR);
   3455          				}
   3456          			}
   3457          #endif
   3458          			fp->sect = sect;
   3459          		}
   3460          		rcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Get partial sector data from sector buffer */
   3461          		if (rcnt > btr) rcnt = btr;
   3462          #if _FS_TINY
   3463          		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
   3464          			ABORT(fs, FR_DISK_ERR);
   3465          		}
   3466          		mem_cpy(rbuff, &fs->win[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
   3467          #else
   3468          		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fs)], rcnt);	/* Pick partial sector */
   3469          #endif
   3470          	}
   3471          
   3472          	LEAVE_FF(fs, FR_OK);
   3473          }
   3474          
   3475          
   3476          
   3477          
   3478          #if !_FS_READONLY
   3479          /*-----------------------------------------------------------------------*/
   3480          /* Write File                                                            */
   3481          /*-----------------------------------------------------------------------*/
   3482          
   3483          FRESULT f_write (
   3484          	FIL* fp,			/* Pointer to the file object */
   3485          	const void* buff,	/* Pointer to the data to be written */
   3486          	UINT btw,			/* Number of bytes to write */
   3487          	UINT* bw			/* Pointer to number of bytes written */
   3488          )
   3489          {
   3490          	FRESULT res;
   3491          	FATFS *fs;
   3492          	DWORD clst, sect;
   3493          	UINT wcnt, cc, csect;
   3494          	const BYTE *wbuff = (const BYTE*)buff;
   3495          
   3496          
   3497          	*bw = 0;	/* Clear write byte counter */
   3498          	res = validate(fp, &fs);
   3499          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3500          	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   3501          
   3502          	/* Check fptr wrap-around (file size cannot exceed the limit on each FAT specs) */
   3503          	if ((_FS_EXFAT && fs->fs_type == FS_EXFAT && fp->fptr + btw < fp->fptr)
   3504          		|| (DWORD)fp->fptr + btw < (DWORD)fp->fptr) {
   3505          		btw = (UINT)(0xFFFFFFFF - (DWORD)fp->fptr);
   3506          	}
   3507          
   3508          	for ( ;  btw;							/* Repeat until all data written */
   3509          		wbuff += wcnt, fp->fptr += wcnt, fp->obj.objsize = (fp->fptr > fp->obj.objsize) ? fp->fptr : fp->obj.objsize, *bw += wcnt, btw -= wcnt) {
   3510          		if ((fp->fptr % SS(fs)) == 0) {		/* On the sector boundary? */
   3511          			csect = (UINT)(fp->fptr / SS(fs)) & (fs->csize - 1);	/* Sector offset in the cluster */
   3512          			if (csect == 0) {				/* On the cluster boundary? */
   3513          				if (fp->fptr == 0) {		/* On the top of the file? */
   3514          					clst = fp->obj.sclust;	/* Follow from the origin */
   3515          					if (clst == 0) {		/* If no cluster is allocated, */
   3516          						clst = create_chain(&fp->obj, 0);	/* create a new cluster chain */
   3517          					}
   3518          				} else {					/* On the middle or end of the file */
   3519          #if _USE_FASTSEEK
   3520          					if (fp->cltbl) {
   3521          						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
   3522          					} else
   3523          #endif
   3524          					{
   3525          						clst = create_chain(&fp->obj, fp->clust);	/* Follow or stretch cluster chain on the FAT */
   3526          					}
   3527          				}
   3528          				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
   3529          				if (clst == 1) ABORT(fs, FR_INT_ERR);
   3530          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3531          				fp->clust = clst;			/* Update current cluster */
   3532          				if (fp->obj.sclust == 0) fp->obj.sclust = clst;	/* Set start cluster if the first write */
   3533          			}
   3534          #if _FS_TINY
   3535          			if (fs->winsect == fp->sect && sync_window(fs) != FR_OK)	{	/* Write-back sector cache */
   3536          				ABORT(fs, FR_DISK_ERR);
   3537          			}
   3538          #else
   3539          			if (fp->flag & _FA_DIRTY) {		/* Write-back sector cache */
   3540          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3541          					ABORT(fs, FR_DISK_ERR);
   3542          				}
   3543          				fp->flag &= ~_FA_DIRTY;
   3544          			}
   3545          #endif
   3546          			sect = clust2sect(fs, fp->clust);	/* Get current sector */
   3547          			if (!sect) ABORT(fs, FR_INT_ERR);
   3548          			sect += csect;
   3549          			cc = btw / SS(fs);				/* When remaining bytes >= sector size, */
   3550          			if (cc) {						/* Write maximum contiguous sectors directly */
   3551          				if (csect + cc > fs->csize) {	/* Clip at cluster boundary */
   3552          					cc = fs->csize - csect;
   3553          				}
   3554          				if (disk_write(fs->drv, wbuff, sect, cc) != RES_OK) {
   3555          					ABORT(fs, FR_DISK_ERR);
   3556          				}
   3557          #if _FS_MINIMIZE <= 2
   3558          #if _FS_TINY
   3559          				if (fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
   3560          					mem_cpy(fs->win, wbuff + ((fs->winsect - sect) * SS(fs)), SS(fs));
   3561          					fs->wflag = 0;
   3562          				}
   3563          #else
   3564          				if (fp->sect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
   3565          					mem_cpy(fp->buf, wbuff + ((fp->sect - sect) * SS(fs)), SS(fs));
   3566          					fp->flag &= ~_FA_DIRTY;
   3567          				}
   3568          #endif
   3569          #endif
   3570          				wcnt = SS(fs) * cc;		/* Number of bytes transferred */
   3571          				continue;
   3572          			}
   3573          #if _FS_TINY
   3574          			if (fp->fptr >= fp->obj.objsize) {	/* Avoid silly cache filling at growing edge */
   3575          				if (sync_window(fs) != FR_OK) ABORT(fs, FR_DISK_ERR);
   3576          				fs->winsect = sect;
   3577          			}
   3578          #else
   3579          			if (fp->sect != sect) {		/* Fill sector cache with file data */
   3580          				if (fp->fptr < fp->obj.objsize &&
   3581          					disk_read(fs->drv, fp->buf, sect, 1) != RES_OK) {
   3582          						ABORT(fs, FR_DISK_ERR);
   3583          				}
   3584          			}
   3585          #endif
   3586          			fp->sect = sect;
   3587          		}
   3588          		wcnt = SS(fs) - ((UINT)fp->fptr % SS(fs));	/* Put partial sector into file I/O buffer */
   3589          		if (wcnt > btw) wcnt = btw;
   3590          #if _FS_TINY
   3591          		if (move_window(fs, fp->sect) != FR_OK) {	/* Move sector window */
   3592          			ABORT(fs, FR_DISK_ERR);
   3593          		}
   3594          		mem_cpy(&fs->win[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
   3595          		fs->wflag = 1;
   3596          #else
   3597          		mem_cpy(&fp->buf[fp->fptr % SS(fs)], wbuff, wcnt);	/* Fit partial sector */
   3598          		fp->flag |= _FA_DIRTY;
   3599          #endif
   3600          	}
   3601          
   3602          	fp->flag |= _FA_MODIFIED;						/* Set file change flag */
   3603          
   3604          	LEAVE_FF(fs, FR_OK);
   3605          }
   3606          
   3607          
   3608          
   3609          
   3610          /*-----------------------------------------------------------------------*/
   3611          /* Synchronize the File                                                  */
   3612          /*-----------------------------------------------------------------------*/
   3613          
   3614          FRESULT f_sync (
   3615          	FIL* fp		/* Pointer to the file object */
   3616          )
   3617          {
   3618          	FRESULT res;
   3619          	FATFS *fs;
   3620          	DWORD tm;
   3621          	BYTE *dir;
   3622          	DEF_DIRBUF;
   3623          
   3624          
   3625          	res = validate(fp, &fs);	/* Check validity of the object */
   3626          	if (res == FR_OK) {
   3627          		if (fp->flag & _FA_MODIFIED) {	/* Is there any change to the file? */
   3628          #if !_FS_TINY
   3629          			if (fp->flag & _FA_DIRTY) {	/* Write-back cached data if needed */
   3630          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3631          					LEAVE_FF(fs, FR_DISK_ERR);
   3632          				}
   3633          				fp->flag &= ~_FA_DIRTY;
   3634          			}
   3635          #endif
   3636          			/* Update the directory entry */
   3637          			tm = GET_FATTIME();				/* Modified time */
   3638          #if _FS_EXFAT
   3639          			if (fs->fs_type == FS_EXFAT) {
   3640          				res = fill_fat_chain(&fp->obj);	/* Create FAT chain if needed */
   3641          				if (res == FR_OK) {
   3642          					DIR dj;
   3643          
   3644          					INIT_DIRBUF(fs);
   3645          					res = load_obj_dir(&dj, &fp->obj);	/* Load directory entry block */
   3646          					if (res == FR_OK) {
   3647          						fs->dirbuf[XDIR_Attr] |= AM_ARC;					/* Set archive bit */
   3648          						fs->dirbuf[XDIR_GenFlags] = fp->obj.stat | 1;		/* Update file allocation info */
   3649          						st_dword(fs->dirbuf + XDIR_FstClus, fp->obj.sclust);
   3650          						st_qword(fs->dirbuf + XDIR_FileSize, fp->obj.objsize);
   3651          						st_qword(fs->dirbuf + XDIR_ValidFileSize, fp->obj.objsize);
   3652          						st_dword(fs->dirbuf + XDIR_ModTime, tm);			/* Update modified time */
   3653          						fs->dirbuf[XDIR_ModTime10] = 0;
   3654          						st_dword(fs->dirbuf + XDIR_AccTime, 0);
   3655          						res = store_xdir(&dj);	/* Restore it to the directory */
   3656          						if (res == FR_OK) {
   3657          							res = sync_fs(fs);
   3658          							fp->flag &= ~_FA_MODIFIED;
   3659          						}
   3660          					}
   3661          					FREE_DIRBUF();
   3662          				}
   3663          			} else
   3664          #endif
   3665          			{
   3666          				res = move_window(fs, fp->dir_sect);
   3667          				if (res == FR_OK) {
   3668          					dir = fp->dir_ptr;
   3669          					dir[DIR_Attr] |= AM_ARC;						/* Set archive bit */
   3670          					st_clust(fp->obj.fs, dir, fp->obj.sclust);		/* Update file allocation info  */
   3671          					st_dword(dir + DIR_FileSize, (DWORD)fp->obj.objsize);	/* Update file size */
   3672          					st_dword(dir + DIR_WrtTime, tm);				/* Update modified time */
   3673          					st_word(dir + DIR_LstAccDate, 0);
   3674          					fs->wflag = 1;
   3675          					res = sync_fs(fs);					/* Restore it to the directory */
   3676          					fp->flag &= ~_FA_MODIFIED;
   3677          				}
   3678          			}
   3679          		}
   3680          	}
   3681          
   3682          	LEAVE_FF(fs, res);
   3683          }
   3684          
   3685          #endif /* !_FS_READONLY */
   3686          
   3687          
   3688          
   3689          
   3690          /*-----------------------------------------------------------------------*/
   3691          /* Close File                                                            */
   3692          /*-----------------------------------------------------------------------*/
   3693          
   3694          FRESULT f_close (
   3695          	FIL* fp		/* Pointer to the file object to be closed */
   3696          )
   3697          {
   3698          	FRESULT res;
   3699          	FATFS *fs;
   3700          
   3701          #if !_FS_READONLY
   3702          	res = f_sync(fp);					/* Flush cached data */
   3703          	if (res == FR_OK)
   3704          #endif
   3705          	{
   3706          		res = validate(fp, &fs);	/* Lock volume */
   3707          		if (res == FR_OK) {
   3708          #if _FS_LOCK != 0
   3709          			res = dec_lock(fp->obj.lockid);	/* Decrement file open counter */
   3710          			if (res == FR_OK)
   3711          #endif
   3712          			{
   3713          				fp->obj.fs = 0;			/* Invalidate file object */
   3714          			}
   3715          #if _FS_REENTRANT
   3716          			unlock_fs(fs, FR_OK);		/* Unlock volume */
   3717          #endif
   3718          		}
   3719          	}
   3720          	return res;
   3721          }
   3722          
   3723          
   3724          
   3725          
   3726          /*-----------------------------------------------------------------------*/
   3727          /* Change Current Directory or Current Drive, Get Current Directory      */
   3728          /*-----------------------------------------------------------------------*/
   3729          
   3730          #if _FS_RPATH >= 1
   3731          #if _VOLUMES >= 2
   3732          FRESULT f_chdrive (
   3733          	const TCHAR* path		/* Drive number */
   3734          )
   3735          {
   3736          	int vol;
   3737          
   3738          
   3739          	vol = get_ldnumber(&path);
   3740          	if (vol < 0) return FR_INVALID_DRIVE;
   3741          
   3742          	CurrVol = (BYTE)vol;
   3743          
   3744          	return FR_OK;
   3745          }
   3746          #endif
   3747          
   3748          
   3749          FRESULT f_chdir (
   3750          	const TCHAR* path	/* Pointer to the directory path */
   3751          )
   3752          {
   3753          	FRESULT res;
   3754          	DIR dj;
   3755          	FATFS *fs;
   3756          	DEF_NAMBUF;
   3757          
   3758          	/* Get logical drive number */
   3759          	res = find_volume(&path, &fs, 0);
   3760          	if (res == FR_OK) {
   3761          		dj.obj.fs = fs;
   3762          		INIT_NAMBUF(dj);
   3763          		res = follow_path(&dj, path);		/* Follow the path */
   3764          		if (res == FR_OK) {					/* Follow completed */
   3765          			if (dj.fn[NSFLAG] & NS_NONAME) {
   3766          				fs->cdir = dj.obj.sclust;	/* It is the start directory itself */
   3767          #if _FS_EXFAT
   3768          				if (fs->fs_type == FS_EXFAT) {
   3769          					fs->cdc_scl = dj.obj.c_scl;
   3770          					fs->cdc_size = dj.obj.c_size;
   3771          					fs->cdc_ofs = dj.obj.c_ofs;
   3772          				}
   3773          #endif
   3774          			} else {
   3775          				if (dj.obj.attr & AM_DIR) {	/* It is a sub-directory */
   3776          #if _FS_EXFAT
   3777          					if (fs->fs_type == FS_EXFAT) {
   3778          						fs->cdir = ld_dword(fs->dirbuf + XDIR_FstClus);		/* Sub-directory cluster */
   3779          						fs->cdc_scl = dj.obj.sclust;						/* Save containing directory information */
   3780          						fs->cdc_size = ((DWORD)dj.obj.objsize & 0xFFFFFF00) | dj.obj.stat;
   3781          						fs->cdc_ofs = dj.blk_ofs;
   3782          					} else
   3783          #endif
   3784          					{
   3785          						fs->cdir = ld_clust(fs, dj.dir);					/* Sub-directory cluster */
   3786          					}
   3787          				} else {
   3788          					res = FR_NO_PATH;		/* Reached but a file */
   3789          				}
   3790          			}
   3791          		}
   3792          		FREE_NAMBUF();
   3793          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   3794          	}
   3795          
   3796          	LEAVE_FF(fs, res);
   3797          }
   3798          
   3799          
   3800          #if _FS_RPATH >= 2
   3801          FRESULT f_getcwd (
   3802          	TCHAR* buff,	/* Pointer to the directory path */
   3803          	UINT len		/* Size of path */
   3804          )
   3805          {
   3806          	FRESULT res;
   3807          	DIR dj;
   3808          	FATFS *fs;
   3809          	UINT i, n;
   3810          	DWORD ccl;
   3811          	TCHAR *tp;
   3812          	FILINFO fno;
   3813          	DEF_NAMBUF;
   3814          
   3815          	*buff = 0;
   3816          	/* Get logical drive number */
   3817          	res = find_volume((const TCHAR**)&buff, &fs, 0);	/* Get current volume */
   3818          	if (res == FR_OK) {
   3819          		dj.obj.fs = fs;
   3820          		INIT_NAMBUF(dj);
   3821          		i = len;			/* Bottom of buffer (directory stack base) */
   3822          		if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {	/* (Cannot do getcwd on exFAT and returns root path) */
   3823          			dj.obj.sclust = fs->cdir;				/* Start to follow upper directory from current directory */
   3824          			while ((ccl = dj.obj.sclust) != 0) {	/* Repeat while current directory is a sub-directory */
   3825          				res = dir_sdi(&dj, 1 * SZDIRE);	/* Get parent directory */
   3826          				if (res != FR_OK) break;
   3827          				res = move_window(fs, dj.sect);
   3828          				if (res != FR_OK) break;
   3829          				dj.obj.sclust = ld_clust(fs, dj.dir);	/* Goto parent directory */
   3830          				res = dir_sdi(&dj, 0);
   3831          				if (res != FR_OK) break;
   3832          				do {							/* Find the entry links to the child directory */
   3833          					res = dir_read(&dj, 0);
   3834          					if (res != FR_OK) break;
   3835          					if (ccl == ld_clust(fs, dj.dir)) break;	/* Found the entry */
   3836          					res = dir_next(&dj, 0);
   3837          				} while (res == FR_OK);
   3838          				if (res == FR_NO_FILE) res = FR_INT_ERR;/* It cannot be 'not found'. */
   3839          				if (res != FR_OK) break;
   3840          				get_fileinfo(&dj, &fno);		/* Get the directory name and push it to the buffer */
   3841          				for (n = 0; fno.fname[n]; n++) ;
   3842          				if (i < n + 3) {
   3843          					res = FR_NOT_ENOUGH_CORE; break;
   3844          				}
   3845          				while (n) buff[--i] = fno.fname[--n];
   3846          				buff[--i] = '/';
   3847          			}
   3848          		}
   3849          		tp = buff;
   3850          		if (res == FR_OK) {
   3851          #if _VOLUMES >= 2
   3852          			*tp++ = '0' + CurrVol;			/* Put drive number */
   3853          			*tp++ = ':';
   3854          #endif
   3855          			if (i == len) {					/* Root-directory */
   3856          				*tp++ = '/';
   3857          			} else {						/* Sub-directroy */
   3858          				do		/* Add stacked path str */
   3859          					*tp++ = buff[i++];
   3860          				while (i < len);
   3861          			}
   3862          		}
   3863          		*tp = 0;
   3864          		FREE_NAMBUF();
   3865          	}
   3866          
   3867          	LEAVE_FF(fs, res);
   3868          }
   3869          #endif /* _FS_RPATH >= 2 */
   3870          #endif /* _FS_RPATH >= 1 */
   3871          
   3872          
   3873          
   3874          #if _FS_MINIMIZE <= 2
   3875          /*-----------------------------------------------------------------------*/
   3876          /* Seek File R/W Pointer                                                 */
   3877          /*-----------------------------------------------------------------------*/
   3878          
   3879          FRESULT f_lseek (
   3880          	FIL* fp,		/* Pointer to the file object */
   3881          	FSIZE_t ofs		/* File pointer from top of file */
   3882          )
   3883          {
   3884          	FRESULT res;
   3885          	FATFS *fs;
   3886          	DWORD clst, bcs, nsect;
   3887          	FSIZE_t ifptr;
   3888          #if _USE_FASTSEEK
   3889          	DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
   3890          #endif
   3891          
   3892          	res = validate(fp, &fs);		/* Check validity of the object */
   3893          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   3894          #if _USE_FASTSEEK
   3895          	if (fp->cltbl) {	/* Fast seek */
   3896          		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
   3897          			tbl = fp->cltbl;
   3898          			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
   3899          			cl = fp->sclust;			/* Top of the chain */
   3900          			if (cl) {
   3901          				do {
   3902          					/* Get a fragment */
   3903          					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
   3904          					do {
   3905          						pcl = cl; ncl++;
   3906          						cl = get_fat(fs, cl);
   3907          						if (cl <= 1) ABORT(fs, FR_INT_ERR);
   3908          						if (cl == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3909          					} while (cl == pcl + 1);
   3910          					if (ulen <= tlen) {		/* Store the length and top of the fragment */
   3911          						*tbl++ = ncl; *tbl++ = tcl;
   3912          					}
   3913          				} while (cl < fs->n_fatent);	/* Repeat until end of chain */
   3914          			}
   3915          			*fp->cltbl = ulen;	/* Number of items used */
   3916          			if (ulen <= tlen) {
   3917          				*tbl = 0;		/* Terminate table */
   3918          			} else {
   3919          				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
   3920          			}
   3921          		} else {						/* Fast seek */
   3922          			if (ofs > fp->fsize) {		/* Clip offset at the file size */
   3923          				ofs = fp->fsize;
   3924          			}
   3925          			fp->fptr = ofs;				/* Set file pointer */
   3926          			if (ofs) {
   3927          				fp->clust = clmt_clust(fp, ofs - 1);
   3928          				dsc = clust2sect(fs, fp->clust);
   3929          				if (!dsc) ABORT(fs, FR_INT_ERR);
   3930          				dsc += (ofs - 1) / SS(fs) & (fs->csize - 1);
   3931          				if (fp->fptr % SS(fs) && dsc != fp->sect) {	/* Refill sector cache if needed */
   3932          #if !_FS_TINY
   3933          #if !_FS_READONLY
   3934          					if (fp->flag & _FA_DIRTY) {		/* Write-back dirty sector cache */
   3935          						if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   3936          							ABORT(fp, FR_DISK_ERR);
   3937          						}
   3938          						fp->flag &= ~_FA_DIRTY;
   3939          					}
   3940          #endif
   3941          					if (disk_read(fs->drv, fp->buf, dsc, 1) != RES_OK) {	/* Load current sector */
   3942          						ABORT(fs, FR_DISK_ERR);
   3943          					}
   3944          #endif
   3945          					fp->sect = dsc;
   3946          				}
   3947          			}
   3948          		}
   3949          	} else
   3950          #endif
   3951          
   3952          	/* Normal Seek */
   3953          	{
   3954          		if (ofs > fp->obj.objsize				/* In read-only mode, clip offset with the file size */
   3955          #if !_FS_READONLY
   3956          			 && !(fp->flag & FA_WRITE)
   3957          #endif
   3958          			) ofs = fp->obj.objsize;
   3959          
   3960          		ifptr = fp->fptr;
   3961          		fp->fptr = nsect = 0;
   3962          		if (ofs) {
   3963          			bcs = (DWORD)fs->csize * SS(fs);	/* Cluster size (byte) */
   3964          			if (ifptr > 0 &&
   3965          				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
   3966          				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
   3967          				ofs -= fp->fptr;
   3968          				clst = fp->clust;
   3969          			} else {									/* When seek to back cluster, */
   3970          				clst = fp->obj.sclust;					/* start from the first cluster */
   3971          #if !_FS_READONLY
   3972          				if (clst == 0) {						/* If no cluster chain, create a new chain */
   3973          					clst = create_chain(&fp->obj, 0);
   3974          					if (clst == 1) ABORT(fs, FR_INT_ERR);
   3975          					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3976          					fp->obj.sclust = clst;
   3977          				}
   3978          #endif
   3979          				fp->clust = clst;
   3980          			}
   3981          			if (clst != 0) {
   3982          				while (ofs > bcs) {						/* Cluster following loop */
   3983          #if !_FS_READONLY
   3984          					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
   3985          						clst = create_chain(&fp->obj, clst);	/* Force stretch if in write mode */
   3986          						if (clst == 0) {				/* When disk gets full, clip file size */
   3987          							ofs = bcs; break;
   3988          						}
   3989          					} else
   3990          #endif
   3991          						clst = get_fat(&fp->obj, clst);	/* Follow cluster chain if not in write mode */
   3992          					if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   3993          					if (clst <= 1 || clst >= fs->n_fatent) ABORT(fs, FR_INT_ERR);
   3994          					fp->clust = clst;
   3995          					fp->fptr += bcs;
   3996          					ofs -= bcs;
   3997          				}
   3998          				fp->fptr += ofs;
   3999          				if (ofs % SS(fs)) {
   4000          					nsect = clust2sect(fs, clst);	/* Current sector */
   4001          					if (!nsect) ABORT(fs, FR_INT_ERR);
   4002          					nsect += (DWORD)(ofs / SS(fs));
   4003          				}
   4004          			}
   4005          		}
   4006          		if (fp->fptr % SS(fs) && nsect != fp->sect) {	/* Fill sector cache if needed */
   4007          #if !_FS_TINY
   4008          #if !_FS_READONLY
   4009          			if (fp->flag & _FA_DIRTY) {			/* Write-back dirty sector cache */
   4010          				if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   4011          					ABORT(fs, FR_DISK_ERR);
   4012          				}
   4013          				fp->flag &= ~_FA_DIRTY;
   4014          			}
   4015          #endif
   4016          			if (disk_read(fs->drv, fp->buf, nsect, 1) != RES_OK) {	/* Fill sector cache */
   4017          				ABORT(fs, FR_DISK_ERR);
   4018          			}
   4019          #endif
   4020          			fp->sect = nsect;
   4021          		}
   4022          #if !_FS_READONLY
   4023          		if (fp->fptr > fp->obj.objsize) {		/* Set file change flag if the file size is extended */
   4024          			fp->obj.objsize = fp->fptr;
   4025          			fp->flag |= _FA_MODIFIED;
   4026          		}
   4027          #endif
   4028          	}
   4029          
   4030          	LEAVE_FF(fs, res);
   4031          }
   4032          
   4033          
   4034          
   4035          #if _FS_MINIMIZE <= 1
   4036          /*-----------------------------------------------------------------------*/
   4037          /* Create a Directory Object                                             */
   4038          /*-----------------------------------------------------------------------*/
   4039          
   4040          FRESULT f_opendir (
   4041          	DIR* dp,			/* Pointer to directory object to create */
   4042          	const TCHAR* path	/* Pointer to the directory path */
   4043          )
   4044          {
   4045          	FRESULT res;
   4046          	FATFS *fs;
   4047          	_FDID *obj;
   4048          	DEF_NAMBUF;
   4049          
   4050          
   4051          	if (!dp) return FR_INVALID_OBJECT;
   4052          
   4053          	/* Get logical drive number */
   4054          	obj = &dp->obj;
   4055          	res = find_volume(&path, &fs, 0);
   4056          	if (res == FR_OK) {
   4057          		obj->fs = fs;
   4058          		INIT_NAMBUF(*dp);
   4059          		res = follow_path(dp, path);			/* Follow the path to the directory */
   4060          		if (res == FR_OK) {						/* Follow completed */
   4061          			if (!(dp->fn[NSFLAG] & NS_NONAME)) {	/* It is not the origin directory itself */
   4062          				if (obj->attr & AM_DIR) {		/* This object is a sub-directory */
   4063          #if _FS_EXFAT
   4064          					if (fs->fs_type == FS_EXFAT) {
   4065          						obj->c_scl = obj->sclust;	/* Save containing directory inforamation */
   4066          						obj->c_size = ((DWORD)obj->objsize & 0xFFFFFF00) | obj->stat;
   4067          						obj->c_ofs = dp->blk_ofs;
   4068          						obj->sclust = ld_dword(fs->dirbuf + XDIR_FstClus);	/* Get object location and status */
   4069          						obj->objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   4070          						obj->stat = fs->dirbuf[XDIR_GenFlags] & 2;
   4071          					} else
   4072          #endif
   4073          					{
   4074          						obj->sclust = ld_clust(fs, dp->dir);	/* Get object location */
   4075          					}
   4076          				} else {						/* This object is a file */
   4077          					res = FR_NO_PATH;
   4078          				}
   4079          			}
   4080          			if (res == FR_OK) {
   4081          				obj->id = fs->id;
   4082          				res = dir_sdi(dp, 0);			/* Rewind directory */
   4083          #if _FS_LOCK != 0
   4084          				if (res == FR_OK) {
   4085          					if (obj->sclust) {
   4086          						obj->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
   4087          						if (!obj->lockid) res = FR_TOO_MANY_OPEN_FILES;
   4088          					} else {
   4089          						obj->lockid = 0;	/* Root directory need not to be locked */
   4090          					}
   4091          				}
   4092          #endif
   4093          			}
   4094          		}
   4095          		FREE_NAMBUF();
   4096          		if (res == FR_NO_FILE) res = FR_NO_PATH;
   4097          	}
   4098          	if (res != FR_OK) obj->fs = 0;		/* Invalidate the directory object if function faild */
   4099          
   4100          	LEAVE_FF(fs, res);
   4101          }
   4102          
   4103          
   4104          
   4105          
   4106          /*-----------------------------------------------------------------------*/
   4107          /* Close Directory                                                       */
   4108          /*-----------------------------------------------------------------------*/
   4109          
   4110          FRESULT f_closedir (
   4111          	DIR *dp		/* Pointer to the directory object to be closed */
   4112          )
   4113          {
   4114          	FRESULT res;
   4115          	FATFS *fs;
   4116          
   4117          
   4118          	res = validate(dp, &fs);
   4119          	if (res == FR_OK) {
   4120          #if _FS_LOCK != 0
   4121          		if (dp->obj.lockid) {				/* Decrement sub-directory open counter */
   4122          			res = dec_lock(dp->obj.lockid);
   4123          		}
   4124          		if (res == FR_OK)
   4125          #endif
   4126          		{
   4127          			dp->obj.fs = 0;			/* Invalidate directory object */
   4128          		}
   4129          #if _FS_REENTRANT
   4130          		unlock_fs(fs, FR_OK);		/* Unlock volume */
   4131          #endif
   4132          	}
   4133          	return res;
   4134          }
   4135          
   4136          
   4137          
   4138          
   4139          /*-----------------------------------------------------------------------*/
   4140          /* Read Directory Entries in Sequence                                    */
   4141          /*-----------------------------------------------------------------------*/
   4142          
   4143          FRESULT f_readdir (
   4144          	DIR* dp,			/* Pointer to the open directory object */
   4145          	FILINFO* fno		/* Pointer to file information to return */
   4146          )
   4147          {
   4148          	FRESULT res;
   4149          	FATFS *fs;
   4150          	DEF_NAMBUF;
   4151          
   4152          
   4153          	res = validate(dp, &fs);	/* Check validity of the object */
   4154          	if (res == FR_OK) {
   4155          		if (!fno) {
   4156          			res = dir_sdi(dp, 0);			/* Rewind the directory object */
   4157          		} else {
   4158          			INIT_NAMBUF(*dp);
   4159          			res = dir_read(dp, 0);			/* Read an item */
   4160          			if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory */
   4161          			if (res == FR_OK) {				/* A valid entry is found */
   4162          				get_fileinfo(dp, fno);		/* Get the object information */
   4163          				res = dir_next(dp, 0);		/* Increment index for next */
   4164          				if (res == FR_NO_FILE) res = FR_OK;	/* Ignore end of directory now */
   4165          			}
   4166          			FREE_NAMBUF();
   4167          		}
   4168          	}
   4169          	LEAVE_FF(fs, res);
   4170          }
   4171          
   4172          
   4173          
   4174          #if _USE_FIND
   4175          /*-----------------------------------------------------------------------*/
   4176          /* Find Next File                                                        */
   4177          /*-----------------------------------------------------------------------*/
   4178          
   4179          FRESULT f_findnext (
   4180          	DIR* dp,		/* Pointer to the open directory object */
   4181          	FILINFO* fno	/* Pointer to the file information structure */
   4182          )
   4183          {
   4184          	FRESULT res;
   4185          
   4186          
   4187          	for (;;) {
   4188          		res = f_readdir(dp, fno);		/* Get a directory item */
   4189          		if (res != FR_OK || !fno || !fno->fname[0]) break;	/* Terminate if any error or end of directory */
   4190          		if (pattern_matching(dp->pat, fno->fname, 0, 0)) break;		/* Test for the file name */
   4191          #if _USE_LFN != 0 && _USE_FIND == 2
   4192          		if (pattern_matching(dp->pat, fno->altname, 0, 0)) break;	/* Test for alternative name if exist */
   4193          #endif
   4194          	}
   4195          	return res;
   4196          }
   4197          
   4198          
   4199          
   4200          /*-----------------------------------------------------------------------*/
   4201          /* Find First File                                                       */
   4202          /*-----------------------------------------------------------------------*/
   4203          
   4204          FRESULT f_findfirst (
   4205          	DIR* dp,				/* Pointer to the blank directory object */
   4206          	FILINFO* fno,			/* Pointer to the file information structure */
   4207          	const TCHAR* path,		/* Pointer to the directory to open */
   4208          	const TCHAR* pattern	/* Pointer to the matching pattern */
   4209          )
   4210          {
   4211          	FRESULT res;
   4212          
   4213          
   4214          	dp->pat = pattern;		/* Save pointer to pattern string */
   4215          	res = f_opendir(dp, path);		/* Open the target directory */
   4216          	if (res == FR_OK) {
   4217          		res = f_findnext(dp, fno);	/* Find the first item */
   4218          	}
   4219          	return res;
   4220          }
   4221          
   4222          #endif	/* _USE_FIND */
   4223          
   4224          
   4225          
   4226          #if _FS_MINIMIZE == 0
   4227          /*-----------------------------------------------------------------------*/
   4228          /* Get File Status                                                       */
   4229          /*-----------------------------------------------------------------------*/
   4230          
   4231          FRESULT f_stat (
   4232          	const TCHAR* path,	/* Pointer to the file path */
   4233          	FILINFO* fno		/* Pointer to file information to return */
   4234          )
   4235          {
   4236          	FRESULT res;
   4237          	DIR dj;
   4238          	DEF_NAMBUF;
   4239          
   4240          
   4241          	/* Get logical drive number */
   4242          	res = find_volume(&path, &dj.obj.fs, 0);
   4243          	if (res == FR_OK) {
   4244          		INIT_NAMBUF(dj);
   4245          		res = follow_path(&dj, path);	/* Follow the file path */
   4246          		if (res == FR_OK) {				/* Follow completed */
   4247          			if (dj.fn[NSFLAG] & NS_NONAME) {	/* It is origin directory */
   4248          				res = FR_INVALID_NAME;
   4249          			} else {							/* Found an object */
   4250          				if (fno) get_fileinfo(&dj, fno);
   4251          			}
   4252          		}
   4253          		FREE_NAMBUF();
   4254          	}
   4255          
   4256          	LEAVE_FF(dj.obj.fs, res);
   4257          }
   4258          
   4259          
   4260          
   4261          #if !_FS_READONLY
   4262          /*-----------------------------------------------------------------------*/
   4263          /* Get Number of Free Clusters                                           */
   4264          /*-----------------------------------------------------------------------*/
   4265          
   4266          FRESULT f_getfree (
   4267          	const TCHAR* path,	/* Path name of the logical drive number */
   4268          	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
   4269          	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
   4270          )
   4271          {
   4272          	FRESULT res;
   4273          	FATFS *fs;
   4274          	DWORD nfree, clst, sect, stat;
   4275          	UINT i;
   4276          	BYTE *p;
   4277          	_FDID obj;
   4278          
   4279          
   4280          	/* Get logical drive number */
   4281          	res = find_volume(&path, &fs, 0);
   4282          	if (res == FR_OK) {
   4283          		*fatfs = fs;				/* Return ptr to the fs object */
   4284          		/* If free_clst is valid, return it without full cluster scan */
   4285          		if (fs->free_clst <= fs->n_fatent - 2) {
   4286          			*nclst = fs->free_clst;
   4287          		} else {
   4288          			/* Get number of free clusters */
   4289          			nfree = 0;
   4290          			if (fs->fs_type == FS_FAT12) {	/* FAT12: Sector unalighed FAT entries */
   4291          				clst = 2; obj.fs = fs;
   4292          				do {
   4293          					stat = get_fat(&obj, clst);
   4294          					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   4295          					if (stat == 1) { res = FR_INT_ERR; break; }
   4296          					if (stat == 0) nfree++;
   4297          				} while (++clst < fs->n_fatent);
   4298          			} else {
   4299          #if _FS_EXFAT
   4300          				if (fs->fs_type == FS_EXFAT) {	/* exFAT: Scan bitmap table */
   4301          					BYTE bm;
   4302          					UINT b;
   4303          
   4304          					clst = fs->n_fatent - 2;
   4305          					sect = fs->database;
   4306          					i = 0;
   4307          					do {
   4308          						if (i == 0 && (res = move_window(fs, sect++)) != FR_OK) break;
   4309          						for (b = 8, bm = fs->win[i]; b && clst; b--, clst--) {
   4310          							if (!(bm & 1)) nfree++;
   4311          							bm >>= 1;
   4312          						}
   4313          						i = (i + 1) & (SS(fs) - 1);
   4314          					} while (clst);
   4315          				} else
   4316          #endif
   4317          				{	/* FAT16/32: Sector alighed FAT entries */
   4318          					clst = fs->n_fatent; sect = fs->fatbase;
   4319          					i = 0; p = 0;
   4320          					do {
   4321          						if (i == 0) {
   4322          							res = move_window(fs, sect++);
   4323          							if (res != FR_OK) break;
   4324          							p = fs->win;
   4325          							i = SS(fs);
   4326          						}
   4327          						if (fs->fs_type == FS_FAT16) {
   4328          							if (ld_word(p) == 0) nfree++;
   4329          							p += 2; i -= 2;
   4330          						} else {
   4331          							if ((ld_dword(p) & 0x0FFFFFFF) == 0) nfree++;
   4332          							p += 4; i -= 4;
   4333          						}
   4334          					} while (--clst);
   4335          				}
   4336          			}
   4337          			*nclst = nfree;			/* Return the free clusters */
   4338          			fs->free_clst = nfree;	/* Now free_clst is valid */
   4339          			fs->fsi_flag |= 1;		/* FSInfo is to be updated */
   4340          		}
   4341          	}
   4342          
   4343          	LEAVE_FF(fs, res);
   4344          }
   4345          
   4346          
   4347          
   4348          
   4349          /*-----------------------------------------------------------------------*/
   4350          /* Truncate File                                                         */
   4351          /*-----------------------------------------------------------------------*/
   4352          
   4353          FRESULT f_truncate (
   4354          	FIL* fp		/* Pointer to the file object */
   4355          )
   4356          {
   4357          	FRESULT res;
   4358          	FATFS *fs;
   4359          	DWORD ncl;
   4360          
   4361          
   4362          	res = validate(fp, &fs);	/* Check validity of the object */
   4363          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   4364          	if (!(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   4365          
   4366          	if (fp->obj.objsize > fp->fptr) {
   4367          		if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
   4368          			res = remove_chain(&fp->obj, fp->obj.sclust, 0);
   4369          			fp->obj.sclust = 0;
   4370          		} else {				/* When truncate a part of the file, remove remaining clusters */
   4371          			ncl = get_fat(&fp->obj, fp->clust);
   4372          			res = FR_OK;
   4373          			if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
   4374          			if (ncl == 1) res = FR_INT_ERR;
   4375          			if (res == FR_OK && ncl < fs->n_fatent) {
   4376          				res = remove_chain(&fp->obj, ncl, fp->clust);
   4377          			}
   4378          		}
   4379          		fp->obj.objsize = fp->fptr;	/* Set file size to current R/W point */
   4380          		fp->flag |= _FA_MODIFIED;
   4381          #if !_FS_TINY
   4382          		if (res == FR_OK && (fp->flag & _FA_DIRTY)) {
   4383          			if (disk_write(fs->drv, fp->buf, fp->sect, 1) != RES_OK) {
   4384          				res = FR_DISK_ERR;
   4385          			} else {
   4386          				fp->flag &= ~_FA_DIRTY;
   4387          			}
   4388          		}
   4389          #endif
   4390          		if (res != FR_OK) ABORT(fs, res);
   4391          	}
   4392          
   4393          	LEAVE_FF(fs, res);
   4394          }
   4395          
   4396          
   4397          
   4398          
   4399          /*-----------------------------------------------------------------------*/
   4400          /* Delete a File/Directory                                               */
   4401          /*-----------------------------------------------------------------------*/
   4402          
   4403          FRESULT f_unlink (
   4404          	const TCHAR* path		/* Pointer to the file or directory path */
   4405          )
   4406          {
   4407          	FRESULT res;
   4408          	DIR dj, sdj;
   4409          	DWORD dclst = 0;
   4410          	FATFS *fs;
   4411          #if _FS_EXFAT
   4412          	_FDID obj;
   4413          #endif
   4414          	DEF_NAMBUF;
   4415          
   4416          
   4417          	/* Get logical drive number */
   4418          	res = find_volume(&path, &fs, FA_WRITE);
   4419          	dj.obj.fs = fs;
   4420          	if (res == FR_OK) {
   4421          		INIT_NAMBUF(dj);
   4422          		res = follow_path(&dj, path);		/* Follow the file path */
   4423          		if (_FS_RPATH && res == FR_OK && (dj.fn[NSFLAG] & NS_DOT)) {
   4424          			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
   4425          		}
   4426          #if _FS_LOCK != 0
   4427          		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Check if it is an open object */
   4428          #endif
   4429          		if (res == FR_OK) {					/* The object is accessible */
   4430          			if (dj.fn[NSFLAG] & NS_NONAME) {
   4431          				res = FR_INVALID_NAME;		/* Cannot remove the origin directory */
   4432          			} else {
   4433          				if (dj.obj.attr & AM_RDO) {
   4434          					res = FR_DENIED;		/* Cannot remove R/O object */
   4435          				}
   4436          			}
   4437          			if (res == FR_OK) {
   4438          #if _FS_EXFAT
   4439          				obj.fs = fs;
   4440          				if (fs->fs_type == FS_EXFAT) {
   4441          					obj.sclust = dclst = ld_dword(fs->dirbuf + XDIR_FstClus);
   4442          					obj.objsize = ld_qword(fs->dirbuf + XDIR_FileSize);
   4443          					obj.stat = fs->dirbuf[XDIR_GenFlags] & 2;
   4444          				} else
   4445          #endif
   4446          				{
   4447          					dclst = ld_clust(fs, dj.dir);
   4448          				}
   4449          				if (dj.obj.attr & AM_DIR) {			/* Is it a sub-directory ? */
   4450          #if _FS_RPATH != 0
   4451          					if (dclst == fs->cdir) {		 		/* Is it the current directory? */
   4452          						res = FR_DENIED;
   4453          					} else
   4454          #endif
   4455          					{
   4456          						sdj.obj.fs = fs;						/* Open the sub-directory */
   4457          						sdj.obj.sclust = dclst;
   4458          #if _FS_EXFAT
   4459          						if (fs->fs_type == FS_EXFAT) {
   4460          							sdj.obj.objsize = obj.objsize;
   4461          							sdj.obj.stat = obj.stat;
   4462          						}
   4463          #endif
   4464          						res = dir_sdi(&sdj, 0);
   4465          						if (res == FR_OK) {
   4466          							res = dir_read(&sdj, 0);			/* Read an item */
   4467          							if (res == FR_OK) res = FR_DENIED;	/* Not empty? */
   4468          							if (res == FR_NO_FILE) res = FR_OK;	/* Empty? */
   4469          						}
   4470          					}
   4471          				}
   4472          			}
   4473          			if (res == FR_OK) {
   4474          				res = dir_remove(&dj);			/* Remove the directory entry */
   4475          				if (res == FR_OK && dclst) {	/* Remove the cluster chain if exist */
   4476          #if _FS_EXFAT
   4477          					res = remove_chain(&obj, dclst, 0);
   4478          #else
   4479          					res = remove_chain(&dj.obj, dclst, 0);
   4480          #endif
   4481          				}
   4482          				if (res == FR_OK) res = sync_fs(fs);
   4483          			}
   4484          		}
   4485          		FREE_NAMBUF();
   4486          	}
   4487          
   4488          	LEAVE_FF(fs, res);
   4489          }
   4490          
   4491          
   4492          
   4493          
   4494          /*-----------------------------------------------------------------------*/
   4495          /* Create a Directory                                                    */
   4496          /*-----------------------------------------------------------------------*/
   4497          
   4498          FRESULT f_mkdir (
   4499          	const TCHAR* path		/* Pointer to the directory path */
   4500          )
   4501          {
   4502          	FRESULT res;
   4503          	DIR dj;
   4504          	FATFS *fs;
   4505          	BYTE *dir;
   4506          	UINT n;
   4507          	DWORD dsc, dcl, pcl, tm;
   4508          	DEF_NAMBUF;
   4509          
   4510          
   4511          	/* Get logical drive number */
   4512          	res = find_volume(&path, &fs, FA_WRITE);
   4513          	dj.obj.fs = fs;
   4514          	if (res == FR_OK) {
   4515          		INIT_NAMBUF(dj);
   4516          		res = follow_path(&dj, path);			/* Follow the file path */
   4517          		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
   4518          		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NSFLAG] & NS_DOT)) {
   4519          			res = FR_INVALID_NAME;
   4520          		}
   4521          		if (res == FR_NO_FILE) {				/* Can create a new directory */
   4522          			dcl = create_chain(&dj.obj, 0);		/* Allocate a cluster for the new directory table */
   4523          			dj.obj.objsize = (DWORD)fs->csize * SS(fs);
   4524          			res = FR_OK;
   4525          			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
   4526          			if (dcl == 1) res = FR_INT_ERR;
   4527          			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
   4528          			if (res == FR_OK) res = sync_window(fs);	/* Flush FAT */
   4529          			tm = GET_FATTIME();
   4530          			if (res == FR_OK) {					/* Initialize the new directory table */
   4531          				dsc = clust2sect(fs, dcl);
   4532          				dir = fs->win;
   4533          				mem_set(dir, 0, SS(fs));
   4534          				if (!_FS_EXFAT || fs->fs_type != FS_EXFAT) {
   4535          					mem_set(dir + DIR_Name, ' ', 11);	/* Create "." entry */
   4536          					dir[DIR_Name] = '.';
   4537          					dir[DIR_Attr] = AM_DIR;
   4538          					st_dword(dir + DIR_WrtTime, tm);
   4539          					st_clust(fs, dir, dcl);
   4540          					mem_cpy(dir + SZDIRE, dir, SZDIRE); 	/* Create ".." entry */
   4541          					dir[SZDIRE + 1] = '.'; pcl = dj.obj.sclust;
   4542          					if (fs->fs_type == FS_FAT32 && pcl == fs->dirbase)
   4543          						pcl = 0;
   4544          					st_clust(fs, dir + SZDIRE, pcl);
   4545          				}
   4546          				for (n = fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
   4547          					fs->winsect = dsc++;
   4548          					fs->wflag = 1;
   4549          					res = sync_window(fs);
   4550          					if (res != FR_OK) break;
   4551          					mem_set(dir, 0, SS(fs));
   4552          				}
   4553          			}
   4554          			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
   4555          			if (res == FR_OK) {
   4556          #if _FS_EXFAT
   4557          				if (fs->fs_type == FS_EXFAT) {
   4558          					st_dword(fs->dirbuf + XDIR_ModTime, tm);
   4559          					st_dword(fs->dirbuf + XDIR_FstClus, dcl);
   4560          					st_dword(fs->dirbuf + XDIR_FileSize, (DWORD)dj.obj.objsize);
   4561          					st_dword(fs->dirbuf + XDIR_ValidFileSize, (DWORD)dj.obj.objsize);
   4562          					fs->dirbuf[XDIR_GenFlags] = 3;
   4563          					fs->dirbuf[XDIR_Attr] = AM_DIR;
   4564          					res = store_xdir(&dj);
   4565          				} else
   4566          #endif
   4567          				{
   4568          					dir = dj.dir;
   4569          					st_dword(dir + DIR_WrtTime, tm);	/* Created time */
   4570          					st_clust(fs, dir, dcl);				/* Table start cluster */
   4571          					dir[DIR_Attr] = AM_DIR;				/* Attribute */
   4572          					fs->wflag = 1;
   4573          				}
   4574          				res = sync_fs(fs);
   4575          			} else {
   4576          				remove_chain(&dj.obj, dcl, 0);		/* Could not register, remove cluster chain */
   4577          			}
   4578          		}
   4579          		FREE_NAMBUF();
   4580          	}
   4581          
   4582          	LEAVE_FF(fs, res);
   4583          }
   4584          
   4585          
   4586          
   4587          
   4588          /*-----------------------------------------------------------------------*/
   4589          /* Rename a File/Directory                                               */
   4590          /*-----------------------------------------------------------------------*/
   4591          
   4592          FRESULT f_rename (
   4593          	const TCHAR* path_old,	/* Pointer to the object name to be renamed */
   4594          	const TCHAR* path_new	/* Pointer to the new name */
   4595          )
   4596          {
   4597          	FRESULT res;
   4598          	DIR djo, djn;
   4599          	FATFS *fs;
   4600          	BYTE buf[_FS_EXFAT ? SZDIRE * 2 : 24], *dir;
   4601          	DWORD dw;
   4602          	DEF_NAMBUF;
   4603          
   4604          
   4605          	get_ldnumber(&path_new);						/* Ignore drive number of new name */
   4606          	res = find_volume(&path_old, &fs, FA_WRITE);	/* Get logical drive number of the old object */
   4607          	if (res == FR_OK) {
   4608          		djo.obj.fs = fs;
   4609          		INIT_NAMBUF(djo);
   4610          		res = follow_path(&djo, path_old);		/* Check old object */
   4611          		if (res == FR_OK && (djo.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check validity of name */
   4612          #if _FS_LOCK != 0
   4613          		if (res == FR_OK) res = chk_lock(&djo, 2);
   4614          #endif
   4615          		if (res == FR_OK) {						/* Object to be renamed is found */
   4616          #if _FS_EXFAT
   4617          			if (fs->fs_type == FS_EXFAT) {	/* At exFAT */
   4618          				BYTE nf, nn;
   4619          				WORD nh;
   4620          
   4621          				mem_cpy(buf, fs->dirbuf, SZDIRE * 2);	/* Save 85+C0 entry of old object */
   4622          				mem_cpy(&djn, &djo, sizeof djo);
   4623          				res = follow_path(&djn, path_new);	/* Make sure if new object name is not in use */
   4624          				if (res == FR_OK) res = FR_EXIST;	/* Is new name already in use? */
   4625          				if (res == FR_NO_FILE) { 			/* It is a valid path and no name collision */
   4626          					res = dir_register(&djn);		/* Register the new entry */
   4627          					if (res == FR_OK) {
   4628          						nf = fs->dirbuf[XDIR_NumSec]; nn = fs->dirbuf[XDIR_NumName];
   4629          						nh = ld_word(fs->dirbuf + XDIR_NameHash);
   4630          						mem_cpy(fs->dirbuf, buf, SZDIRE * 2);
   4631          						fs->dirbuf[XDIR_NumSec] = nf; fs->dirbuf[XDIR_NumName] = nn;
   4632          						st_word(fs->dirbuf + XDIR_NameHash, nh);
   4633          /* Start of critical section where any interruption can cause a cross-link */
   4634          						res = store_xdir(&djn);
   4635          					}
   4636          				}
   4637          			} else
   4638          #endif
   4639          			{	/* At FAT12/FAT16/FAT32 */
   4640          				mem_cpy(buf, djo.dir + DIR_Attr, 21);	/* Save information about the object except name */
   4641          				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
   4642          				res = follow_path(&djn, path_new);		/* Make sure if new object name is not in use */
   4643          				if (res == FR_OK) res = FR_EXIST;		/* Is new name already in use? */
   4644          				if (res == FR_NO_FILE) { 				/* It is a valid path and no name collision */
   4645          					res = dir_register(&djn);			/* Register the new entry */
   4646          					if (res == FR_OK) {
   4647          						dir = djn.dir;					/* Copy information about object except name */
   4648          						mem_cpy(dir + 13, buf + 2, 19);
   4649          						dir[DIR_Attr] = buf[0] | AM_ARC;
   4650          						fs->wflag = 1;
   4651          						if ((dir[DIR_Attr] & AM_DIR) && djo.obj.sclust != djn.obj.sclust) {	/* Update .. entry in the sub-directory if needed */
   4652          							dw = clust2sect(fs, ld_clust(fs, dir));
   4653          							if (!dw) {
   4654          								res = FR_INT_ERR;
   4655          							} else {
   4656          /* Start of critical section where any interruption can cause a cross-link */
   4657          								res = move_window(fs, dw);
   4658          								dir = fs->win + SZDIRE * 1;	/* Ptr to .. entry */
   4659          								if (res == FR_OK && dir[1] == '.') {
   4660          									st_clust(fs, dir, djn.obj.sclust);
   4661          									fs->wflag = 1;
   4662          								}
   4663          							}
   4664          						}
   4665          					}
   4666          				}
   4667          			}
   4668          			if (res == FR_OK) {
   4669          				res = dir_remove(&djo);		/* Remove old entry */
   4670          				if (res == FR_OK) {
   4671          					res = sync_fs(fs);
   4672          				}
   4673          			}
   4674          /* End of critical section */
   4675          		}
   4676          		FREE_NAMBUF();
   4677          	}
   4678          
   4679          	LEAVE_FF(fs, res);
   4680          }
   4681          
   4682          
   4683          
   4684          #endif /* !_FS_READONLY */
   4685          #endif /* _FS_MINIMIZE == 0 */
   4686          #endif /* _FS_MINIMIZE <= 1 */
   4687          #endif /* _FS_MINIMIZE <= 2 */
   4688          
   4689          
   4690          
   4691          #if _USE_CHMOD && !_FS_READONLY
   4692          /*-----------------------------------------------------------------------*/
   4693          /* Change Attribute                                                      */
   4694          /*-----------------------------------------------------------------------*/
   4695          
   4696          FRESULT f_chmod (
   4697          	const TCHAR* path,	/* Pointer to the file path */
   4698          	BYTE attr,			/* Attribute bits */
   4699          	BYTE mask			/* Attribute mask to change */
   4700          )
   4701          {
   4702          	FRESULT res;
   4703          	DIR dj;
   4704          	FATFS *fs;
   4705          	DEF_NAMBUF;
   4706          
   4707          
   4708          	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
   4709          	dj.obj.fs = fs;
   4710          	if (res == FR_OK) {
   4711          		INIT_NAMBUF(dj);
   4712          		res = follow_path(&dj, path);	/* Follow the file path */
   4713          		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
   4714          		if (res == FR_OK) {
   4715          			mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
   4716          #if _FS_EXFAT
   4717          			if (fs->fs_type == FS_EXFAT) {
   4718          				fs->dirbuf[XDIR_Attr] = (attr & mask) | (fs->dirbuf[XDIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   4719          				res = store_xdir(&dj);
   4720          			} else
   4721          #endif
   4722          			{
   4723          				dj.dir[DIR_Attr] = (attr & mask) | (dj.dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
   4724          				fs->wflag = 1;
   4725          			}
   4726          			res = sync_fs(fs);
   4727          		}
   4728          		FREE_NAMBUF();
   4729          	}
   4730          
   4731          	LEAVE_FF(fs, res);
   4732          }
   4733          
   4734          
   4735          
   4736          
   4737          /*-----------------------------------------------------------------------*/
   4738          /* Change Timestamp                                                      */
   4739          /*-----------------------------------------------------------------------*/
   4740          
   4741          FRESULT f_utime (
   4742          	const TCHAR* path,	/* Pointer to the file/directory name */
   4743          	const FILINFO* fno	/* Pointer to the time stamp to be set */
   4744          )
   4745          {
   4746          	FRESULT res;
   4747          	DIR dj;
   4748          	FATFS *fs;
   4749          	DEF_NAMBUF;
   4750          
   4751          
   4752          	res = find_volume(&path, &fs, FA_WRITE);	/* Get logical drive number */
   4753          	dj.obj.fs = fs;
   4754          	if (res == FR_OK) {
   4755          		INIT_NAMBUF(dj);
   4756          		res = follow_path(&dj, path);	/* Follow the file path */
   4757          		if (res == FR_OK && (dj.fn[NSFLAG] & (NS_DOT | NS_NONAME))) res = FR_INVALID_NAME;	/* Check object validity */
   4758          		if (res == FR_OK) {
   4759          #if _FS_EXFAT
   4760          			if (fs->fs_type == FS_EXFAT) {
   4761          				st_word(fs->dirbuf + XDIR_ModTime, fno->ftime);
   4762          				st_word(fs->dirbuf + XDIR_ModTime + 2, fno->fdate);
   4763          				res = store_xdir(&dj);
   4764          			} else
   4765          #endif
   4766          			{
   4767          				st_word(dj.dir + DIR_WrtTime, fno->ftime);
   4768          				st_word(dj.dir + DIR_WrtDate, fno->fdate);
   4769          				fs->wflag = 1;
   4770          			}
   4771          			if (res == FR_OK) res = sync_fs(fs);
   4772          		}
   4773          		FREE_NAMBUF();
   4774          	}
   4775          
   4776          	LEAVE_FF(fs, res);
   4777          }
   4778          
   4779          #endif	/* _USE_CHMOD && !_FS_READONLY */
   4780          
   4781          
   4782          
   4783          #if _USE_LABEL
   4784          /*-----------------------------------------------------------------------*/
   4785          /* Get Volume Label                                                      */
   4786          /*-----------------------------------------------------------------------*/
   4787          
   4788          FRESULT f_getlabel (
   4789          	const TCHAR* path,	/* Path name of the logical drive number */
   4790          	TCHAR* label,		/* Pointer to a buffer to return the volume label */
   4791          	DWORD* vsn			/* Pointer to a variable to return the volume serial number */
   4792          )
   4793          {
   4794          	FRESULT res;
   4795          	DIR dj;
   4796          	FATFS *fs;
   4797          	UINT si, di;
   4798          #if _LFN_UNICODE || _FS_EXFAT
   4799          	WCHAR w;
   4800          #endif
   4801          
   4802          	/* Get logical drive number */
   4803          	res = find_volume(&path, &fs, 0);
   4804          
   4805          	/* Get volume label */
   4806          	if (res == FR_OK && label) {
   4807          		dj.obj.fs = fs; dj.obj.sclust = 0;	/* Open root directory */
   4808          		res = dir_sdi(&dj, 0);
   4809          		if (res == FR_OK) {
   4810          		 	res = dir_read(&dj, 1);			/* Find a volume label entry */
   4811          		 	if (res == FR_OK) {
   4812          #if _FS_EXFAT
   4813          				if (fs->fs_type == FS_EXFAT) {
   4814          					for (si = di = 0; si < dj.dir[XDIR_NumLabel]; si++) {	/* Extract volume label from 83 entry */
   4815          						w = ld_word(dj.dir + XDIR_Label + si * 2);
   4816          #if _LFN_UNICODE
   4817          						label[di++] = w;
   4818          #else
   4819          						w = ff_convert(w, 0);	/* Unicode -> OEM */
   4820          						if (w == 0) w = '?';	/* Replace wrong character */
   4821          						if (_DF1S && w >= 0x100) label[di++] = (char)(w >> 8);
   4822          						label[di++] = (char)w;
   4823          #endif
   4824          					}
   4825          					label[di] = 0;
   4826          				} else
   4827          #endif
   4828          				{
   4829          					si = di = 0;		/* Extract volume label from AM_VOL entry with code comversion */
   4830          					do {
   4831          #if _LFN_UNICODE
   4832          						w = (si < 11) ? dj.dir[si++] : ' ';
   4833          						if (IsDBCS1(w) && si < 11 && IsDBCS2(dj.dir[si])) {
   4834          							w = w << 8 | dj.dir[si++];
   4835          						}
   4836          						label[di++] = ff_convert(w, 1);	/* OEM -> Unicode */
   4837          #else
   4838          						label[di++] = dj.dir[si++];
   4839          #endif
   4840          					} while (di < 11);
   4841          					do {				/* Truncate trailing spaces */
   4842          						label[di] = 0;
   4843          						if (di == 0) break;
   4844          					} while (label[--di] == ' ');
   4845          				}
   4846          			}
   4847          		}
   4848          		if (res == FR_NO_FILE) {	/* No label entry and return nul string */
   4849          			label[0] = 0;
   4850          			res = FR_OK;
   4851          		}
   4852          	}
   4853          
   4854          	/* Get volume serial number */
   4855          	if (res == FR_OK && vsn) {
   4856          		res = move_window(fs, fs->volbase);
   4857          		if (res == FR_OK) {
   4858          			switch (fs->fs_type) {
   4859          			case FS_EXFAT: di = BPB_VolIDEx; break;
   4860          			case FS_FAT32: di = BS_VolID32; break;
   4861          			default:       di = BS_VolID;
   4862          			}
   4863          			*vsn = ld_dword(&fs->win[di]);
   4864          		}
   4865          	}
   4866          
   4867          	LEAVE_FF(fs, res);
   4868          }
   4869          
   4870          
   4871          
   4872          #if !_FS_READONLY
   4873          /*-----------------------------------------------------------------------*/
   4874          /* Set Volume Label                                                      */
   4875          /*-----------------------------------------------------------------------*/
   4876          
   4877          FRESULT f_setlabel (
   4878          	const TCHAR* label	/* Pointer to the volume label to set */
   4879          )
   4880          {
   4881          	FRESULT res;
   4882          	DIR dj;
   4883          	FATFS *fs;
   4884          	BYTE dirvn[22];
   4885          	UINT i, j, slen;
   4886          	WCHAR w;
   4887          	static const char badchr[] = "\"*+,.:;<=>\?[]|\x7F";
   4888          
   4889          
   4890          	/* Get logical drive number */
   4891          	res = find_volume(&label, &fs, FA_WRITE);
   4892          	if (res != FR_OK) LEAVE_FF(fs, res);
   4893          	dj.obj.fs = fs;
   4894          
   4895          	/* Get length of given volume label */
   4896          	for (slen = 0; (UINT)label[slen] >= ' '; slen++) ;	/* Get name length */
   4897          
   4898          #if _FS_EXFAT
   4899          	if (fs->fs_type == FS_EXFAT) {	/* At the exFAT */
   4900          		for (i = j = 0; i < slen; ) {	/* Create volume label in directory form */
   4901          			w = label[i++];
   4902          #if !_LFN_UNICODE
   4903          			if (IsDBCS1(w)) {
   4904          				w = (i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   4905          			}
   4906          			w = ff_convert(w, 1);
   4907          #endif
   4908          			if (w == 0 || chk_chr(badchr, w) || j == 22) {	/* Check validity check validity of the volume label */
   4909          				LEAVE_FF(fs, FR_INVALID_NAME);
   4910          			}
   4911          			st_word(dirvn + j, w); j += 2;
   4912          		}
   4913          		slen = j;
   4914          	} else
   4915          #endif
   4916          	{	/* At the FAT12/16/32 */
   4917          		for ( ; slen && label[slen - 1] == ' '; slen--) ;	/* Remove trailing spaces */
   4918          		if (slen) {		/* Is there a volume label to be set? */
   4919          			dirvn[0] = 0; i = j = 0;	/* Create volume label in directory form */
   4920          			do {
   4921          #if _LFN_UNICODE
   4922          				w = ff_convert(ff_wtoupper(label[i++]), 0);
   4923          #else
   4924          				w = (BYTE)label[i++];
   4925          				if (IsDBCS1(w)) {
   4926          					w = (j < 10 && i < slen && IsDBCS2(label[i])) ? w << 8 | (BYTE)label[i++] : 0;
   4927          				}
   4928          #if _USE_LFN != 0
   4929          				w = ff_convert(ff_wtoupper(ff_convert(w, 1)), 0);
   4930          #else
   4931          				if (IsLower(w)) w -= 0x20;			/* To upper ASCII characters */
   4932          #ifdef _EXCVT
   4933          				if (w >= 0x80) w = ExCvt[w - 0x80];	/* To upper extended characters (SBCS cfg) */
   4934          #else
   4935          				if (!_DF1S && w >= 0x80) w = 0;		/* Reject extended characters (ASCII cfg) */
   4936          #endif
   4937          #endif
   4938          #endif
   4939          				if (w == 0 || chk_chr(badchr, w) || j >= (UINT)((w >= 0x100) ? 10 : 11)) {	/* Reject invalid characters for volume label */
   4940          					LEAVE_FF(fs, FR_INVALID_NAME);
   4941          				}
   4942          				if (w >= 0x100) dirvn[j++] = (BYTE)(w >> 8);
   4943          				dirvn[j++] = (BYTE)w;
   4944          			} while (i < slen);
   4945          			while (j < 11) dirvn[j++] = ' ';	/* Fill remaining name field */
   4946          			if (dirvn[0] == DDEM) LEAVE_FF(fs, FR_INVALID_NAME);	/* Reject illegal name (heading DDEM) */
   4947          		}
   4948          	}
   4949          
   4950          	/* Set volume label */
   4951          	dj.obj.sclust = 0;		/* Open root directory */
   4952          	res = dir_sdi(&dj, 0);
   4953          	if (res == FR_OK) {
   4954          		res = dir_read(&dj, 1);	/* Get volume label entry */
   4955          		if (res == FR_OK) {
   4956          			if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
   4957          				dj.dir[XDIR_NumLabel] = slen / 2;	/* Change the volume label */
   4958          				mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
   4959          			} else {
   4960          				if (slen) {
   4961          					mem_cpy(dj.dir, dirvn, 11);	/* Change the volume label */
   4962          				} else {
   4963          					dj.dir[DIR_Name] = DDEM;	/* Remove the volume label */
   4964          				}
   4965          			}
   4966          			fs->wflag = 1;
   4967          			res = sync_fs(fs);
   4968          		} else {			/* No volume label entry is found or error */
   4969          			if (res == FR_NO_FILE) {
   4970          				res = FR_OK;
   4971          				if (slen) {	/* Create a volume label entry */
   4972          					res = dir_alloc(&dj, 1);	/* Allocate an entry */
   4973          					if (res == FR_OK) {
   4974          						mem_set(dj.dir, 0, SZDIRE);	/* Clear the entry */
   4975          						if (_FS_EXFAT && fs->fs_type == FS_EXFAT) {
   4976          							dj.dir[XDIR_Type] = 0x83;		/* Create 83 entry */
   4977          							dj.dir[XDIR_NumLabel] = slen / 2;
   4978          							mem_cpy(dj.dir + XDIR_Label, dirvn, slen);
   4979          						} else {
   4980          							dj.dir[DIR_Attr] = AM_VOL;		/* Create volume label entry */
   4981          							mem_cpy(dj.dir, dirvn, 11);
   4982          						}
   4983          						fs->wflag = 1;
   4984          						res = sync_fs(fs);
   4985          					}
   4986          				}
   4987          			}
   4988          		}
   4989          	}
   4990          
   4991          	LEAVE_FF(fs, res);
   4992          }
   4993          
   4994          #endif /* !_FS_READONLY */
   4995          #endif /* _USE_LABEL */
   4996          
   4997          
   4998          
   4999          #if _USE_EXPAND && !_FS_READONLY
   5000          /*-----------------------------------------------------------------------*/
   5001          /* Allocate a Contiguous Blocks to the File                              */
   5002          /*-----------------------------------------------------------------------*/
   5003          
   5004          FRESULT f_expand (
   5005          	FIL* fp,		/* Pointer to the file object */
   5006          	FSIZE_t fsz,	/* File size to be expanded to */
   5007          	BYTE opt		/* Operation mode 0:Find and prepare or 1:Find and allocate */
   5008          )
   5009          {
   5010          	FRESULT res;
   5011          	FATFS *fs;
   5012          	DWORD val, clst, csz, stcl, scl, ncl, tcl;
   5013          
   5014          
   5015          	res = validate(fp, &fs);		/* Check validity of the object */
   5016          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   5017          	if (fsz == 0 || fp->obj.objsize != 0 || !(fp->flag & FA_WRITE)) LEAVE_FF(fs, FR_DENIED);
   5018          #if _FS_EXFAT
   5019          	if (fs->fs_type != FS_EXFAT && fsz >= 0x100000000) LEAVE_FF(fs, FR_DENIED);	/* Check if in size limit */
   5020          #endif
   5021          	csz = (DWORD)fs->csize * SS(fs);	/* Cluster size */
   5022          	tcl = (DWORD)(fsz / csz) + ((fsz & (csz - 1)) ? 1 : 0);	/* Number of clusters required */
   5023          	stcl = fs->last_clst;
   5024          	if (stcl < 2 || stcl >= fs->n_fatent) stcl = 2;
   5025          
   5026          #if _FS_EXFAT
   5027          	if (fs->fs_type == FS_EXFAT) {
   5028          		scl = find_bitmap(fs, stcl, tcl);			/* Find a contiguous cluster block */
   5029          		if (scl == 0) res = FR_DENIED;				/* No contiguous cluster block was found */
   5030          		if (scl == 1) res = FR_INT_ERR;
   5031          		if (scl == 0xFFFFFFFF) res = FR_DISK_ERR;
   5032          		if (res == FR_OK) {
   5033          			if (opt) {
   5034          				res = change_bitmap(fs, scl, tcl, 1);	/* Mark the cluster block 'in use' */
   5035          				fs->last_clst = scl + tcl - 1;
   5036          			} else {
   5037          				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
   5038          			}
   5039          		}
   5040          	} else
   5041          #endif
   5042          	{
   5043          		scl = clst = stcl; ncl = 0;
   5044          		for (;;) {	/* Find a contiguous cluster block */
   5045          			val = get_fat(&fp->obj, clst);
   5046          			if (++clst >= fs->n_fatent) clst = 2;
   5047          			if (val == 1) { res = FR_INT_ERR; break; }
   5048          			if (val == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
   5049          			if (val == 0) {	/* Is it a free cluster? */
   5050          				if (++ncl == tcl) break;	/* Break if a contiguous cluster block was found */
   5051          			} else {
   5052          				scl = clst; ncl = 0;		/* Not a free cluster */
   5053          			}
   5054          			if (clst == stcl) { res = FR_DENIED; break; }	/* All cluster scanned? */
   5055          		}
   5056          		if (res == FR_OK) {
   5057          			if (opt) {
   5058          				for (clst = scl; tcl; clst++, tcl--) {	/* Create a cluster chain on the FAT */
   5059          					val = (tcl == 1) ? 0xFFFFFFFF : clst + 1;
   5060          					res = put_fat(fs, clst, val);
   5061          					if (res != FR_OK) break;
   5062          					fs->last_clst = clst;
   5063          				}
   5064          			} else {
   5065          				fs->last_clst = scl - 1;				/* Set suggested cluster to start next */
   5066          			}
   5067          		}
   5068          	}
   5069          
   5070          	if (opt && res == FR_OK) {
   5071          		fp->obj.sclust = scl;		/* Update allocation information */
   5072          		fp->obj.objsize = fsz;
   5073          		if (_FS_EXFAT) fp->obj.stat = 2;
   5074          		fp->flag |= _FA_MODIFIED;
   5075          	}
   5076          
   5077          	LEAVE_FF(fs, res);
   5078          }
   5079          
   5080          #endif /* _USE_EXPAND && !_FS_READONLY */
   5081          
   5082          
   5083          
   5084          /*-----------------------------------------------------------------------*/
   5085          /* Forward data to the stream directly (available on only tiny cfg)      */
   5086          /*-----------------------------------------------------------------------*/
   5087          #if _USE_FORWARD && _FS_TINY
   5088          
   5089          FRESULT f_forward (
   5090          	FIL* fp, 						/* Pointer to the file object */
   5091          	UINT (*func)(const BYTE*,UINT),	/* Pointer to the streaming function */
   5092          	UINT btf,						/* Number of bytes to forward */
   5093          	UINT* bf						/* Pointer to number of bytes forwarded */
   5094          )
   5095          {
   5096          	FRESULT res;
   5097          	FATFS *fs;
   5098          	DWORD clst, sect;
   5099          	FSIZE_t remain;
   5100          	UINT rcnt, csect;
   5101          
   5102          
   5103          	*bf = 0;	/* Clear transfer byte counter */
   5104          	res = validate(fp, &fs);		/* Check validity of the object */
   5105          	if (res != FR_OK || (res = (FRESULT)fp->err) != FR_OK) LEAVE_FF(fs, res);	/* Check validity */
   5106          	if (!(fp->flag & FA_READ)) LEAVE_FF(fs, FR_DENIED);	/* Check access mode */
   5107          
   5108          	remain = fp->fsize - fp->fptr;
   5109          	if (btf > remain) btf = (UINT)remain;			/* Truncate btf by remaining bytes */
   5110          
   5111          	for ( ;  btf && (*func)(0, 0);					/* Repeat until all data transferred or stream becomes busy */
   5112          		fp->fptr += rcnt, *bf += rcnt, btf -= rcnt) {
   5113          		csect = (UINT)(fp->fptr / SS(fs) & (fs->csize - 1));	/* Sector offset in the cluster */
   5114          		if ((fp->fptr % SS(fs)) == 0) {				/* On the sector boundary? */
   5115          			if (csect == 0) {						/* On the cluster boundary? */
   5116          				clst = (fp->fptr == 0) ?			/* On the top of the file? */
   5117          					fp->sclust : get_fat(fs, fp->clust);
   5118          				if (clst <= 1) ABORT(fs, FR_INT_ERR);
   5119          				if (clst == 0xFFFFFFFF) ABORT(fs, FR_DISK_ERR);
   5120          				fp->clust = clst;					/* Update current cluster */
   5121          			}
   5122          		}
   5123          		sect = clust2sect(fs, fp->clust);			/* Get current data sector */
   5124          		if (!sect) ABORT(fs, FR_INT_ERR);
   5125          		sect += csect;
   5126          		if (move_window(fs, sect) != FR_OK) {		/* Move sector window */
   5127          			ABORT(fs, FR_DISK_ERR);
   5128          		}
   5129          		fp->sect = sect;
   5130          		rcnt = SS(fs) - (WORD)(fp->fptr % SS(fs));	/* Forward data from sector window */
   5131          		if (rcnt > btf) rcnt = btf;
   5132          		rcnt = (*func)(&fs->win[(WORD)fp->fptr % SS(fs)], rcnt);
   5133          		if (!rcnt) ABORT(fs, FR_INT_ERR);
   5134          	}
   5135          
   5136          	LEAVE_FF(fs, FR_OK);
   5137          }
   5138          #endif /* _USE_FORWARD */
   5139          
   5140          
   5141          
   5142          #if _USE_MKFS && !_FS_READONLY
   5143          /*-----------------------------------------------------------------------*/
   5144          /* Create file system on the logical drive                               */
   5145          /*-----------------------------------------------------------------------*/
   5146          #define N_ROOTDIR	512		/* Number of root directory entries for FAT12/16 */
   5147          #define N_FATS		1		/* Number of FATs (1 or 2) */
   5148          
   5149          
   5150          FRESULT f_mkfs (
   5151          	const TCHAR* path,	/* Logical drive number */
   5152          	BYTE sfd,			/* Partitioning rule 0:FDISK, 1:SFD */
   5153          	UINT au				/* Size of allocation unit in unit of byte or sector */
   5154          )
   5155          {
   5156          	static const WORD vst[] = { 1024,   512,  256,  128,   64,    32,   16,    8,    4,    2,   0};
   5157          	static const WORD cst[] = {32768, 16384, 8192, 4096, 2048, 16384, 8192, 4096, 2048, 1024, 512};
   5158          	int vol;
   5159          	BYTE fmt, md, sys, *tbl, pdrv, part;
   5160          	DWORD n_clst, vs, n, wsect;
   5161          	UINT i;
   5162          	DWORD b_vol, b_fat, b_dir, b_data;	/* LBA */
   5163          	DWORD n_vol, n_rsv, n_fat, n_dir;	/* Size */
   5164          	FATFS *fs;
   5165          	DSTATUS stat;
   5166          #if _USE_TRIM
   5167          	DWORD eb[2];
   5168          #endif
   5169          
   5170          
   5171          	/* Check mounted drive and clear work area */
   5172          	if (sfd > 1) return FR_INVALID_PARAMETER;
   5173          	vol = get_ldnumber(&path);				/* Get target volume */
   5174          	if (vol < 0) return FR_INVALID_DRIVE;
   5175          	fs = FatFs[vol];						/* Check if the volume has work area */
   5176          	if (!fs) return FR_NOT_ENABLED;
   5177          	fs->fs_type = 0;
   5178          	pdrv = LD2PD(vol);	/* Physical drive */
   5179          	part = LD2PT(vol);	/* Partition (0:auto detect, 1-4:get from partition table)*/
   5180          
   5181          	/* Get disk statics */
   5182          	stat = disk_initialize(pdrv);
   5183          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5184          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5185          #if _MAX_SS != _MIN_SS		/* Get disk sector size */
   5186          	if (disk_ioctl(pdrv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK || SS(fs) > _MAX_SS || SS(fs) < _MIN_SS) {
   5187          		return FR_DISK_ERR;
   5188          	}
   5189          #endif
   5190          	if (_MULTI_PARTITION && part) {
   5191          		/* Get partition information from partition table in the MBR */
   5192          		if (disk_read(pdrv, fs->win, 0, 1) != RES_OK) return FR_DISK_ERR;
   5193          		if (ld_word(fs->win + BS_55AA) != 0xAA55) return FR_MKFS_ABORTED;
   5194          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5195          		if (!tbl[4]) return FR_MKFS_ABORTED;	/* No partition? */
   5196          		b_vol = ld_dword(tbl + 8);	/* Volume start sector */
   5197          		n_vol = ld_dword(tbl + 12);	/* Volume size */
   5198          	} else {
   5199          		/* Create a single-partition in this function */
   5200          		if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &n_vol) != RES_OK || n_vol < 128) {
   5201          			return FR_DISK_ERR;
   5202          		}
   5203          		b_vol = (sfd) ? 0 : 63;		/* Volume start sector */
   5204          		n_vol -= b_vol;				/* Volume size */
   5205          	}
   5206          
   5207          	if (au & (au - 1)) au = 0;
   5208          	if (!au) {						/* AU auto selection */
   5209          		vs = n_vol / (2000 / (SS(fs) / 512));
   5210          		for (i = 0; vs < vst[i]; i++) ;
   5211          		au = cst[i];
   5212          	}
   5213          	if (au >= _MIN_SS) au /= SS(fs);	/* Number of sectors per cluster */
   5214          	if (!au) au = 1;
   5215          	if (au > 128) au = 128;
   5216          
   5217          	/* Pre-compute number of clusters and FAT sub-type */
   5218          	n_clst = n_vol / au;
   5219          	fmt = FS_FAT12;
   5220          	if (n_clst >= MIN_FAT16) fmt = FS_FAT16;
   5221          	if (n_clst >= MIN_FAT32) fmt = FS_FAT32;
   5222          
   5223          	/* Determine offset and size of FAT structure */
   5224          	if (fmt == FS_FAT32) {
   5225          		n_fat = ((n_clst * 4) + 8 + SS(fs) - 1) / SS(fs);
   5226          		n_rsv = 32;
   5227          		n_dir = 0;
   5228          	} else {
   5229          		n_fat = (fmt == FS_FAT12) ? (n_clst * 3 + 1) / 2 + 3 : (n_clst * 2) + 4;
   5230          		n_fat = (n_fat + SS(fs) - 1) / SS(fs);
   5231          		n_rsv = 1;
   5232          		n_dir = (DWORD)N_ROOTDIR * SZDIRE / SS(fs);
   5233          	}
   5234          	b_fat = b_vol + n_rsv;				/* FAT area start sector */
   5235          	b_dir = b_fat + n_fat * N_FATS;		/* Directory area start sector */
   5236          	b_data = b_dir + n_dir;				/* Data area start sector */
   5237          	if (n_vol < b_data + au - b_vol) return FR_MKFS_ABORTED;	/* Too small volume */
   5238          
   5239          	/* Align data start sector to erase block boundary (for flash memory media) */
   5240          	if (disk_ioctl(pdrv, GET_BLOCK_SIZE, &n) != RES_OK || !n || n > 32768) n = 1;
   5241          	n = (b_data + n - 1) & ~(n - 1);	/* Next nearest erase block from current data start */
   5242          	n = (n - b_data) / N_FATS;
   5243          	if (fmt == FS_FAT32) {		/* FAT32: Move FAT offset */
   5244          		n_rsv += n;
   5245          		b_fat += n;
   5246          	} else {					/* FAT12/16: Expand FAT size */
   5247          		n_fat += n;
   5248          	}
   5249          
   5250          	/* Determine number of clusters and final check of validity of the FAT sub-type */
   5251          	n_clst = (n_vol - n_rsv - n_fat * N_FATS - n_dir) / au;
   5252          	if (   (fmt == FS_FAT16 && n_clst < MIN_FAT16)
   5253          		|| (fmt == FS_FAT32 && n_clst < MIN_FAT32)) {
   5254          		return FR_MKFS_ABORTED;
   5255          	}
   5256          
   5257          	/* Determine system ID in the partition table */
   5258          	if (fmt == FS_FAT32) {
   5259          		sys = 0x0C;		/* FAT32X */
   5260          	} else {
   5261          		if (fmt == FS_FAT12 && n_vol < 0x10000) {
   5262          			sys = 0x01;	/* FAT12(<65536) */
   5263          		} else {
   5264          			sys = (n_vol < 0x10000) ? 0x04 : 0x06;	/* FAT16(<65536) : FAT12/16(>=65536) */
   5265          		}
   5266          	}
   5267          
   5268          	if (_MULTI_PARTITION && part) {
   5269          		/* Update system ID in the partition table */
   5270          		tbl = &fs->win[MBR_Table + (part - 1) * SZ_PTE];
   5271          		tbl[4] = sys;
   5272          		if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to teh MBR */
   5273          			return FR_DISK_ERR;
   5274          		}
   5275          		md = 0xF8;
   5276          	} else {
   5277          		if (sfd) {	/* No partition table (SFD) */
   5278          			md = 0xF0;
   5279          		} else {	/* Create partition table (FDISK) */
   5280          			mem_set(fs->win, 0, SS(fs));
   5281          			tbl = fs->win + MBR_Table;	/* Create partition table for single partition in the drive */
   5282          			tbl[1] = 1;						/* Partition start head */
   5283          			tbl[2] = 1;						/* Partition start sector */
   5284          			tbl[3] = 0;						/* Partition start cylinder */
   5285          			tbl[4] = sys;					/* System type */
   5286          			tbl[5] = 254;					/* Partition end head */
   5287          			n = (b_vol + n_vol) / 63 / 255;
   5288          			tbl[6] = (BYTE)(n >> 2 | 63);	/* Partition end sector */
   5289          			tbl[7] = (BYTE)n;				/* End cylinder */
   5290          			st_dword(tbl + 8, 63);			/* Partition start in LBA */
   5291          			st_dword(tbl + 12, n_vol);		/* Partition size in LBA */
   5292          			st_word(fs->win + BS_55AA, 0xAA55);	/* MBR signature */
   5293          			if (disk_write(pdrv, fs->win, 0, 1) != RES_OK) {	/* Write it to the MBR */
   5294          				return FR_DISK_ERR;
   5295          			}
   5296          			md = 0xF8;
   5297          		}
   5298          	}
   5299          
   5300          	/* Create BPB in the VBR */
   5301          	tbl = fs->win;							/* Clear sector */
   5302          	mem_set(tbl, 0, SS(fs));
   5303          	mem_cpy(tbl, "\xEB\xFE\x90" "MSDOS5.0", 11);/* Boot jump code, OEM name */
   5304          	i = SS(fs);								/* Sector size */
   5305          	st_word(tbl + BPB_BytsPerSec, (WORD)i);
   5306          	tbl[BPB_SecPerClus] = (BYTE)au;			/* Sectors per cluster */
   5307          	st_word(tbl + BPB_RsvdSecCnt, (WORD)n_rsv);	/* Reserved sectors */
   5308          	tbl[BPB_NumFATs] = N_FATS;				/* Number of FATs */
   5309          	i = (fmt == FS_FAT32) ? 0 : N_ROOTDIR;	/* Number of root directory entries */
   5310          	st_word(tbl + BPB_RootEntCnt, (WORD)i);
   5311          	if (n_vol < 0x10000) {					/* Number of total sectors */
   5312          		st_word(tbl + BPB_TotSec16, (WORD)n_vol);
   5313          	} else {
   5314          		st_dword(tbl + BPB_TotSec32, (WORD)n_vol);
   5315          	}
   5316          	tbl[BPB_Media] = md;					/* Media descriptor */
   5317          	st_word(tbl + BPB_SecPerTrk, 63);		/* Number of sectors per track */
   5318          	st_word(tbl + BPB_NumHeads, 255);		/* Number of heads */
   5319          	st_dword(tbl + BPB_HiddSec, b_vol);		/* Volume offset */
   5320          	n = GET_FATTIME();						/* Use current time as VSN */
   5321          	if (fmt == FS_FAT32) {
   5322          		st_dword(tbl + BS_VolID32, n);		/* VSN */
   5323          		st_dword(tbl + BPB_FATSz32, n_fat);	/* Number of sectors per FAT */
   5324          		st_dword(tbl + BPB_RootClus32, 2);	/* Root directory start cluster (2) */
   5325          		st_word(tbl + BPB_FSInfo32, 1);		/* FSINFO record offset (VBR + 1) */
   5326          		st_word(tbl + BPB_BkBootSec32, 6);	/* Backup boot record offset (VBR + 6) */
   5327          		tbl[BS_DrvNum32] = 0x80;			/* Drive number */
   5328          		tbl[BS_BootSig32] = 0x29;			/* Extended boot signature */
   5329          		mem_cpy(tbl + BS_VolLab32, "NO NAME    " "FAT32   ", 19);	/* Volume label, FAT signature */
   5330          	} else {
   5331          		st_dword(tbl + BS_VolID, n);		/* VSN */
   5332          		st_word(tbl + BPB_FATSz16, (WORD)n_fat);	/* Number of sectors per FAT */
   5333          		tbl[BS_DrvNum] = 0x80;				/* Drive number */
   5334          		tbl[BS_BootSig] = 0x29;				/* Extended boot signature */
   5335          		mem_cpy(tbl + BS_VolLab, "NO NAME    " "FAT     ", 19);	/* Volume label, FAT signature */
   5336          	}
   5337          	st_word(tbl + BS_55AA, 0xAA55);			/* Signature (Offset is fixed here regardless of sector size) */
   5338          	if (disk_write(pdrv, tbl, b_vol, 1) != RES_OK) {	/* Write it to the VBR sector */
   5339          		return FR_DISK_ERR;
   5340          	}
   5341          	if (fmt == FS_FAT32) {					/* Write it to the backup VBR if needed (VBR + 6) */
   5342          		disk_write(pdrv, tbl, b_vol + 6, 1);
   5343          	}
   5344          
   5345          	/* Initialize FAT area */
   5346          	wsect = b_fat;
   5347          	for (i = 0; i < N_FATS; i++) {		/* Initialize each FAT copy */
   5348          		mem_set(tbl, 0, SS(fs));			/* 1st sector of the FAT  */
   5349          		n = md;								/* Media descriptor byte */
   5350          		if (fmt != FS_FAT32) {
   5351          			n |= (fmt == FS_FAT12) ? 0x00FFFF00 : 0xFFFFFF00;
   5352          			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT12/16) */
   5353          		} else {
   5354          			n |= 0xFFFFFF00;
   5355          			st_dword(tbl + 0, n);			/* Reserve cluster #0-1 (FAT32) */
   5356          			st_dword(tbl + 4, 0xFFFFFFFF);
   5357          			st_dword(tbl + 8, 0x0FFFFFFF);	/* Reserve cluster #2 for root directory */
   5358          		}
   5359          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5360          			return FR_DISK_ERR;
   5361          		}
   5362          		mem_set(tbl, 0, SS(fs));			/* Fill following FAT entries with zero */
   5363          		for (n = 1; n < n_fat; n++) {		/* This loop may take a time on FAT32 volume due to many single sector writes */
   5364          			if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5365          				return FR_DISK_ERR;
   5366          			}
   5367          		}
   5368          	}
   5369          
   5370          	/* Initialize root directory */
   5371          	i = (fmt == FS_FAT32) ? au : (UINT)n_dir;
   5372          	do {
   5373          		if (disk_write(pdrv, tbl, wsect++, 1) != RES_OK) {
   5374          			return FR_DISK_ERR;
   5375          		}
   5376          	} while (--i);
   5377          
   5378          #if _USE_TRIM	/* Erase data area if needed */
   5379          	{
   5380          		eb[0] = wsect; eb[1] = wsect + (n_clst - ((fmt == FS_FAT32) ? 1 : 0)) * au - 1;
   5381          		disk_ioctl(pdrv, CTRL_TRIM, eb);
   5382          	}
   5383          #endif
   5384          
   5385          	/* Create FSINFO if needed */
   5386          	if (fmt == FS_FAT32) {
   5387          		st_dword(tbl + FSI_LeadSig, 0x41615252);
   5388          		st_dword(tbl + FSI_StrucSig, 0x61417272);
   5389          		st_dword(tbl + FSI_Free_Count, n_clst - 1);	/* Number of free clusters */
   5390          		st_dword(tbl + FSI_Nxt_Free, 2);			/* Last allocated cluster# */
   5391          		st_word(tbl + BS_55AA, 0xAA55);
   5392          		disk_write(pdrv, tbl, b_vol + 1, 1);	/* Write original (VBR + 1) */
   5393          		disk_write(pdrv, tbl, b_vol + 7, 1);	/* Write backup (VBR + 7) */
   5394          	}
   5395          
   5396          	return (disk_ioctl(pdrv, CTRL_SYNC, 0) == RES_OK) ? FR_OK : FR_DISK_ERR;
   5397          }
   5398          
   5399          
   5400          
   5401          #if _MULTI_PARTITION
   5402          /*-----------------------------------------------------------------------*/
   5403          /* Create partition table on the physical drive                          */
   5404          /*-----------------------------------------------------------------------*/
   5405          
   5406          FRESULT f_fdisk (
   5407          	BYTE pdrv,			/* Physical drive number */
   5408          	const DWORD szt[],	/* Pointer to the size table for each partitions */
   5409          	void* work			/* Pointer to the working buffer */
   5410          )
   5411          {
   5412          	UINT i, n, sz_cyl, tot_cyl, b_cyl, e_cyl, p_cyl;
   5413          	BYTE s_hd, e_hd, *p, *buf = (BYTE*)work;
   5414          	DSTATUS stat;
   5415          	DWORD sz_disk, sz_part, s_part;
   5416          
   5417          
   5418          	stat = disk_initialize(pdrv);
   5419          	if (stat & STA_NOINIT) return FR_NOT_READY;
   5420          	if (stat & STA_PROTECT) return FR_WRITE_PROTECTED;
   5421          	if (disk_ioctl(pdrv, GET_SECTOR_COUNT, &sz_disk)) return FR_DISK_ERR;
   5422          
   5423          	/* Determine CHS in the table regardless of the drive geometry */
   5424          	for (n = 16; n < 256 && sz_disk / n / 63 > 1024; n *= 2) ;
   5425          	if (n == 256) n--;
   5426          	e_hd = n - 1;
   5427          	sz_cyl = 63 * n;
   5428          	tot_cyl = sz_disk / sz_cyl;
   5429          
   5430          	/* Create partition table */
   5431          	mem_set(buf, 0, _MAX_SS);
   5432          	p = buf + MBR_Table; b_cyl = 0;
   5433          	for (i = 0; i < 4; i++, p += SZ_PTE) {
   5434          		p_cyl = (szt[i] <= 100U) ? (DWORD)tot_cyl * szt[i] / 100 : szt[i] / sz_cyl;
   5435          		if (!p_cyl) continue;
   5436          		s_part = (DWORD)sz_cyl * b_cyl;
   5437          		sz_part = (DWORD)sz_cyl * p_cyl;
   5438          		if (i == 0) {	/* Exclude first track of cylinder 0 */
   5439          			s_hd = 1;
   5440          			s_part += 63; sz_part -= 63;
   5441          		} else {
   5442          			s_hd = 0;
   5443          		}
   5444          		e_cyl = b_cyl + p_cyl - 1;
   5445          		if (e_cyl >= tot_cyl) return FR_INVALID_PARAMETER;
   5446          
   5447          		/* Set partition table */
   5448          		p[1] = s_hd;						/* Start head */
   5449          		p[2] = (BYTE)((b_cyl >> 2) + 1);	/* Start sector */
   5450          		p[3] = (BYTE)b_cyl;					/* Start cylinder */
   5451          		p[4] = 0x06;						/* System type (temporary setting) */
   5452          		p[5] = e_hd;						/* End head */
   5453          		p[6] = (BYTE)((e_cyl >> 2) + 63);	/* End sector */
   5454          		p[7] = (BYTE)e_cyl;					/* End cylinder */
   5455          		st_dword(p + 8, s_part);			/* Start sector in LBA */
   5456          		st_dword(p + 12, sz_part);			/* Partition size */
   5457          
   5458          		/* Next partition */
   5459          		b_cyl += p_cyl;
   5460          	}
   5461          	st_word(p, 0xAA55);
   5462          
   5463          	/* Write it to the MBR */
   5464          	return (disk_write(pdrv, buf, 0, 1) != RES_OK || disk_ioctl(pdrv, CTRL_SYNC, 0) != RES_OK) ? FR_DISK_ERR : FR_OK;
   5465          }
   5466          
   5467          
   5468          #endif /* _MULTI_PARTITION */
   5469          #endif /* _USE_MKFS && !_FS_READONLY */
   5470          
   5471          
   5472          
   5473          
   5474          #if _USE_STRFUNC
   5475          /*-----------------------------------------------------------------------*/
   5476          /* Get a string from the file                                            */
   5477          /*-----------------------------------------------------------------------*/
   5478          
   5479          TCHAR* f_gets (
   5480          	TCHAR* buff,	/* Pointer to the string buffer to read */
   5481          	int len,		/* Size of string buffer (characters) */
   5482          	FIL* fp			/* Pointer to the file object */
   5483          )
   5484          {
   5485          	int n = 0;
   5486          	TCHAR c, *p = buff;
   5487          	BYTE s[2];
   5488          	UINT rc;
   5489          
   5490          
   5491          	while (n < len - 1) {	/* Read characters until buffer gets filled */
   5492          #if _LFN_UNICODE
   5493          #if _STRF_ENCODE == 3		/* Read a character in UTF-8 */
   5494          		f_read(fp, s, 1, &rc);
   5495          		if (rc != 1) break;
   5496          		c = s[0];
   5497          		if (c >= 0x80) {
   5498          			if (c < 0xC0) continue;	/* Skip stray trailer */
   5499          			if (c < 0xE0) {			/* Two-byte sequence */
   5500          				f_read(fp, s, 1, &rc);
   5501          				if (rc != 1) break;
   5502          				c = (c & 0x1F) << 6 | (s[0] & 0x3F);
   5503          				if (c < 0x80) c = '?';
   5504          			} else {
   5505          				if (c < 0xF0) {		/* Three-byte sequence */
   5506          					f_read(fp, s, 2, &rc);
   5507          					if (rc != 2) break;
   5508          					c = c << 12 | (s[0] & 0x3F) << 6 | (s[1] & 0x3F);
   5509          					if (c < 0x800) c = '?';
   5510          				} else {			/* Reject four-byte sequence */
   5511          					c = '?';
   5512          				}
   5513          			}
   5514          		}
   5515          #elif _STRF_ENCODE == 2		/* Read a character in UTF-16BE */
   5516          		f_read(fp, s, 2, &rc);
   5517          		if (rc != 2) break;
   5518          		c = s[1] + (s[0] << 8);
   5519          #elif _STRF_ENCODE == 1		/* Read a character in UTF-16LE */
   5520          		f_read(fp, s, 2, &rc);
   5521          		if (rc != 2) break;
   5522          		c = s[0] + (s[1] << 8);
   5523          #else						/* Read a character in ANSI/OEM */
   5524          		f_read(fp, s, 1, &rc);
   5525          		if (rc != 1) break;
   5526          		c = s[0];
   5527          		if (IsDBCS1(c)) {
   5528          			f_read(fp, s, 1, &rc);
   5529          			if (rc != 1) break;
   5530          			c = (c << 8) + s[0];
   5531          		}
   5532          		c = ff_convert(c, 1);	/* OEM -> Unicode */
   5533          		if (!c) c = '?';
   5534          #endif
   5535          #else						/* Read a character without conversion */
   5536          		f_read(fp, s, 1, &rc);
   5537          		if (rc != 1) break;
   5538          		c = s[0];
   5539          #endif
   5540          		if (_USE_STRFUNC == 2 && c == '\r') continue;	/* Strip '\r' */
   5541          		*p++ = c;
   5542          		n++;
   5543          		if (c == '\n') break;		/* Break on EOL */
   5544          	}
   5545          	*p = 0;
   5546          	return n ? buff : 0;			/* When no data read (eof or error), return with error. */
   5547          }
   5548          
   5549          
   5550          
   5551          
   5552          #if !_FS_READONLY
   5553          #include <stdarg.h>
   5554          /*-----------------------------------------------------------------------*/
   5555          /* Put a character to the file                                           */
   5556          /*-----------------------------------------------------------------------*/
   5557          
   5558          typedef struct {
   5559          	FIL* fp;
   5560          	int idx, nchr;
   5561          	BYTE buf[64];
   5562          } putbuff;
   5563          
   5564          
   5565          static
   5566          void putc_bfd (
   5567          	putbuff* pb,
   5568          	TCHAR c
   5569          )
   5570          {
   5571          	UINT bw;
   5572          	int i;
   5573          
   5574          
   5575          	if (_USE_STRFUNC == 2 && c == '\n') {	 /* LF -> CRLF conversion */
   5576          		putc_bfd(pb, '\r');
   5577          	}
   5578          
   5579          	i = pb->idx;	/* Buffer write index (-1:error) */
   5580          	if (i < 0) return;
   5581          
   5582          #if _LFN_UNICODE
   5583          #if _STRF_ENCODE == 3			/* Write a character in UTF-8 */
   5584          	if (c < 0x80) {				/* 7-bit */
   5585          		pb->buf[i++] = (BYTE)c;
   5586          	} else {
   5587          		if (c < 0x800) {		/* 11-bit */
   5588          			pb->buf[i++] = (BYTE)(0xC0 | c >> 6);
   5589          		} else {				/* 16-bit */
   5590          			pb->buf[i++] = (BYTE)(0xE0 | c >> 12);
   5591          			pb->buf[i++] = (BYTE)(0x80 | (c >> 6 & 0x3F));
   5592          		}
   5593          		pb->buf[i++] = (BYTE)(0x80 | (c & 0x3F));
   5594          	}
   5595          #elif _STRF_ENCODE == 2			/* Write a character in UTF-16BE */
   5596          	pb->buf[i++] = (BYTE)(c >> 8);
   5597          	pb->buf[i++] = (BYTE)c;
   5598          #elif _STRF_ENCODE == 1			/* Write a character in UTF-16LE */
   5599          	pb->buf[i++] = (BYTE)c;
   5600          	pb->buf[i++] = (BYTE)(c >> 8);
   5601          #else							/* Write a character in ANSI/OEM */
   5602          	c = ff_convert(c, 0);	/* Unicode -> OEM */
   5603          	if (!c) c = '?';
   5604          	if (c >= 0x100)
   5605          		pb->buf[i++] = (BYTE)(c >> 8);
   5606          	pb->buf[i++] = (BYTE)c;
   5607          #endif
   5608          #else							/* Write a character without conversion */
   5609          	pb->buf[i++] = (BYTE)c;
   5610          #endif
   5611          
   5612          	if (i >= (int)(sizeof pb->buf) - 3) {	/* Write buffered characters to the file */
   5613          		f_write(pb->fp, pb->buf, (UINT)i, &bw);
   5614          		i = (bw == (UINT)i) ? 0 : -1;
   5615          	}
   5616          	pb->idx = i;
   5617          	pb->nchr++;
   5618          }
   5619          
   5620          
   5621          
   5622          int f_putc (
   5623          	TCHAR c,	/* A character to be output */
   5624          	FIL* fp		/* Pointer to the file object */
   5625          )
   5626          {
   5627          	putbuff pb;
   5628          	UINT nw;
   5629          
   5630          
   5631          	pb.fp = fp;			/* Initialize output buffer */
   5632          	pb.nchr = pb.idx = 0;
   5633          
   5634          	putc_bfd(&pb, c);	/* Put a character */
   5635          
   5636          	if (   pb.idx >= 0	/* Flush buffered characters to the file */
   5637          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5638          		&& (UINT)pb.idx == nw) return pb.nchr;
   5639          	return EOF;
   5640          }
   5641          
   5642          
   5643          
   5644          
   5645          /*-----------------------------------------------------------------------*/
   5646          /* Put a string to the file                                              */
   5647          /*-----------------------------------------------------------------------*/
   5648          
   5649          int f_puts (
   5650          	const TCHAR* str,	/* Pointer to the string to be output */
   5651          	FIL* fp				/* Pointer to the file object */
   5652          )
   5653          {
   5654          	putbuff pb;
   5655          	UINT nw;
   5656          
   5657          
   5658          	pb.fp = fp;				/* Initialize output buffer */
   5659          	pb.nchr = pb.idx = 0;
   5660          
   5661          	while (*str)			/* Put the string */
   5662          		putc_bfd(&pb, *str++);
   5663          
   5664          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   5665          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5666          		&& (UINT)pb.idx == nw) return pb.nchr;
   5667          	return EOF;
   5668          }
   5669          
   5670          
   5671          
   5672          
   5673          /*-----------------------------------------------------------------------*/
   5674          /* Put a formatted string to the file                                    */
   5675          /*-----------------------------------------------------------------------*/
   5676          
   5677          int f_printf (
   5678          	FIL* fp,			/* Pointer to the file object */
   5679          	const TCHAR* fmt,	/* Pointer to the format string */
   5680          	...					/* Optional arguments... */
   5681          )
   5682          {
   5683          	va_list arp;
   5684          	BYTE f, r;
   5685          	UINT nw, i, j, w;
   5686          	DWORD v;
   5687          	TCHAR c, d, str[32], *p;
   5688          	putbuff pb;
   5689          
   5690          
   5691          	pb.fp = fp;				/* Initialize output buffer */
   5692          	pb.nchr = pb.idx = 0;
   5693          
   5694          	va_start(arp, fmt);
   5695          
   5696          	for (;;) {
   5697          		c = *fmt++;
   5698          		if (c == 0) break;			/* End of string */
   5699          		if (c != '%') {				/* Non escape character */
   5700          			putc_bfd(&pb, c);
   5701          			continue;
   5702          		}
   5703          		w = f = 0;
   5704          		c = *fmt++;
   5705          		if (c == '0') {				/* Flag: '0' padding */
   5706          			f = 1; c = *fmt++;
   5707          		} else {
   5708          			if (c == '-') {			/* Flag: left justified */
   5709          				f = 2; c = *fmt++;
   5710          			}
   5711          		}
   5712          		while (IsDigit(c)) {		/* Precision */
   5713          			w = w * 10 + c - '0';
   5714          			c = *fmt++;
   5715          		}
   5716          		if (c == 'l' || c == 'L') {	/* Prefix: Size is long int */
   5717          			f |= 4; c = *fmt++;
   5718          		}
   5719          		if (!c) break;
   5720          		d = c;
   5721          		if (IsLower(d)) d -= 0x20;
   5722          		switch (d) {				/* Type is... */
   5723          		case 'S' :					/* String */
   5724          			p = va_arg(arp, TCHAR*);
   5725          			for (j = 0; p[j]; j++) ;
   5726          			if (!(f & 2)) {
   5727          				while (j++ < w) putc_bfd(&pb, ' ');
   5728          			}
   5729          			while (*p) putc_bfd(&pb, *p++);
   5730          			while (j++ < w) putc_bfd(&pb, ' ');
   5731          			continue;
   5732          		case 'C' :					/* Character */
   5733          			putc_bfd(&pb, (TCHAR)va_arg(arp, int)); continue;
   5734          		case 'B' :					/* Binary */
   5735          			r = 2; break;
   5736          		case 'O' :					/* Octal */
   5737          			r = 8; break;
   5738          		case 'D' :					/* Signed decimal */
   5739          		case 'U' :					/* Unsigned decimal */
   5740          			r = 10; break;
   5741          		case 'X' :					/* Hexdecimal */
   5742          			r = 16; break;
   5743          		default:					/* Unknown type (pass-through) */
   5744          			putc_bfd(&pb, c); continue;
   5745          		}
   5746          
   5747          		/* Get an argument and put it in numeral */
   5748          		v = (f & 4) ? (DWORD)va_arg(arp, long) : ((d == 'D') ? (DWORD)(long)va_arg(arp, int) : (DWORD)va_arg(arp, unsigned int));
   5749          		if (d == 'D' && (v & 0x80000000)) {
   5750          			v = 0 - v;
   5751          			f |= 8;
   5752          		}
   5753          		i = 0;
   5754          		do {
   5755          			d = (TCHAR)(v % r); v /= r;
   5756          			if (d > 9) d += (c == 'x') ? 0x27 : 0x07;
   5757          			str[i++] = d + '0';
   5758          		} while (v && i < sizeof str / sizeof str[0]);
   5759          		if (f & 8) str[i++] = '-';
   5760          		j = i; d = (f & 1) ? '0' : ' ';
   5761          		while (!(f & 2) && j++ < w) putc_bfd(&pb, d);
   5762          		do putc_bfd(&pb, str[--i]); while (i);
   5763          		while (j++ < w) putc_bfd(&pb, d);
   5764          	}
   5765          
   5766          	va_end(arp);
   5767          
   5768          	if (   pb.idx >= 0		/* Flush buffered characters to the file */
   5769          		&& f_write(pb.fp, pb.buf, (UINT)pb.idx, &nw) == FR_OK
   5770          		&& (UINT)pb.idx == nw) return pb.nchr;
   5771          	return EOF;
   5772          }
   5773          
   5774          #endif /* !_FS_READONLY */
   5775          #endif /* _USE_STRFUNC */

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   change_bitmap
        32   -> move_window
      16   check_fs
        16   -> ld_dword
        16   -> ld_word
        16   -> mem_cmp
        16   -> move_window
       0   chk_chr
       0   clust2sect
      32   create_chain
        32   -> change_bitmap
        32   -> find_bitmap
        32   -> get_fat
        32   -> put_fat
      48   create_name
        48   -> chk_chr
        48   -> ff_convert
        48   -> mem_set
      32   create_xdir
        32   -> mem_set
        32   -> st_word
        32   -> xname_sum
      24   dir_alloc
        24   -> dir_next
        24   -> dir_sdi
        24   -> move_window
      48   dir_find
        48   -> dir_next
        48   -> dir_read
        48   -> dir_sdi
        48   -> ff_wtoupper
        48   -> ld_word
        48   -> mem_cmp
        48   -> move_window
        48   -> sum_sfn
        48   -> xname_sum
      32   dir_next
        32   -> clust2sect
        32   -> create_chain
        32   -> get_fat
        32   -> mem_set
        32   -> sync_window
      48   dir_read
        48   -> dir_next
        48   -> ld_word
        48   -> load_xdir
        48   -> move_window
        48   -> sum_sfn
     120   dir_register
       120   -> create_xdir
       120   -> dir_alloc
       120   -> dir_find
       120   -> dir_next
       120   -> dir_sdi
       120   -> fill_fat_chain
       120   -> gen_numname
       120   -> load_obj_dir
       120   -> mem_cpy
       120   -> mem_set
       120   -> move_window
       120   -> st_qword
       120   -> st_word
       120   -> store_xdir
       120   -> sum_sfn
       120 __aeabi_uidiv
      16   dir_remove
        16   -> dir_next
        16   -> dir_sdi
        16   -> move_window
      24   dir_sdi
        24   -> clust2sect
        24   -> get_fat
     104   f_chdir
       104   -> find_volume
       104   -> follow_path
       104   -> ld_clust
       104   -> ld_dword
      16   f_close
        16   -> f_sync
        16   -> validate
      16   f_closedir
        16   -> validate
      16   f_findfirst
        16   -> f_findnext
        16   -> f_opendir
      16   f_findnext
        16   -> f_readdir
        16   -> pattern_matching
     408   f_getcwd
       408   -> dir_next
       408   -> dir_read
       408   -> dir_sdi
       408   -> find_volume
       408   -> get_fileinfo
       408   -> ld_clust
       408   -> move_window
      88   f_getfree
        88   -> find_volume
        88   -> get_fat
        88   -> ld_dword
        88   -> ld_word
        88   -> move_window
      40   f_gets
        40   -> f_read
      56   f_lseek
        56   -> clust2sect
        56   -> create_chain
        56   -> disk_read
        56   -> disk_write
        56   -> get_fat
        56   -> validate
        56 __aeabi_uldivmod
     128   f_mkdir
       128   -> clust2sect
       128   -> create_chain
       128   -> dir_register
       128   -> find_volume
       128   -> follow_path
       128   -> get_fattime
       128   -> mem_cpy
       128   -> mem_set
       128   -> remove_chain
       128   -> st_clust
       128   -> st_dword
       128   -> store_xdir
       128   -> sync_fs
       128   -> sync_window
      24   f_mount
        24   -> find_volume
        24   -> get_ldnumber
     120   f_open
       120   -> dir_register
       120   -> find_volume
       120   -> follow_path
       120   -> get_fattime
       120   -> ld_clust
       120   -> ld_dword
       120   -> ld_qword
       120   -> move_window
       120   -> remove_chain
       120   -> st_clust
       120   -> st_dword
       120   -> st_qword
       120   -> store_xdir
      32   f_opendir
        32   -> dir_sdi
        32   -> find_volume
        32   -> follow_path
        32   -> ld_clust
        32   -> ld_dword
        32   -> ld_qword
     160   f_printf
       160   -> f_write
       160   -> putc_bfd
       160 __aeabi_uidiv
       160 __aeabi_uidivmod
      88   f_putc
        88   -> f_write
        88   -> putc_bfd
      88   f_puts
        88   -> f_write
        88   -> putc_bfd
      40   f_read
        40   -> clust2sect
        40   -> disk_read
        40   -> disk_write
        40   -> get_fat
        40   -> mem_cpy
        40   -> validate
      32   f_readdir
        32   -> dir_next
        32   -> dir_read
        32   -> dir_sdi
        32   -> get_fileinfo
        32   -> validate
     248   f_rename
       248   -> clust2sect
       248   -> dir_register
       248   -> dir_remove
       248   -> find_volume
       248   -> follow_path
       248   -> get_ldnumber
       248   -> ld_clust
       248   -> ld_word
       248   -> mem_cpy
       248   -> move_window
       248   -> st_clust
       248   -> st_word
       248   -> store_xdir
       248   -> sync_fs
     104   f_stat
       104   -> find_volume
       104   -> follow_path
       104   -> get_fileinfo
     112   f_sync
       112   -> disk_write
       112   -> fill_fat_chain
       112   -> get_fattime
       112   -> load_obj_dir
       112   -> move_window
       112   -> st_clust
       112   -> st_dword
       112   -> st_qword
       112   -> st_word
       112   -> store_xdir
       112   -> sync_fs
       112   -> validate
      24   f_truncate
        24   -> disk_write
        24   -> get_fat
        24   -> remove_chain
        24   -> validate
     224   f_unlink
       224   -> dir_read
       224   -> dir_remove
       224   -> dir_sdi
       224   -> find_volume
       224   -> follow_path
       224   -> ld_clust
       224   -> ld_dword
       224   -> ld_qword
       224   -> remove_chain
       224   -> sync_fs
      40   f_write
        40   -> clust2sect
        40   -> create_chain
        40   -> disk_read
        40   -> disk_write
        40   -> mem_cpy
        40   -> validate
      16   fill_fat_chain
        16   -> put_fat
      40   find_bitmap
        40   -> move_window
      48   find_volume
        48   -> check_fs
        48   -> clust2sect
        48   -> disk_initialize
        48   -> disk_status
        48   -> get_ldnumber
        48   -> ld_dword
        48   -> ld_qword
        48   -> ld_word
        48   -> move_window
        48 __aeabi_uidiv
     112   follow_path
       112   -> create_name
       112   -> dir_find
       112   -> dir_sdi
       112   -> ld_clust
       112   -> ld_dword
       112   -> ld_qword
       112   -> load_obj_dir
      24   gen_numname
        24   -> mem_cpy
       0   get_achar
      32   get_fat
        32   -> ld_dword
        32   -> ld_word
        32   -> move_window
        32 __aeabi_uidiv
      32   get_fileinfo
        32   -> ff_convert
        32   -> get_xdir_info
        32   -> ld_dword
        32   -> ld_word
      12   get_ldnumber
      24   get_xdir_info
        24   -> ff_convert
        24   -> ld_qword
        24   -> ld_word
      16   ld_clust
        16   -> ld_word
       0   ld_dword
      12   ld_qword
       0   ld_word
       8   load_obj_dir
         8   -> dir_sdi
         8   -> load_xdir
      24   load_xdir
        24   -> dir_next
        24   -> ld_word
        24   -> mem_cpy
        24   -> move_window
        24   -> xdir_sum
       8   mem_cmp
       0   mem_cpy
       0   mem_set
      16   move_window
        16   -> disk_read
        16   -> sync_window
      32   pattern_matching
        32   -> get_achar
        32   -> pattern_matching
      24   put_fat
        24   -> ld_dword
        24   -> move_window
        24   -> st_dword
        24   -> st_word
      16   putc_bfd
        16   -> f_write
      40   remove_chain
        40   -> change_bitmap
        40   -> get_fat
        40   -> put_fat
      16   st_clust
        16   -> st_word
       0   st_dword
       0   st_qword
       0   st_word
      24   store_xdir
        24   -> dir_next
        24   -> dir_sdi
        24   -> mem_cpy
        24   -> move_window
        24   -> st_word
        24   -> xdir_sum
       0   sum_sfn
      16   sync_fs
        16   -> disk_ioctl
        16   -> disk_write
        16   -> mem_set
        16   -> st_dword
        16   -> st_word
        16   -> sync_window
      24   sync_window
        24   -> disk_write
      16   validate
        16   -> disk_status
      20   xdir_sum
      16   xname_sum
        16   -> ff_wtoupper


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable11
       4  ??DataTable11_1
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable15
       4  ??DataTable15_1
       4  ??DataTable17
       4  ??DataTable19
       4  ??DataTable22
       4  ??DataTable24
       4  ??DataTable25
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable7
       4  ??DataTable9
       4  ??DataTable9_1
      12  ?_0
       8  ?_1
      12  ?_2
     128  ExCvt
     616  Fsid
          FatFs
          DirBuf
     512  LfnBuf
      16  LfnOfs
     122  change_bitmap
     106  check_fs
      18  chk_chr
      24  clust2sect
     290  create_chain
     568  create_name
     138  create_xdir
      90  dir_alloc
     500  dir_find
     264  dir_next
     370  dir_read
     612  dir_register
      94  dir_remove
     158  dir_sdi
     168  f_chdir
      30  f_close
      20  f_closedir
      28  f_findfirst
      50  f_findnext
     264  f_getcwd
     340  f_getfree
      66  f_gets
     532  f_lseek
     462  f_mkdir
      80  f_mount
     628  f_open
     184  f_opendir
     530  f_printf
      62  f_putc
      72  f_puts
     402  f_read
      82  f_readdir
     360  f_rename
      68  f_stat
     310  f_sync
     208  f_truncate
     250  f_unlink
     534  f_write
      48  fill_fat_chain
     166  find_bitmap
     886  find_volume
     326  follow_path
     126  gen_numname
      34  get_achar
     330  get_fat
     270  get_fileinfo
      66  get_ldnumber
     134  get_xdir_info
      36  ld_clust
      22  ld_dword
      70  ld_qword
      12  ld_word
      54  load_obj_dir
     166  load_xdir
      26  mem_cmp
      18  mem_cpy
      10  mem_set
      54  move_window
     158  pattern_matching
     266  put_fat
      58  putc_bfd
     232  remove_chain
      36  st_clust
      16  st_dword
      54  st_qword
       8  st_word
     100  store_xdir
      26  sum_sfn
     136  sync_fs
      86  sync_window
      56  validate
      58  xdir_sum
      68  xname_sum

 
  1 128 bytes in section .bss
 13 588 bytes in section .text
 
 13 588 bytes of CODE memory
  1 128 bytes of DATA memory

Errors: none
Warnings: none

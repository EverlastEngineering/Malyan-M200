###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Oct/2019  17:00:21
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_can.c
#    Command line =
#        -f C:\Users\yongzong\AppData\Local\Temp\EW406B.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_can.c
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\stm32f0xx_can.lst
#    Object file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\stm32f0xx_can.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_can.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f0xx_can.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    16-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Controller area network (CAN) peripheral and 
      9            *          applicable only for STM32F072 devices :           
     10            *           + Initialization and Configuration 
     11            *           + CAN Frames Transmission 
     12            *           + CAN Frames Reception    
     13            *           + Operation modes switch  
     14            *           + Error management          
     15            *           + Interrupts and flags        
     16            *         
     17            @verbatim
     18                                         
     19           ===============================================================================      
     20                                ##### How to use this driver #####
     21           ===============================================================================                
     22              [..]
     23              (#) Enable the CAN controller interface clock using 
     24                  RCC_APB1PeriphClockCmd(RCC_APB1Periph_CAN, ENABLE);      
     25              (#) CAN pins configuration:
     26                  (++) Enable the clock for the CAN GPIOs using the following function:
     27                       RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOx, ENABLE);   
     28                  (++) Connect the involved CAN pins to AF0 using the following function 
     29                       GPIO_PinAFConfig(GPIOx, GPIO_PinSourcex, GPIO_AF_CANx); 
     30                  (++) Configure these CAN pins in alternate function mode by calling
     31                       the function  GPIO_Init();
     32              (#) Initialise and configure the CAN using CAN_Init() and 
     33                  CAN_FilterInit() functions.   
     34              (#) Transmit the desired CAN frame using CAN_Transmit() function.
     35              (#) Check the transmission of a CAN frame using CAN_TransmitStatus() function.
     36              (#) Cancel the transmission of a CAN frame using CAN_CancelTransmit() function.  
     37              (#) Receive a CAN frame using CAN_Recieve() function.
     38              (#) Release the receive FIFOs using CAN_FIFORelease() function.
     39              (#) Return the number of pending received frames using CAN_MessagePending() function.            
     40              (#) To control CAN events you can use one of the following two methods:
     41                  (++) Check on CAN flags using the CAN_GetFlagStatus() function.  
     42                  (++) Use CAN interrupts through the function CAN_ITConfig() at initialization 
     43                       phase and CAN_GetITStatus() function into interrupt routines to check 
     44                       if the event has occurred or not.
     45                       After checking on a flag you should clear it using CAN_ClearFlag()
     46                       function. And after checking on an interrupt event you should clear it 
     47                       using CAN_ClearITPendingBit() function.            
     48                           
     49            @endverbatim
     50            *       
     51            ******************************************************************************
     52            * @attention
     53            *
     54            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     55            *
     56            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     57            * You may not use this file except in compliance with the License.
     58            * You may obtain a copy of the License at:
     59            *
     60            *        http://www.st.com/software_license_agreement_liberty_v2
     61            *
     62            * Unless required by applicable law or agreed to in writing, software 
     63            * distributed under the License is distributed on an "AS IS" BASIS, 
     64            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     65            * See the License for the specific language governing permissions and
     66            * limitations under the License.
     67            *
     68            ******************************************************************************
     69            */
     70          
     71          /* Includes ------------------------------------------------------------------*/
     72          #include "stm32f0xx_can.h"
     73          #include "stm32f0xx_rcc.h"
     74          
     75          /** @addtogroup STM32F0xx_StdPeriph_Driver
     76            * @{
     77            */
     78          
     79          /** @defgroup CAN 
     80            * @brief CAN driver modules
     81            * @{
     82            */ 
     83          /* Private typedef -----------------------------------------------------------*/
     84          /* Private define ------------------------------------------------------------*/
     85          
     86          /* CAN Master Control Register bits */
     87          #define MCR_DBF           ((uint32_t)0x00010000) /* software master reset */
     88          
     89          /* CAN Mailbox Transmit Request */
     90          #define TMIDxR_TXRQ       ((uint32_t)0x00000001) /* Transmit mailbox request */
     91          
     92          /* CAN Filter Master Register bits */
     93          #define FMR_FINIT         ((uint32_t)0x00000001) /* Filter init mode */
     94          
     95          /* Time out for INAK bit */
     96          #define INAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
     97          /* Time out for SLAK bit */
     98          #define SLAK_TIMEOUT      ((uint32_t)0x00FFFFFF)
     99          
    100          /* Flags in TSR register */
    101          #define CAN_FLAGS_TSR     ((uint32_t)0x08000000) 
    102          /* Flags in RF1R register */
    103          #define CAN_FLAGS_RF1R    ((uint32_t)0x04000000) 
    104          /* Flags in RF0R register */
    105          #define CAN_FLAGS_RF0R    ((uint32_t)0x02000000) 
    106          /* Flags in MSR register */
    107          #define CAN_FLAGS_MSR     ((uint32_t)0x01000000) 
    108          /* Flags in ESR register */
    109          #define CAN_FLAGS_ESR     ((uint32_t)0x00F00000) 
    110          
    111          /* Mailboxes definition */
    112          #define CAN_TXMAILBOX_0   ((uint8_t)0x00)
    113          #define CAN_TXMAILBOX_1   ((uint8_t)0x01)
    114          #define CAN_TXMAILBOX_2   ((uint8_t)0x02) 
    115          
    116          #define CAN_MODE_MASK     ((uint32_t) 0x00000003)
    117          
    118          /* Private macro -------------------------------------------------------------*/
    119          /* Private variables ---------------------------------------------------------*/
    120          /* Private function prototypes -----------------------------------------------*/
    121          /* Private functions ---------------------------------------------------------*/
    122          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit);
    123          
    124          /** @defgroup CAN_Private_Functions
    125            * @{
    126            */
    127          
    128          /** @defgroup CAN_Group1 Initialization and Configuration functions
    129           *  @brief    Initialization and Configuration functions 
    130           *
    131          @verbatim    
    132           ===============================================================================
    133                        ##### Initialization and Configuration functions #####
    134           ===============================================================================  
    135              [..] This section provides functions allowing to: 
    136                   (+) Initialize the CAN peripherals : Prescaler, operating mode, the maximum 
    137                       number of time quanta to perform resynchronization, the number of time 
    138                       quanta in Bit Segment 1 and 2 and many other modes. 
    139                   (+) Configure the CAN reception filter.                                      
    140                   (+) Select the start bank filter for slave CAN.
    141                   (+) Enable or disable the Debug Freeze mode for CAN.
    142                   (+) Enable or disable the CAN Time Trigger Operation communication mode.
    143             
    144          @endverbatim
    145            * @{
    146            */
    147            
    148          /**
    149            * @brief  Deinitializes the CAN peripheral registers to their default reset values.
    150            * @param  CANx: where x can be 1 to select the CAN peripheral.
    151            * @retval None.
    152            */
    153          void CAN_DeInit(CAN_TypeDef* CANx)
    154          {
    155            /* Check the parameters */
    156            assert_param(IS_CAN_ALL_PERIPH(CANx));
    157           
    158            /* Enable CAN reset state */
    159            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, ENABLE);
    160            /* Release CAN from reset state */
    161            RCC_APB1PeriphResetCmd(RCC_APB1Periph_CAN, DISABLE);
    162          }
    163          
    164          /**
    165            * @brief  Initializes the CAN peripheral according to the specified
    166            *         parameters in the CAN_InitStruct.
    167            * @param  CANx: where x can be 1 to select the CAN peripheral.
    168            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure that contains
    169            *         the configuration information for the CAN peripheral.
    170            * @retval Constant indicates initialization succeed which will be 
    171            *         CAN_InitStatus_Failed or CAN_InitStatus_Success.
    172            */
    173          uint8_t CAN_Init(CAN_TypeDef* CANx, CAN_InitTypeDef* CAN_InitStruct)
    174          {
    175            uint8_t InitStatus = CAN_InitStatus_Failed;
    176            uint32_t wait_ack = 0x00000000;
    177            
    178            /* Check the parameters */
    179            assert_param(IS_CAN_ALL_PERIPH(CANx));
    180            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TTCM));
    181            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_ABOM));
    182            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_AWUM));
    183            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_NART));
    184            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_RFLM));
    185            assert_param(IS_FUNCTIONAL_STATE(CAN_InitStruct->CAN_TXFP));
    186            assert_param(IS_CAN_MODE(CAN_InitStruct->CAN_Mode));
    187            assert_param(IS_CAN_SJW(CAN_InitStruct->CAN_SJW));
    188            assert_param(IS_CAN_BS1(CAN_InitStruct->CAN_BS1));
    189            assert_param(IS_CAN_BS2(CAN_InitStruct->CAN_BS2));
    190            assert_param(IS_CAN_PRESCALER(CAN_InitStruct->CAN_Prescaler));
    191          
    192            /* Exit from sleep mode */
    193            CANx->MCR &= (~(uint32_t)CAN_MCR_SLEEP);
    194          
    195            /* Request initialisation */
    196            CANx->MCR |= CAN_MCR_INRQ ;
    197          
    198            /* Wait the acknowledge */
    199            while (((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    200            {
    201              wait_ack++;
    202            }
    203          
    204            /* Check acknowledge */
    205            if ((CANx->MSR & CAN_MSR_INAK) != CAN_MSR_INAK)
    206            {
    207              InitStatus = CAN_InitStatus_Failed;
    208            }
    209            else 
    210            {
    211              /* Set the time triggered communication mode */
    212              if (CAN_InitStruct->CAN_TTCM == ENABLE)
    213              {
    214                CANx->MCR |= CAN_MCR_TTCM;
    215              }
    216              else
    217              {
    218                CANx->MCR &= ~(uint32_t)CAN_MCR_TTCM;
    219              }
    220          
    221              /* Set the automatic bus-off management */
    222              if (CAN_InitStruct->CAN_ABOM == ENABLE)
    223              {
    224                CANx->MCR |= CAN_MCR_ABOM;
    225              }
    226              else
    227              {
    228                CANx->MCR &= ~(uint32_t)CAN_MCR_ABOM;
    229              }
    230          
    231              /* Set the automatic wake-up mode */
    232              if (CAN_InitStruct->CAN_AWUM == ENABLE)
    233              {
    234                CANx->MCR |= CAN_MCR_AWUM;
    235              }
    236              else
    237              {
    238                CANx->MCR &= ~(uint32_t)CAN_MCR_AWUM;
    239              }
    240          
    241              /* Set the no automatic retransmission */
    242              if (CAN_InitStruct->CAN_NART == ENABLE)
    243              {
    244                CANx->MCR |= CAN_MCR_NART;
    245              }
    246              else
    247              {
    248                CANx->MCR &= ~(uint32_t)CAN_MCR_NART;
    249              }
    250          
    251              /* Set the receive FIFO locked mode */
    252              if (CAN_InitStruct->CAN_RFLM == ENABLE)
    253              {
    254                CANx->MCR |= CAN_MCR_RFLM;
    255              }
    256              else
    257              {
    258                CANx->MCR &= ~(uint32_t)CAN_MCR_RFLM;
    259              }
    260          
    261              /* Set the transmit FIFO priority */
    262              if (CAN_InitStruct->CAN_TXFP == ENABLE)
    263              {
    264                CANx->MCR |= CAN_MCR_TXFP;
    265              }
    266              else
    267              {
    268                CANx->MCR &= ~(uint32_t)CAN_MCR_TXFP;
    269              }
    270          
    271              /* Set the bit timing register */
    272              CANx->BTR = (uint32_t)((uint32_t)CAN_InitStruct->CAN_Mode << 30) | \
    273                          ((uint32_t)CAN_InitStruct->CAN_SJW << 24) | \
    274                          ((uint32_t)CAN_InitStruct->CAN_BS1 << 16) | \
    275                          ((uint32_t)CAN_InitStruct->CAN_BS2 << 20) | \
    276                         ((uint32_t)CAN_InitStruct->CAN_Prescaler - 1);
    277          
    278              /* Request leave initialisation */
    279              CANx->MCR &= ~(uint32_t)CAN_MCR_INRQ;
    280          
    281             /* Wait the acknowledge */
    282             wait_ack = 0;
    283          
    284             while (((CANx->MSR & CAN_MSR_INAK) == (uint16_t)CAN_MSR_INAK) && (wait_ack != INAK_TIMEOUT))
    285             {
    286               wait_ack++;
    287             }
    288          
    289              /* ...and check acknowledged */
    290              if ((CANx->MSR & CAN_MSR_INAK) == CAN_MSR_INAK)
    291              {
    292                InitStatus = CAN_InitStatus_Failed;
    293              }
    294              else
    295              {
    296                InitStatus = CAN_InitStatus_Success ;
    297              }
    298            }
    299          
    300            /* At this step, return the status of initialization */
    301            return InitStatus;
    302          }
    303          
    304          /**
    305            * @brief  Configures the CAN reception filter according to the specified
    306            *         parameters in the CAN_FilterInitStruct.
    307            * @param  CAN_FilterInitStruct: pointer to a CAN_FilterInitTypeDef structure that
    308            *         contains the configuration information.
    309            * @retval None
    310            */
    311          void CAN_FilterInit(CAN_FilterInitTypeDef* CAN_FilterInitStruct)
    312          {
    313            uint32_t filter_number_bit_pos = 0;
    314            /* Check the parameters */
    315            assert_param(IS_CAN_FILTER_NUMBER(CAN_FilterInitStruct->CAN_FilterNumber));
    316            assert_param(IS_CAN_FILTER_MODE(CAN_FilterInitStruct->CAN_FilterMode));
    317            assert_param(IS_CAN_FILTER_SCALE(CAN_FilterInitStruct->CAN_FilterScale));
    318            assert_param(IS_CAN_FILTER_FIFO(CAN_FilterInitStruct->CAN_FilterFIFOAssignment));
    319            assert_param(IS_FUNCTIONAL_STATE(CAN_FilterInitStruct->CAN_FilterActivation));
    320          
    321            filter_number_bit_pos = ((uint32_t)1) << CAN_FilterInitStruct->CAN_FilterNumber;
    322          
    323            /* Initialisation mode for the filter */
    324            CAN->FMR |= FMR_FINIT;
    325          
    326            /* Filter Deactivation */
    327            CAN->FA1R &= ~(uint32_t)filter_number_bit_pos;
    328          
    329            /* Filter Scale */
    330            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_16bit)
    331            {
    332              /* 16-bit scale for the filter */
    333              CAN->FS1R &= ~(uint32_t)filter_number_bit_pos;
    334          
    335              /* First 16-bit identifier and First 16-bit mask */
    336              /* Or First 16-bit identifier and Second 16-bit identifier */
    337              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    338                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow) << 16) |
    339                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    340          
    341              /* Second 16-bit identifier and Second 16-bit mask */
    342              /* Or Third 16-bit identifier and Fourth 16-bit identifier */
    343              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    344                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    345                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh);
    346            }
    347          
    348            if (CAN_FilterInitStruct->CAN_FilterScale == CAN_FilterScale_32bit)
    349            {
    350              /* 32-bit scale for the filter */
    351              CAN->FS1R |= filter_number_bit_pos;
    352              /* 32-bit identifier or First 32-bit identifier */
    353              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR1 = 
    354                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdHigh) << 16) |
    355                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterIdLow);
    356              /* 32-bit mask or Second 32-bit identifier */
    357              CAN->sFilterRegister[CAN_FilterInitStruct->CAN_FilterNumber].FR2 = 
    358                 ((0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdHigh) << 16) |
    359                  (0x0000FFFF & (uint32_t)CAN_FilterInitStruct->CAN_FilterMaskIdLow);
    360            }
    361          
    362            /* Filter Mode */
    363            if (CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdMask)
    364            {
    365              /*Id/Mask mode for the filter*/
    366              CAN->FM1R &= ~(uint32_t)filter_number_bit_pos;
    367            }
    368            else /* CAN_FilterInitStruct->CAN_FilterMode == CAN_FilterMode_IdList */
    369            {
    370              /*Identifier list mode for the filter*/
    371              CAN->FM1R |= (uint32_t)filter_number_bit_pos;
    372            }
    373          
    374            /* Filter FIFO assignment */
    375            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO0)
    376            {
    377              /* FIFO 0 assignation for the filter */
    378              CAN->FFA1R &= ~(uint32_t)filter_number_bit_pos;
    379            }
    380          
    381            if (CAN_FilterInitStruct->CAN_FilterFIFOAssignment == CAN_Filter_FIFO1)
    382            {
    383              /* FIFO 1 assignation for the filter */
    384              CAN->FFA1R |= (uint32_t)filter_number_bit_pos;
    385            }
    386            
    387            /* Filter activation */
    388            if (CAN_FilterInitStruct->CAN_FilterActivation == ENABLE)
    389            {
    390              CAN->FA1R |= filter_number_bit_pos;
    391            }
    392          
    393            /* Leave the initialisation mode for the filter */
    394            CAN->FMR &= ~FMR_FINIT;
    395          }
    396          
    397          /**
    398            * @brief  Fills each CAN_InitStruct member with its default value.
    399            * @param  CAN_InitStruct: pointer to a CAN_InitTypeDef structure which ill be initialized.
    400            * @retval None
    401            */
    402          void CAN_StructInit(CAN_InitTypeDef* CAN_InitStruct)
    403          {
    404            /* Reset CAN init structure parameters values */
    405            
    406            /* Initialize the time triggered communication mode */
    407            CAN_InitStruct->CAN_TTCM = DISABLE;
    408            
    409            /* Initialize the automatic bus-off management */
    410            CAN_InitStruct->CAN_ABOM = DISABLE;
    411            
    412            /* Initialize the automatic wake-up mode */
    413            CAN_InitStruct->CAN_AWUM = DISABLE;
    414            
    415            /* Initialize the no automatic retransmission */
    416            CAN_InitStruct->CAN_NART = DISABLE;
    417            
    418            /* Initialize the receive FIFO locked mode */
    419            CAN_InitStruct->CAN_RFLM = DISABLE;
    420            
    421            /* Initialize the transmit FIFO priority */
    422            CAN_InitStruct->CAN_TXFP = DISABLE;
    423            
    424            /* Initialize the CAN_Mode member */
    425            CAN_InitStruct->CAN_Mode = CAN_Mode_Normal;
    426            
    427            /* Initialize the CAN_SJW member */
    428            CAN_InitStruct->CAN_SJW = CAN_SJW_1tq;
    429            
    430            /* Initialize the CAN_BS1 member */
    431            CAN_InitStruct->CAN_BS1 = CAN_BS1_4tq;
    432            
    433            /* Initialize the CAN_BS2 member */
    434            CAN_InitStruct->CAN_BS2 = CAN_BS2_3tq;
    435            
    436            /* Initialize the CAN_Prescaler member */
    437            CAN_InitStruct->CAN_Prescaler = 1;
    438          }
    439          
    440          /**
    441            * @brief  Select the start bank filter for slave CAN.
    442            * @param  CAN_BankNumber: Select the start slave bank filter from 1..27.
    443            * @retval None
    444            */
    445          void CAN_SlaveStartBank(uint8_t CAN_BankNumber) 
    446          {
    447            /* Check the parameters */
    448            assert_param(IS_CAN_BANKNUMBER(CAN_BankNumber));
    449            
    450            /* Enter Initialisation mode for the filter */
    451            CAN->FMR |= FMR_FINIT;
    452            
    453            /* Select the start slave bank */
    454            CAN->FMR &= (uint32_t)0xFFFFC0F1 ;
    455            CAN->FMR |= (uint32_t)(CAN_BankNumber)<<8;
    456            
    457            /* Leave Initialisation mode for the filter */
    458            CAN->FMR &= ~FMR_FINIT;
    459          }
    460          
    461          /**
    462            * @brief  Enables or disables the DBG Freeze for CAN.
    463            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    464            * @param  NewState: new state of the CAN peripheral. 
    465            *          This parameter can be: ENABLE (CAN reception/transmission is frozen
    466            *          during debug. Reception FIFOs can still be accessed/controlled normally) 
    467            *          or DISABLE (CAN is working during debug).
    468            * @retval None
    469            */
    470          void CAN_DBGFreeze(CAN_TypeDef* CANx, FunctionalState NewState)
    471          {
    472            /* Check the parameters */
    473            assert_param(IS_CAN_ALL_PERIPH(CANx));
    474            assert_param(IS_FUNCTIONAL_STATE(NewState));
    475            
    476            if (NewState != DISABLE)
    477            {
    478              /* Enable Debug Freeze  */
    479              CANx->MCR |= MCR_DBF;
    480            }
    481            else
    482            {
    483              /* Disable Debug Freeze */
    484              CANx->MCR &= ~MCR_DBF;
    485            }
    486          }
    487          
    488          /**
    489            * @brief  Enables or disables the CAN Time TriggerOperation communication mode.
    490            * @note   DLC must be programmed as 8 in order Time Stamp (2 bytes) to be 
    491            *         sent over the CAN bus.  
    492            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    493            * @param  NewState: Mode new state. This parameter can be: ENABLE or DISABLE.
    494            *         When enabled, Time stamp (TIME[15:0]) value is  sent in the last two
    495            *         data bytes of the 8-byte message: TIME[7:0] in data byte 6 and TIME[15:8] 
    496            *         in data byte 7. 
    497            * @retval None
    498            */
    499          void CAN_TTComModeCmd(CAN_TypeDef* CANx, FunctionalState NewState)
    500          {
    501            /* Check the parameters */
    502            assert_param(IS_CAN_ALL_PERIPH(CANx));
    503            assert_param(IS_FUNCTIONAL_STATE(NewState));
    504            if (NewState != DISABLE)
    505            {
    506              /* Enable the TTCM mode */
    507              CANx->MCR |= CAN_MCR_TTCM;
    508          
    509              /* Set TGT bits */
    510              CANx->sTxMailBox[0].TDTR |= ((uint32_t)CAN_TDT0R_TGT);
    511              CANx->sTxMailBox[1].TDTR |= ((uint32_t)CAN_TDT1R_TGT);
    512              CANx->sTxMailBox[2].TDTR |= ((uint32_t)CAN_TDT2R_TGT);
    513            }
    514            else
    515            {
    516              /* Disable the TTCM mode */
    517              CANx->MCR &= (uint32_t)(~(uint32_t)CAN_MCR_TTCM);
    518          
    519              /* Reset TGT bits */
    520              CANx->sTxMailBox[0].TDTR &= ((uint32_t)~CAN_TDT0R_TGT);
    521              CANx->sTxMailBox[1].TDTR &= ((uint32_t)~CAN_TDT1R_TGT);
    522              CANx->sTxMailBox[2].TDTR &= ((uint32_t)~CAN_TDT2R_TGT);
    523            }
    524          }
    525          /**
    526            * @}
    527            */
    528          
    529          
    530          /** @defgroup CAN_Group2 CAN Frames Transmission functions
    531           *  @brief    CAN Frames Transmission functions 
    532           *
    533          @verbatim    
    534           ===============================================================================
    535                          ##### CAN Frames Transmission functions #####
    536           ===============================================================================  
    537              [..] This section provides functions allowing to 
    538                   (+) Initiate and transmit a CAN frame message (if there is an empty mailbox).
    539                   (+) Check the transmission status of a CAN Frame.
    540                   (+) Cancel a transmit request.
    541             
    542          @endverbatim
    543            * @{
    544            */
    545          
    546          /**
    547            * @brief  Initiates and transmits a CAN frame message.
    548            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
    549            * @param  TxMessage: pointer to a structure which contains CAN Id, CAN DLC and CAN data.
    550            * @retval The number of the mailbox that is used for transmission or
    551            *         CAN_TxStatus_NoMailBox if there is no empty mailbox.
    552            */
    553          uint8_t CAN_Transmit(CAN_TypeDef* CANx, CanTxMsg* TxMessage)
    554          {
    555            uint8_t transmit_mailbox = 0;
    556            /* Check the parameters */
    557            assert_param(IS_CAN_ALL_PERIPH(CANx));
    558            assert_param(IS_CAN_IDTYPE(TxMessage->IDE));
    559            assert_param(IS_CAN_RTR(TxMessage->RTR));
    560            assert_param(IS_CAN_DLC(TxMessage->DLC));
    561          
    562            /* Select one empty transmit mailbox */
    563            if ((CANx->TSR&CAN_TSR_TME0) == CAN_TSR_TME0)
    564            {
    565              transmit_mailbox = 0;
    566            }
    567            else if ((CANx->TSR&CAN_TSR_TME1) == CAN_TSR_TME1)
    568            {
    569              transmit_mailbox = 1;
    570            }
    571            else if ((CANx->TSR&CAN_TSR_TME2) == CAN_TSR_TME2)
    572            {
    573              transmit_mailbox = 2;
    574            }
    575            else
    576            {
    577              transmit_mailbox = CAN_TxStatus_NoMailBox;
    578            }
    579          
    580            if (transmit_mailbox != CAN_TxStatus_NoMailBox)
    581            {
    582              /* Set up the Id */
    583              CANx->sTxMailBox[transmit_mailbox].TIR &= TMIDxR_TXRQ;
    584              if (TxMessage->IDE == CAN_Id_Standard)
    585              {
    586                assert_param(IS_CAN_STDID(TxMessage->StdId));  
    587                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->StdId << 21) | \
    588                                                            TxMessage->RTR);
    589              }
    590              else
    591              {
    592                assert_param(IS_CAN_EXTID(TxMessage->ExtId));
    593                CANx->sTxMailBox[transmit_mailbox].TIR |= ((TxMessage->ExtId << 3) | \
    594                                                            TxMessage->IDE | \
    595                                                            TxMessage->RTR);
    596              }
    597              
    598              /* Set up the DLC */
    599              TxMessage->DLC &= (uint8_t)0x0000000F;
    600              CANx->sTxMailBox[transmit_mailbox].TDTR &= (uint32_t)0xFFFFFFF0;
    601              CANx->sTxMailBox[transmit_mailbox].TDTR |= TxMessage->DLC;
    602          
    603              /* Set up the data field */
    604              CANx->sTxMailBox[transmit_mailbox].TDLR = (((uint32_t)TxMessage->Data[3] << 24) | 
    605                                                       ((uint32_t)TxMessage->Data[2] << 16) |
    606                                                       ((uint32_t)TxMessage->Data[1] << 8) | 
    607                                                       ((uint32_t)TxMessage->Data[0]));
    608              CANx->sTxMailBox[transmit_mailbox].TDHR = (((uint32_t)TxMessage->Data[7] << 24) | 
    609                                                       ((uint32_t)TxMessage->Data[6] << 16) |
    610                                                       ((uint32_t)TxMessage->Data[5] << 8) |
    611                                                       ((uint32_t)TxMessage->Data[4]));
    612              /* Request transmission */
    613              CANx->sTxMailBox[transmit_mailbox].TIR |= TMIDxR_TXRQ;
    614            }
    615            return transmit_mailbox;
    616          }
    617          
    618          /**
    619            * @brief  Checks the transmission status of a CAN Frame.
    620            * @param  CANx: where x can be 1 to select the CAN peripheral.
    621            * @param  TransmitMailbox: the number of the mailbox that is used for transmission.
    622            * @retval CAN_TxStatus_Ok if the CAN driver transmits the message, 
    623            *         CAN_TxStatus_Failed in an other case.
    624            */
    625          uint8_t CAN_TransmitStatus(CAN_TypeDef* CANx, uint8_t TransmitMailbox)
    626          {
    627            uint32_t state = 0;
    628          
    629            /* Check the parameters */
    630            assert_param(IS_CAN_ALL_PERIPH(CANx));
    631            assert_param(IS_CAN_TRANSMITMAILBOX(TransmitMailbox));
    632           
    633            switch (TransmitMailbox)
    634            {
    635              case (CAN_TXMAILBOX_0): 
    636                state =   CANx->TSR &  (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0);
    637                break;
    638              case (CAN_TXMAILBOX_1): 
    639                state =   CANx->TSR &  (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1);
    640                break;
    641              case (CAN_TXMAILBOX_2): 
    642                state =   CANx->TSR &  (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2);
    643                break;
    644              default:
    645                state = CAN_TxStatus_Failed;
    646                break;
    647            }
    648            switch (state)
    649            {
    650                /* transmit pending  */
    651              case (0x0): state = CAN_TxStatus_Pending;
    652                break;
    653                /* transmit failed  */
    654               case (CAN_TSR_RQCP0 | CAN_TSR_TME0): state = CAN_TxStatus_Failed;
    655                break;
    656               case (CAN_TSR_RQCP1 | CAN_TSR_TME1): state = CAN_TxStatus_Failed;
    657                break;
    658               case (CAN_TSR_RQCP2 | CAN_TSR_TME2): state = CAN_TxStatus_Failed;
    659                break;
    660                /* transmit succeeded  */
    661              case (CAN_TSR_RQCP0 | CAN_TSR_TXOK0 | CAN_TSR_TME0):state = CAN_TxStatus_Ok;
    662                break;
    663              case (CAN_TSR_RQCP1 | CAN_TSR_TXOK1 | CAN_TSR_TME1):state = CAN_TxStatus_Ok;
    664                break;
    665              case (CAN_TSR_RQCP2 | CAN_TSR_TXOK2 | CAN_TSR_TME2):state = CAN_TxStatus_Ok;
    666                break;
    667              default: state = CAN_TxStatus_Failed;
    668                break;
    669            }
    670            return (uint8_t) state;
    671          }
    672          
    673          /**
    674            * @brief  Cancels a transmit request.
    675            * @param  CANx: where x can be 1 to select the CAN peripheral.
    676            * @param  Mailbox: Mailbox number.
    677            * @retval None
    678            */
    679          void CAN_CancelTransmit(CAN_TypeDef* CANx, uint8_t Mailbox)
    680          {
    681            /* Check the parameters */
    682            assert_param(IS_CAN_ALL_PERIPH(CANx));
    683            assert_param(IS_CAN_TRANSMITMAILBOX(Mailbox));
    684            /* abort transmission */
    685            switch (Mailbox)
    686            {
    687              case (CAN_TXMAILBOX_0): CANx->TSR |= CAN_TSR_ABRQ0;
    688                break;
    689              case (CAN_TXMAILBOX_1): CANx->TSR |= CAN_TSR_ABRQ1;
    690                break;
    691              case (CAN_TXMAILBOX_2): CANx->TSR |= CAN_TSR_ABRQ2;
    692                break;
    693              default:
    694                break;
    695            }
    696          }
    697          /**
    698            * @}
    699            */
    700          
    701          
    702          /** @defgroup CAN_Group3 CAN Frames Reception functions
    703           *  @brief    CAN Frames Reception functions 
    704           *
    705          @verbatim    
    706           ===============================================================================
    707                            ##### CAN Frames Reception functions #####
    708           ===============================================================================  
    709              [..] This section provides functions allowing to 
    710                   (+) Receive a correct CAN frame.
    711                   (+) Release a specified receive FIFO (2 FIFOs are available).
    712                   (+) Return the number of the pending received CAN frames.
    713             
    714          @endverbatim
    715            * @{
    716            */
    717          
    718          /**
    719            * @brief  Receives a correct CAN frame.
    720            * @param  CANx: where x can be 1 to select the CAN peripheral.
    721            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    722            * @param  RxMessage: pointer to a structure receive frame which contains CAN Id,
    723            *         CAN DLC, CAN data and FMI number.
    724            * @retval None
    725            */
    726          void CAN_Receive(CAN_TypeDef* CANx, uint8_t FIFONumber, CanRxMsg* RxMessage)
    727          {
    728            /* Check the parameters */
    729            assert_param(IS_CAN_ALL_PERIPH(CANx));
    730            assert_param(IS_CAN_FIFO(FIFONumber));
    731            /* Get the Id */
    732            RxMessage->IDE = (uint8_t)0x04 & CANx->sFIFOMailBox[FIFONumber].RIR;
    733            if (RxMessage->IDE == CAN_Id_Standard)
    734            {
    735              RxMessage->StdId = (uint32_t)0x000007FF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 21);
    736            }
    737            else
    738            {
    739              RxMessage->ExtId = (uint32_t)0x1FFFFFFF & (CANx->sFIFOMailBox[FIFONumber].RIR >> 3);
    740            }
    741            
    742            RxMessage->RTR = (uint8_t)0x02 & CANx->sFIFOMailBox[FIFONumber].RIR;
    743            /* Get the DLC */
    744            RxMessage->DLC = (uint8_t)0x0F & CANx->sFIFOMailBox[FIFONumber].RDTR;
    745            /* Get the FMI */
    746            RxMessage->FMI = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDTR >> 8);
    747            /* Get the data field */
    748            RxMessage->Data[0] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDLR;
    749            RxMessage->Data[1] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 8);
    750            RxMessage->Data[2] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 16);
    751            RxMessage->Data[3] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDLR >> 24);
    752            RxMessage->Data[4] = (uint8_t)0xFF & CANx->sFIFOMailBox[FIFONumber].RDHR;
    753            RxMessage->Data[5] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 8);
    754            RxMessage->Data[6] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 16);
    755            RxMessage->Data[7] = (uint8_t)0xFF & (CANx->sFIFOMailBox[FIFONumber].RDHR >> 24);
    756            /* Release the FIFO */
    757            /* Release FIFO0 */
    758            if (FIFONumber == CAN_FIFO0)
    759            {
    760              CANx->RF0R |= CAN_RF0R_RFOM0;
    761            }
    762            /* Release FIFO1 */
    763            else /* FIFONumber == CAN_FIFO1 */
    764            {
    765              CANx->RF1R |= CAN_RF1R_RFOM1;
    766            }
    767          }
    768          
    769          /**
    770            * @brief  Releases the specified receive FIFO.
    771            * @param  CANx: where x can be 1 to select the CAN peripheral.
    772            * @param  FIFONumber: FIFO to release, CAN_FIFO0 or CAN_FIFO1.
    773            * @retval None
    774            */
    775          void CAN_FIFORelease(CAN_TypeDef* CANx, uint8_t FIFONumber)
    776          {
    777            /* Check the parameters */
    778            assert_param(IS_CAN_ALL_PERIPH(CANx));
    779            assert_param(IS_CAN_FIFO(FIFONumber));
    780            /* Release FIFO0 */
    781            if (FIFONumber == CAN_FIFO0)
    782            {
    783              CANx->RF0R |= CAN_RF0R_RFOM0;
    784            }
    785            /* Release FIFO1 */
    786            else /* FIFONumber == CAN_FIFO1 */
    787            {
    788              CANx->RF1R |= CAN_RF1R_RFOM1;
    789            }
    790          }
    791          
    792          /**
    793            * @brief  Returns the number of pending received messages.
    794            * @param  CANx: where x can be 1 to select the CAN peripheral.
    795            * @param  FIFONumber: Receive FIFO number, CAN_FIFO0 or CAN_FIFO1.
    796            * @retval NbMessage : which is the number of pending message.
    797            */
    798          uint8_t CAN_MessagePending(CAN_TypeDef* CANx, uint8_t FIFONumber)
    799          {
    800            uint8_t message_pending=0;
    801            /* Check the parameters */
    802            assert_param(IS_CAN_ALL_PERIPH(CANx));
    803            assert_param(IS_CAN_FIFO(FIFONumber));
    804            if (FIFONumber == CAN_FIFO0)
    805            {
    806              message_pending = (uint8_t)(CANx->RF0R&(uint32_t)0x03);
    807            }
    808            else if (FIFONumber == CAN_FIFO1)
    809            {
    810              message_pending = (uint8_t)(CANx->RF1R&(uint32_t)0x03);
    811            }
    812            else
    813            {
    814              message_pending = 0;
    815            }
    816            return message_pending;
    817          }
    818          /**
    819            * @}
    820            */
    821          
    822          
    823          /** @defgroup CAN_Group4 CAN Operation modes functions
    824           *  @brief    CAN Operation modes functions 
    825           *
    826          @verbatim    
    827           ===============================================================================
    828                              ##### CAN Operation modes functions #####
    829           ===============================================================================  
    830              [..] This section provides functions allowing to select the CAN Operation modes:
    831                   (+) sleep mode.
    832                   (+) normal mode. 
    833                   (+) initialization mode.
    834             
    835          @endverbatim
    836            * @{
    837            */
    838            
    839            
    840          /**
    841            * @brief  Selects the CAN Operation mode.
    842            * @param  CAN_OperatingMode: CAN Operating Mode.
    843            *         This parameter can be one of @ref CAN_OperatingMode_TypeDef enumeration.
    844            * @retval status of the requested mode which can be: 
    845            *         - CAN_ModeStatus_Failed:  CAN failed entering the specific mode 
    846            *         - CAN_ModeStatus_Success: CAN Succeed entering the specific mode 
    847            */
    848          uint8_t CAN_OperatingModeRequest(CAN_TypeDef* CANx, uint8_t CAN_OperatingMode)
    849          {
    850            uint8_t status = CAN_ModeStatus_Failed;
    851            
    852            /* Timeout for INAK or also for SLAK bits*/
    853            uint32_t timeout = INAK_TIMEOUT; 
    854          
    855            /* Check the parameters */
    856            assert_param(IS_CAN_ALL_PERIPH(CANx));
    857            assert_param(IS_CAN_OPERATING_MODE(CAN_OperatingMode));
    858          
    859            if (CAN_OperatingMode == CAN_OperatingMode_Initialization)
    860            {
    861              /* Request initialisation */
    862              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_SLEEP)) | CAN_MCR_INRQ);
    863          
    864              /* Wait the acknowledge */
    865              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK) && (timeout != 0))
    866              {
    867                timeout--;
    868              }
    869              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_INAK)
    870              {
    871                status = CAN_ModeStatus_Failed;
    872              }
    873              else
    874              {
    875                status = CAN_ModeStatus_Success;
    876              }
    877            }
    878            else  if (CAN_OperatingMode == CAN_OperatingMode_Normal)
    879            {
    880              /* Request leave initialisation and sleep mode  and enter Normal mode */
    881              CANx->MCR &= (uint32_t)(~(CAN_MCR_SLEEP|CAN_MCR_INRQ));
    882          
    883              /* Wait the acknowledge */
    884              while (((CANx->MSR & CAN_MODE_MASK) != 0) && (timeout!=0))
    885              {
    886                timeout--;
    887              }
    888              if ((CANx->MSR & CAN_MODE_MASK) != 0)
    889              {
    890                status = CAN_ModeStatus_Failed;
    891              }
    892              else
    893              {
    894                status = CAN_ModeStatus_Success;
    895              }
    896            }
    897            else  if (CAN_OperatingMode == CAN_OperatingMode_Sleep)
    898            {
    899              /* Request Sleep mode */
    900              CANx->MCR = (uint32_t)((CANx->MCR & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    901          
    902              /* Wait the acknowledge */
    903              while (((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK) && (timeout!=0))
    904              {
    905                timeout--;
    906              }
    907              if ((CANx->MSR & CAN_MODE_MASK) != CAN_MSR_SLAK)
    908              {
    909                status = CAN_ModeStatus_Failed;
    910              }
    911              else
    912              {
    913                status = CAN_ModeStatus_Success;
    914              }
    915            }
    916            else
    917            {
    918              status = CAN_ModeStatus_Failed;
    919            }
    920          
    921            return  (uint8_t) status;
    922          }
    923          
    924          /**
    925            * @brief  Enters the Sleep (low power) mode.
    926            * @param  CANx: where x can be 1 to select the CAN peripheral.
    927            * @retval CAN_Sleep_Ok if sleep entered, CAN_Sleep_Failed otherwise.
    928            */
    929          uint8_t CAN_Sleep(CAN_TypeDef* CANx)
    930          {
    931            uint8_t sleepstatus = CAN_Sleep_Failed;
    932            
    933            /* Check the parameters */
    934            assert_param(IS_CAN_ALL_PERIPH(CANx));
    935              
    936            /* Request Sleep mode */
    937             CANx->MCR = (((CANx->MCR) & (uint32_t)(~(uint32_t)CAN_MCR_INRQ)) | CAN_MCR_SLEEP);
    938             
    939            /* Sleep mode status */
    940            if ((CANx->MSR & (CAN_MSR_SLAK|CAN_MSR_INAK)) == CAN_MSR_SLAK)
    941            {
    942              /* Sleep mode not entered */
    943              sleepstatus =  CAN_Sleep_Ok;
    944            }
    945            /* return sleep mode status */
    946             return (uint8_t)sleepstatus;
    947          }
    948          
    949          /**
    950            * @brief  Wakes up the CAN peripheral from sleep mode .
    951            * @param  CANx: where x can be 1 to select the CAN peripheral.
    952            * @retval CAN_WakeUp_Ok if sleep mode left, CAN_WakeUp_Failed otherwise.
    953            */
    954          uint8_t CAN_WakeUp(CAN_TypeDef* CANx)
    955          {
    956            uint32_t wait_slak = SLAK_TIMEOUT;
    957            uint8_t wakeupstatus = CAN_WakeUp_Failed;
    958            
    959            /* Check the parameters */
    960            assert_param(IS_CAN_ALL_PERIPH(CANx));
    961              
    962            /* Wake up request */
    963            CANx->MCR &= ~(uint32_t)CAN_MCR_SLEEP;
    964              
    965            /* Sleep mode status */
    966            while(((CANx->MSR & CAN_MSR_SLAK) == CAN_MSR_SLAK)&&(wait_slak!=0x00))
    967            {
    968             wait_slak--;
    969            }
    970            if((CANx->MSR & CAN_MSR_SLAK) != CAN_MSR_SLAK)
    971            {
    972             /* wake up done : Sleep mode exited */
    973              wakeupstatus = CAN_WakeUp_Ok;
    974            }
    975            /* return wakeup status */
    976            return (uint8_t)wakeupstatus;
    977          }
    978          /**
    979            * @}
    980            */
    981          
    982          
    983          /** @defgroup CAN_Group5 CAN Bus Error management functions
    984           *  @brief    CAN Bus Error management functions 
    985           *
    986          @verbatim    
    987           ===============================================================================
    988                            ##### CAN Bus Error management functions #####
    989           ===============================================================================  
    990              [..] This section provides functions allowing to 
    991                   (+) Return the CANx's last error code (LEC).
    992                   (+) Return the CANx Receive Error Counter (REC).
    993                   (+) Return the LSB of the 9-bit CANx Transmit Error Counter(TEC).
    994              [..]
    995                   (@) If TEC is greater than 255, The CAN is in bus-off state.
    996                   (@) If REC or TEC are greater than 96, an Error warning flag occurs.
    997                   (@) If REC or TEC are greater than 127, an Error Passive Flag occurs.
    998                                  
    999          @endverbatim
   1000            * @{
   1001            */
   1002            
   1003          /**
   1004            * @brief  Returns the CANx's last error code (LEC).
   1005            * @param  CANx: where x can be 1 to select the CAN peripheral.
   1006            * @retval Error code: 
   1007            *          - CAN_ERRORCODE_NoErr: No Error  
   1008            *          - CAN_ERRORCODE_StuffErr: Stuff Error
   1009            *          - CAN_ERRORCODE_FormErr: Form Error
   1010            *          - CAN_ERRORCODE_ACKErr : Acknowledgment Error
   1011            *          - CAN_ERRORCODE_BitRecessiveErr: Bit Recessive Error
   1012            *          - CAN_ERRORCODE_BitDominantErr: Bit Dominant Error
   1013            *          - CAN_ERRORCODE_CRCErr: CRC Error
   1014            *          - CAN_ERRORCODE_SoftwareSetErr: Software Set Error  
   1015            */
   1016          uint8_t CAN_GetLastErrorCode(CAN_TypeDef* CANx)
   1017          {
   1018            uint8_t errorcode=0;
   1019            
   1020            /* Check the parameters */
   1021            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1022            
   1023            /* Get the error code*/
   1024            errorcode = (((uint8_t)CANx->ESR) & (uint8_t)CAN_ESR_LEC);
   1025            
   1026            /* Return the error code*/
   1027            return errorcode;
   1028          }
   1029          
   1030          /**
   1031            * @brief  Returns the CANx Receive Error Counter (REC).
   1032            * @note   In case of an error during reception, this counter is incremented 
   1033            *         by 1 or by 8 depending on the error condition as defined by the CAN 
   1034            *         standard. After every successful reception, the counter is 
   1035            *         decremented by 1 or reset to 120 if its value was higher than 128. 
   1036            *         When the counter value exceeds 127, the CAN controller enters the 
   1037            *         error passive state.  
   1038            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.  
   1039            * @retval CAN Receive Error Counter. 
   1040            */
   1041          uint8_t CAN_GetReceiveErrorCounter(CAN_TypeDef* CANx)
   1042          {
   1043            uint8_t counter=0;
   1044            
   1045            /* Check the parameters */
   1046            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1047            
   1048            /* Get the Receive Error Counter*/
   1049            counter = (uint8_t)((CANx->ESR & CAN_ESR_REC)>> 24);
   1050            
   1051            /* Return the Receive Error Counter*/
   1052            return counter;
   1053          }
   1054          
   1055          
   1056          /**
   1057            * @brief  Returns the LSB of the 9-bit CANx Transmit Error Counter(TEC).
   1058            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1059            * @retval LSB of the 9-bit CAN Transmit Error Counter. 
   1060            */
   1061          uint8_t CAN_GetLSBTransmitErrorCounter(CAN_TypeDef* CANx)
   1062          {
   1063            uint8_t counter=0;
   1064            
   1065            /* Check the parameters */
   1066            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1067            
   1068            /* Get the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1069            counter = (uint8_t)((CANx->ESR & CAN_ESR_TEC)>> 16);
   1070            
   1071            /* Return the LSB of the 9-bit CANx Transmit Error Counter(TEC) */
   1072            return counter;
   1073          }
   1074          /**
   1075            * @}
   1076            */
   1077          
   1078          /** @defgroup CAN_Group6 Interrupts and flags management functions
   1079           *  @brief   Interrupts and flags management functions
   1080           *
   1081          @verbatim   
   1082           ===============================================================================
   1083                        ##### Interrupts and flags management functions #####
   1084           ===============================================================================  
   1085              [..] This section provides functions allowing to configure the CAN Interrupts 
   1086                   and to get the status and clear flags and Interrupts pending bits.
   1087              [..] The CAN provides 14 Interrupts sources and 15 Flags:
   1088             
   1089            *** Flags ***
   1090            =============
   1091              [..] The 15 flags can be divided on 4 groups: 
   1092                   (+) Transmit Flags:
   1093                       (++) CAN_FLAG_RQCP0. 
   1094                       (++) CAN_FLAG_RQCP1. 
   1095                       (++) CAN_FLAG_RQCP2: Request completed MailBoxes 0, 1 and 2  Flags
   1096                            Set when when the last request (transmit or abort) has 
   1097                            been performed. 
   1098                   (+) Receive Flags:
   1099                       (++) CAN_FLAG_FMP0.
   1100                       (++) CAN_FLAG_FMP1: FIFO 0 and 1 Message Pending Flags; 
   1101                            Set to signal that messages are pending in the receive FIFO.
   1102                            These Flags are cleared only by hardware. 
   1103                       (++) CAN_FLAG_FF0.
   1104                       (++) CAN_FLAG_FF1: FIFO 0 and 1 Full Flags; 
   1105                            Set when three messages are stored in the selected FIFO.                        
   1106                       (++) CAN_FLAG_FOV0.              
   1107                       (++) CAN_FLAG_FOV1: FIFO 0 and 1 Overrun Flags; 
   1108                            Set when a new message has been received and passed the filter 
   1109                            while the FIFO was full.         
   1110                   (+) Operating Mode Flags: 
   1111                       (++) CAN_FLAG_WKU: Wake up Flag; 
   1112                            Set to signal that a SOF bit has been detected while the CAN 
   1113                            hardware was in Sleep mode. 
   1114                       (++) CAN_FLAG_SLAK: Sleep acknowledge Flag;
   1115                            Set to signal that the CAN has entered Sleep Mode. 
   1116                   (+) Error Flags:  
   1117                       (++) CAN_FLAG_EWG: Error Warning Flag;
   1118                            Set when the warning limit has been reached (Receive Error Counter 
   1119                            or Transmit Error Counter greater than 96). 
   1120                            This Flag is cleared only by hardware.
   1121                       (++) CAN_FLAG_EPV: Error Passive Flag;
   1122                            Set when the Error Passive limit has been reached (Receive Error 
   1123                            Counter or Transmit Error Counter greater than 127).
   1124                            This Flag is cleared only by hardware.
   1125                       (++) CAN_FLAG_BOF: Bus-Off Flag;
   1126                            Set when CAN enters the bus-off state. The bus-off state is 
   1127                            entered on TEC overflow, greater than 255.
   1128                            This Flag is cleared only by hardware.
   1129                       (++) CAN_FLAG_LEC: Last error code Flag;
   1130                            Set If a message has been transferred (reception or transmission) 
   1131                            with error, and the error code is hold.                      
   1132            
   1133            *** Interrupts ***
   1134            ==================
   1135              [..] The 14 interrupts can be divided on 4 groups: 
   1136                   (+) Transmit interrupt:   
   1137                       (++) CAN_IT_TME: Transmit mailbox empty Interrupt;
   1138                            If enabled, this interrupt source is pending when no transmit 
   1139                            request are pending for Tx mailboxes.      
   1140                   (+) Receive Interrupts:   
   1141                       (++) CAN_IT_FMP0.
   1142                       (++) CAN_IT_FMP1: FIFO 0 and FIFO1 message pending Interrupts;
   1143                            If enabled, these interrupt sources are pending when messages 
   1144                            are pending in the receive FIFO.
   1145                            The corresponding interrupt pending bits are cleared only by hardware.
   1146                       (++) CAN_IT_FF0.              
   1147                       (++) CAN_IT_FF1: FIFO 0 and FIFO1 full Interrupts;
   1148                            If enabled, these interrupt sources are pending when three messages 
   1149                            are stored in the selected FIFO.
   1150                       (++) CAN_IT_FOV0.        
   1151                       (++) CAN_IT_FOV1: FIFO 0 and FIFO1 overrun Interrupts;        
   1152                            If enabled, these interrupt sources are pending when a new message 
   1153                            has been received and passed the filter while the FIFO was full.
   1154                   (+) Operating Mode Interrupts:    
   1155                       (++) CAN_IT_WKU: Wake-up Interrupt;
   1156                            If enabled, this interrupt source is pending when a SOF bit has 
   1157                            been detected while the CAN hardware was in Sleep mode.
   1158                       (++) CAN_IT_SLK: Sleep acknowledge Interrupt:
   1159                            If enabled, this interrupt source is pending when the CAN has 
   1160                            entered Sleep Mode.       
   1161                   (+) Error Interrupts:     
   1162                       (++) CAN_IT_EWG: Error warning Interrupt; 
   1163                            If enabled, this interrupt source is pending when the warning limit 
   1164                            has been reached (Receive Error Counter or Transmit Error Counter=96). 
   1165                       (++) CAN_IT_EPV: Error passive Interrupt;        
   1166                            If enabled, this interrupt source is pending when the Error Passive 
   1167                            limit has been reached (Receive Error Counter or Transmit Error Counter>127).
   1168                       (++) CAN_IT_BOF: Bus-off Interrupt;
   1169                            If enabled, this interrupt source is pending when CAN enters 
   1170                            the bus-off state. The bus-off state is entered on TEC overflow, 
   1171                            greater than 255.
   1172                            This Flag is cleared only by hardware.
   1173                       (++) CAN_IT_LEC: Last error code Interrupt;        
   1174                            If enabled, this interrupt source is pending when a message has 
   1175                            been transferred (reception or transmission) with error and the 
   1176                            error code is hold.
   1177                       (++) CAN_IT_ERR: Error Interrupt;
   1178                            If enabled, this interrupt source is pending when an error condition 
   1179                            is pending.      
   1180              [..] Managing the CAN controller events: 
   1181                   The user should identify which mode will be used in his application to manage 
   1182                   the CAN controller events: Polling mode or Interrupt mode.
   1183                   (+) In the Polling Mode it is advised to use the following functions:
   1184                       (++) CAN_GetFlagStatus() : to check if flags events occur. 
   1185                       (++) CAN_ClearFlag()     : to clear the flags events.
   1186                   (+) In the Interrupt Mode it is advised to use the following functions:
   1187                       (++) CAN_ITConfig()       : to enable or disable the interrupt source.
   1188                       (++) CAN_GetITStatus()    : to check if Interrupt occurs.
   1189                       (++) CAN_ClearITPendingBit() : to clear the Interrupt pending Bit 
   1190                            (corresponding Flag).
   1191                            This function has no impact on CAN_IT_FMP0 and CAN_IT_FMP1 Interrupts 
   1192                            pending bits since there are cleared only by hardware. 
   1193            
   1194          @endverbatim
   1195            * @{
   1196            */ 
   1197          /**
   1198            * @brief  Enables or disables the specified CANx interrupts.
   1199            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1200            * @param  CAN_IT: specifies the CAN interrupt sources to be enabled or disabled.
   1201            *          This parameter can be: 
   1202            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1203            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1204            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1205            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1206            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1207            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1208            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1209            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1210            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1211            *            @arg CAN_IT_EWG: Error warning Interrupt
   1212            *            @arg CAN_IT_EPV: Error passive Interrupt
   1213            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1214            *            @arg CAN_IT_LEC: Last error code Interrupt
   1215            *            @arg CAN_IT_ERR: Error Interrupt
   1216            * @param  NewState: new state of the CAN interrupts.
   1217            *          This parameter can be: ENABLE or DISABLE.
   1218            * @retval None
   1219            */
   1220          void CAN_ITConfig(CAN_TypeDef* CANx, uint32_t CAN_IT, FunctionalState NewState)
   1221          {
   1222            /* Check the parameters */
   1223            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1224            assert_param(IS_CAN_IT(CAN_IT));
   1225            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1226          
   1227            if (NewState != DISABLE)
   1228            {
   1229              /* Enable the selected CANx interrupt */
   1230              CANx->IER |= CAN_IT;
   1231            }
   1232            else
   1233            {
   1234              /* Disable the selected CANx interrupt */
   1235              CANx->IER &= ~CAN_IT;
   1236            }
   1237          }
   1238          /**
   1239            * @brief  Checks whether the specified CAN flag is set or not.
   1240            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1241            * @param  CAN_FLAG: specifies the flag to check.
   1242            *          This parameter can be one of the following values:
   1243            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1244            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1245            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag
   1246            *            @arg CAN_FLAG_FMP0: FIFO 0 Message Pending Flag   
   1247            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1248            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag 
   1249            *            @arg CAN_FLAG_FMP1: FIFO 1 Message Pending Flag   
   1250            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1251            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1252            *            @arg CAN_FLAG_WKU: Wake up Flag
   1253            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag 
   1254            *            @arg CAN_FLAG_EWG: Error Warning Flag
   1255            *            @arg CAN_FLAG_EPV: Error Passive Flag  
   1256            *            @arg CAN_FLAG_BOF: Bus-Off Flag    
   1257            *            @arg CAN_FLAG_LEC: Last error code Flag      
   1258            * @retval The new state of CAN_FLAG (SET or RESET).
   1259            */
   1260          FlagStatus CAN_GetFlagStatus(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1261          {
   1262            FlagStatus bitstatus = RESET;
   1263            
   1264            /* Check the parameters */
   1265            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1266            assert_param(IS_CAN_GET_FLAG(CAN_FLAG));
   1267            
   1268          
   1269            if((CAN_FLAG & CAN_FLAGS_ESR) != (uint32_t)RESET)
   1270            { 
   1271              /* Check the status of the specified CAN flag */
   1272              if ((CANx->ESR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1273              { 
   1274                /* CAN_FLAG is set */
   1275                bitstatus = SET;
   1276              }
   1277              else
   1278              { 
   1279                /* CAN_FLAG is reset */
   1280                bitstatus = RESET;
   1281              }
   1282            }
   1283            else if((CAN_FLAG & CAN_FLAGS_MSR) != (uint32_t)RESET)
   1284            { 
   1285              /* Check the status of the specified CAN flag */
   1286              if ((CANx->MSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1287              { 
   1288                /* CAN_FLAG is set */
   1289                bitstatus = SET;
   1290              }
   1291              else
   1292              { 
   1293                /* CAN_FLAG is reset */
   1294                bitstatus = RESET;
   1295              }
   1296            }
   1297            else if((CAN_FLAG & CAN_FLAGS_TSR) != (uint32_t)RESET)
   1298            { 
   1299              /* Check the status of the specified CAN flag */
   1300              if ((CANx->TSR & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1301              { 
   1302                /* CAN_FLAG is set */
   1303                bitstatus = SET;
   1304              }
   1305              else
   1306              { 
   1307                /* CAN_FLAG is reset */
   1308                bitstatus = RESET;
   1309              }
   1310            }
   1311            else if((CAN_FLAG & CAN_FLAGS_RF0R) != (uint32_t)RESET)
   1312            { 
   1313              /* Check the status of the specified CAN flag */
   1314              if ((CANx->RF0R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1315              { 
   1316                /* CAN_FLAG is set */
   1317                bitstatus = SET;
   1318              }
   1319              else
   1320              { 
   1321                /* CAN_FLAG is reset */
   1322                bitstatus = RESET;
   1323              }
   1324            }
   1325            else /* If(CAN_FLAG & CAN_FLAGS_RF1R != (uint32_t)RESET) */
   1326            { 
   1327              /* Check the status of the specified CAN flag */
   1328              if ((uint32_t)(CANx->RF1R & (CAN_FLAG & 0x000FFFFF)) != (uint32_t)RESET)
   1329              { 
   1330                /* CAN_FLAG is set */
   1331                bitstatus = SET;
   1332              }
   1333              else
   1334              { 
   1335                /* CAN_FLAG is reset */
   1336                bitstatus = RESET;
   1337              }
   1338            }
   1339            /* Return the CAN_FLAG status */
   1340            return  bitstatus;
   1341          }
   1342          
   1343          /**
   1344            * @brief  Clears the CAN's pending flags.
   1345            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1346            * @param  CAN_FLAG: specifies the flag to clear.
   1347            *          This parameter can be one of the following values:
   1348            *            @arg CAN_FLAG_RQCP0: Request MailBox0 Flag
   1349            *            @arg CAN_FLAG_RQCP1: Request MailBox1 Flag
   1350            *            @arg CAN_FLAG_RQCP2: Request MailBox2 Flag 
   1351            *            @arg CAN_FLAG_FF0: FIFO 0 Full Flag       
   1352            *            @arg CAN_FLAG_FOV0: FIFO 0 Overrun Flag  
   1353            *            @arg CAN_FLAG_FF1: FIFO 1 Full Flag        
   1354            *            @arg CAN_FLAG_FOV1: FIFO 1 Overrun Flag     
   1355            *            @arg CAN_FLAG_WKU: Wake up Flag
   1356            *            @arg CAN_FLAG_SLAK: Sleep acknowledge Flag    
   1357            *            @arg CAN_FLAG_LEC: Last error code Flag        
   1358            * @retval None
   1359            */
   1360          void CAN_ClearFlag(CAN_TypeDef* CANx, uint32_t CAN_FLAG)
   1361          {
   1362            uint32_t flagtmp=0;
   1363            /* Check the parameters */
   1364            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1365            assert_param(IS_CAN_CLEAR_FLAG(CAN_FLAG));
   1366            
   1367            if (CAN_FLAG == CAN_FLAG_LEC) /* ESR register */
   1368            {
   1369              /* Clear the selected CAN flags */
   1370              CANx->ESR = (uint32_t)RESET;
   1371            }
   1372            else /* MSR or TSR or RF0R or RF1R */
   1373            {
   1374              flagtmp = CAN_FLAG & 0x000FFFFF;
   1375          
   1376              if ((CAN_FLAG & CAN_FLAGS_RF0R)!=(uint32_t)RESET)
   1377              {
   1378                /* Receive Flags */
   1379                CANx->RF0R = (uint32_t)(flagtmp);
   1380              }
   1381              else if ((CAN_FLAG & CAN_FLAGS_RF1R)!=(uint32_t)RESET)
   1382              {
   1383                /* Receive Flags */
   1384                CANx->RF1R = (uint32_t)(flagtmp);
   1385              }
   1386              else if ((CAN_FLAG & CAN_FLAGS_TSR)!=(uint32_t)RESET)
   1387              {
   1388                /* Transmit Flags */
   1389                CANx->TSR = (uint32_t)(flagtmp);
   1390              }
   1391              else /* If((CAN_FLAG & CAN_FLAGS_MSR)!=(uint32_t)RESET) */
   1392              {
   1393                /* Operating mode Flags */
   1394                CANx->MSR = (uint32_t)(flagtmp);
   1395              }
   1396            }
   1397          }
   1398          
   1399          /**
   1400            * @brief  Checks whether the specified CANx interrupt has occurred or not.
   1401            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1402            * @param  CAN_IT: specifies the CAN interrupt source to check.
   1403            *          This parameter can be one of the following values:
   1404            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt 
   1405            *            @arg CAN_IT_FMP0: FIFO 0 message pending Interrupt 
   1406            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1407            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1408            *            @arg CAN_IT_FMP1: FIFO 1 message pending Interrupt 
   1409            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1410            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1411            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1412            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1413            *            @arg CAN_IT_EWG: Error warning Interrupt
   1414            *            @arg CAN_IT_EPV: Error passive Interrupt
   1415            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1416            *            @arg CAN_IT_LEC: Last error code Interrupt
   1417            *            @arg CAN_IT_ERR: Error Interrupt
   1418            * @retval The current state of CAN_IT (SET or RESET).
   1419            */
   1420          ITStatus CAN_GetITStatus(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1421          {
   1422            ITStatus itstatus = RESET;
   1423            /* Check the parameters */
   1424            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1425            assert_param(IS_CAN_IT(CAN_IT));
   1426            
   1427            /* check the interrupt enable bit */
   1428           if((CANx->IER & CAN_IT) != RESET)
   1429           {
   1430             /* in case the Interrupt is enabled, .... */
   1431              switch (CAN_IT)
   1432              {
   1433                case CAN_IT_TME:
   1434                  /* Check CAN_TSR_RQCPx bits */
   1435                  itstatus = CheckITStatus(CANx->TSR, CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2);  
   1436                  break;
   1437                case CAN_IT_FMP0:
   1438                  /* Check CAN_RF0R_FMP0 bit */
   1439                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FMP0);  
   1440                  break;
   1441                case CAN_IT_FF0:
   1442                  /* Check CAN_RF0R_FULL0 bit */
   1443                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FULL0);  
   1444                  break;
   1445                case CAN_IT_FOV0:
   1446                  /* Check CAN_RF0R_FOVR0 bit */
   1447                  itstatus = CheckITStatus(CANx->RF0R, CAN_RF0R_FOVR0);  
   1448                  break;
   1449                case CAN_IT_FMP1:
   1450                  /* Check CAN_RF1R_FMP1 bit */
   1451                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FMP1);  
   1452                  break;
   1453                case CAN_IT_FF1:
   1454                  /* Check CAN_RF1R_FULL1 bit */
   1455                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FULL1);  
   1456                  break;
   1457                case CAN_IT_FOV1:
   1458                  /* Check CAN_RF1R_FOVR1 bit */
   1459                  itstatus = CheckITStatus(CANx->RF1R, CAN_RF1R_FOVR1);  
   1460                  break;
   1461                case CAN_IT_WKU:
   1462                  /* Check CAN_MSR_WKUI bit */
   1463                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_WKUI);  
   1464                  break;
   1465                case CAN_IT_SLK:
   1466                  /* Check CAN_MSR_SLAKI bit */
   1467                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_SLAKI);  
   1468                  break;
   1469                case CAN_IT_EWG:
   1470                  /* Check CAN_ESR_EWGF bit */
   1471                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EWGF);  
   1472                  break;
   1473                case CAN_IT_EPV:
   1474                  /* Check CAN_ESR_EPVF bit */
   1475                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_EPVF);  
   1476                  break;
   1477                case CAN_IT_BOF:
   1478                  /* Check CAN_ESR_BOFF bit */
   1479                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_BOFF);  
   1480                  break;
   1481                case CAN_IT_LEC:
   1482                  /* Check CAN_ESR_LEC bit */
   1483                  itstatus = CheckITStatus(CANx->ESR, CAN_ESR_LEC);  
   1484                  break;
   1485                case CAN_IT_ERR:
   1486                  /* Check CAN_MSR_ERRI bit */ 
   1487                  itstatus = CheckITStatus(CANx->MSR, CAN_MSR_ERRI); 
   1488                  break;
   1489                default:
   1490                  /* in case of error, return RESET */
   1491                  itstatus = RESET;
   1492                  break;
   1493              }
   1494            }
   1495            else
   1496            {
   1497             /* in case the Interrupt is not enabled, return RESET */
   1498              itstatus  = RESET;
   1499            }
   1500            
   1501            /* Return the CAN_IT status */
   1502            return  itstatus;
   1503          }
   1504          
   1505          /**
   1506            * @brief  Clears the CANx's interrupt pending bits.
   1507            * @param  CANx: where x can be 1 or 2 to to select the CAN peripheral.
   1508            * @param  CAN_IT: specifies the interrupt pending bit to clear.
   1509            *          This parameter can be one of the following values:
   1510            *            @arg CAN_IT_TME: Transmit mailbox empty Interrupt
   1511            *            @arg CAN_IT_FF0: FIFO 0 full Interrupt
   1512            *            @arg CAN_IT_FOV0: FIFO 0 overrun Interrupt
   1513            *            @arg CAN_IT_FF1: FIFO 1 full Interrupt
   1514            *            @arg CAN_IT_FOV1: FIFO 1 overrun Interrupt
   1515            *            @arg CAN_IT_WKU: Wake-up Interrupt
   1516            *            @arg CAN_IT_SLK: Sleep acknowledge Interrupt  
   1517            *            @arg CAN_IT_EWG: Error warning Interrupt
   1518            *            @arg CAN_IT_EPV: Error passive Interrupt
   1519            *            @arg CAN_IT_BOF: Bus-off Interrupt  
   1520            *            @arg CAN_IT_LEC: Last error code Interrupt
   1521            *            @arg CAN_IT_ERR: Error Interrupt 
   1522            * @retval None
   1523            */
   1524          void CAN_ClearITPendingBit(CAN_TypeDef* CANx, uint32_t CAN_IT)
   1525          {
   1526            /* Check the parameters */
   1527            assert_param(IS_CAN_ALL_PERIPH(CANx));
   1528            assert_param(IS_CAN_CLEAR_IT(CAN_IT));
   1529          
   1530            switch (CAN_IT)
   1531            {
   1532              case CAN_IT_TME:
   1533                /* Clear CAN_TSR_RQCPx (rc_w1)*/
   1534                CANx->TSR = CAN_TSR_RQCP0|CAN_TSR_RQCP1|CAN_TSR_RQCP2;  
   1535                break;
   1536              case CAN_IT_FF0:
   1537                /* Clear CAN_RF0R_FULL0 (rc_w1)*/
   1538                CANx->RF0R = CAN_RF0R_FULL0; 
   1539                break;
   1540              case CAN_IT_FOV0:
   1541                /* Clear CAN_RF0R_FOVR0 (rc_w1)*/
   1542                CANx->RF0R = CAN_RF0R_FOVR0; 
   1543                break;
   1544              case CAN_IT_FF1:
   1545                /* Clear CAN_RF1R_FULL1 (rc_w1)*/
   1546                CANx->RF1R = CAN_RF1R_FULL1;  
   1547                break;
   1548              case CAN_IT_FOV1:
   1549                /* Clear CAN_RF1R_FOVR1 (rc_w1)*/
   1550                CANx->RF1R = CAN_RF1R_FOVR1; 
   1551                break;
   1552              case CAN_IT_WKU:
   1553                /* Clear CAN_MSR_WKUI (rc_w1)*/
   1554                CANx->MSR = CAN_MSR_WKUI;  
   1555                break;
   1556              case CAN_IT_SLK:
   1557                /* Clear CAN_MSR_SLAKI (rc_w1)*/ 
   1558                CANx->MSR = CAN_MSR_SLAKI;   
   1559                break;
   1560              case CAN_IT_EWG:
   1561                /* Clear CAN_MSR_ERRI (rc_w1) */
   1562                CANx->MSR = CAN_MSR_ERRI;
   1563                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/ 
   1564                break;
   1565              case CAN_IT_EPV:
   1566                /* Clear CAN_MSR_ERRI (rc_w1) */
   1567                CANx->MSR = CAN_MSR_ERRI; 
   1568                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1569                break;
   1570              case CAN_IT_BOF:
   1571                /* Clear CAN_MSR_ERRI (rc_w1) */ 
   1572                CANx->MSR = CAN_MSR_ERRI; 
   1573                 /* @note the corresponding Flag is cleared by hardware depending on the CAN Bus status*/
   1574                 break;
   1575              case CAN_IT_LEC:
   1576                /*  Clear LEC bits */
   1577                CANx->ESR = RESET; 
   1578                /* Clear CAN_MSR_ERRI (rc_w1) */
   1579                CANx->MSR = CAN_MSR_ERRI; 
   1580                break;
   1581              case CAN_IT_ERR:
   1582                /*Clear LEC bits */
   1583                CANx->ESR = RESET; 
   1584                /* Clear CAN_MSR_ERRI (rc_w1) */
   1585                CANx->MSR = CAN_MSR_ERRI; 
   1586                 /* @note BOFF, EPVF and EWGF Flags are cleared by hardware depending on the CAN Bus status*/
   1587                 break;
   1588              default:
   1589                 break;
   1590             }
   1591          }
   1592           /**
   1593            * @}
   1594            */
   1595          
   1596          /**
   1597            * @brief  Checks whether the CAN interrupt has occurred or not.
   1598            * @param  CAN_Reg: specifies the CAN interrupt register to check.
   1599            * @param  It_Bit: specifies the interrupt source bit to check.
   1600            * @retval The new state of the CAN Interrupt (SET or RESET).
   1601            */
   1602          static ITStatus CheckITStatus(uint32_t CAN_Reg, uint32_t It_Bit)
   1603          {
   1604            ITStatus pendingbitstatus = RESET;
   1605            
   1606            if ((CAN_Reg & It_Bit) != (uint32_t)RESET)
   1607            {
   1608              /* CAN_IT is set */
   1609              pendingbitstatus = SET;
   1610            }
   1611            else
   1612            {
   1613              /* CAN_IT is reset */
   1614              pendingbitstatus = RESET;
   1615            }
   1616            return pendingbitstatus;
   1617          }
   1618          
   1619          /**
   1620            * @}
   1621            */
   1622          
   1623          /**
   1624            * @}
   1625            */
   1626          
   1627          /**
   1628            * @}
   1629            */
   1630          
   1631          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CAN_CancelTransmit
       0   CAN_ClearFlag
       8   CAN_ClearITPendingBit
       0   CAN_DBGFreeze
       8   CAN_DeInit
         8   -> RCC_APB1PeriphResetCmd
       0   CAN_FIFORelease
      20   CAN_FilterInit
      12   CAN_GetFlagStatus
       8   CAN_GetITStatus
         8   -> CheckITStatus
       0   CAN_GetLSBTransmitErrorCounter
       0   CAN_GetLastErrorCode
       0   CAN_GetReceiveErrorCounter
       0   CAN_ITConfig
      16   CAN_Init
       8   CAN_MessagePending
      16   CAN_OperatingModeRequest
      12   CAN_Receive
       0   CAN_SlaveStartBank
       0   CAN_Sleep
       0   CAN_StructInit
       0   CAN_TTComModeCmd
      20   CAN_Transmit
       0   CAN_TransmitStatus
       8   CAN_WakeUp
       0   CheckITStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_2
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable12_3
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
      38  CAN_CancelTransmit
      44  CAN_ClearFlag
     110  CAN_ClearITPendingBit
      22  CAN_DBGFreeze
      24  CAN_DeInit
      22  CAN_FIFORelease
     172  CAN_FilterInit
      56  CAN_GetFlagStatus
     160  CAN_GetITStatus
       8  CAN_GetLSBTransmitErrorCounter
       8  CAN_GetLastErrorCode
       6  CAN_GetReceiveErrorCounter
      18  CAN_ITConfig
     240  CAN_Init
      26  CAN_MessagePending
     122  CAN_OperatingModeRequest
     122  CAN_Receive
      36  CAN_SlaveStartBank
      30  CAN_Sleep
      32  CAN_StructInit
      68  CAN_TTComModeCmd
     164  CAN_Transmit
      68  CAN_TransmitStatus
      40  CAN_WakeUp
      12  CheckITStatus

 
 1'700 bytes in section .text
 
 1'700 bytes of CODE memory

Errors: none
Warnings: none

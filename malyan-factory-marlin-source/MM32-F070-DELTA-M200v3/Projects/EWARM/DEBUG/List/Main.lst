###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Oct/2019  17:32:53
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Main.cpp
#    Command line =
#        -f C:\Users\yongzong\AppData\Local\Temp\EW87C.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Main.cpp
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --c++ --no_exceptions --no_rtti --no_static_destruction -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\Main.lst
#    Object file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\Main.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Main.cpp
      1          /**
      2           * Marlin Firmware
      3           *
      4           * Based on Sprinter and grbl.
      5           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      6           *
      7           * This program is free software: you can redistribute it and/or modify
      8           * it under the terms of the GNU General Public License as published by
      9           * the Free Software Foundation, either version 3 of the License, or
     10           * (at your option) any later version.
     11           *
     12           * This program is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15           * GNU General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU General Public License
     18           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19           *
     20           * About Marlin
     21           *
     22           * This firmware is a mashup between Sprinter and grbl.
     23           *  - https://github.com/kliment/Sprinter
     24           *  - https://github.com/simen/grbl/tree
     25           *
     26           * It has preliminary support for Matthew Roberts advance algorithm
     27           *  - http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
     28           */
     29          
     30          /* All the implementation is done in *.cpp files to get better compatibility with avr-gcc without the Arduino IDE */
     31          /* Use this file to help the Arduino IDE find which Arduino libraries are needed and to keep documentation on GCode */
     32          
     33          #include "Configuration.h"
     34          #include "pins.h"
     35          #include "SEGGER_RTT.h"
     36          
     37          #if ENABLED(ULTRA_LCD)
     38            #if ENABLED(LCD_I2C_TYPE_PCF8575)
     39              #include <Wire.h>
     40              #include <LiquidCrystal_I2C.h>
     41            #elif ENABLED(LCD_I2C_TYPE_MCP23017) || ENABLED(LCD_I2C_TYPE_MCP23008)
     42              #include <Wire.h>
     43              #include <LiquidTWI2.h>
     44            #elif ENABLED(DOGLCD)
     45              #include "U8glib.h" // library for graphics LCD by Oli Kraus (https://code.google.com/p/u8glib/)
     46            #else
     47              #include <LiquidCrystal.h> // library for character LCD
     48            #endif
     49          #endif
     50          
     51          #if HAS_DIGIPOTSS
     52            #include <SPI.h>
     53          #endif
     54          
     55          #if ENABLED(DIGIPOT_I2C)
     56            #include <Wire.h>
     57          #endif
     58          
     59          #if ENABLED(HAVE_TMCDRIVER)
     60            #include <SPI.h>
     61            #include <TMC26XStepper.h>
     62          #endif
     63          
     64          #if ENABLED(HAVE_L6470DRIVER)
     65            #include <SPI.h>
     66            #include <L6470.h>
     67          #endif
     68          
     69          extern void setup();
     70          extern void loop();
     71          extern "C" void USB_main();
     72          extern "C" void SetSysTick();
     73          extern void wifi_writeString(char message[]);
     74          
     75          __no_init unsigned int MAGIC @ 0x20000400;
     76          //__no_init char HWVER[4] @ 0x20000410;
     77          //__no_init const char MACHINE_TYPE[4] @ 0x08001000;
     78          extern const char MACHINE_TYPE[];
     79          
     80          bool unlocked;
     81          
     82          extern void update_LCD();
     83          extern void serial_init(int);
     84          extern "C" void GenerateSystemReset(void);
     85          extern "C" void store_char_usb(unsigned char c);
     86          extern "C" void MSD0_SPI_Configuration();
     87          
     88          void writeString(char message[]) {
     89              char* letter = message;
     90              while (*letter != 0) {
     91                  while(USART_GetFlagStatus(USART1, USART_FLAG_TXE) == RESET){}
     92                  USART_SendData(USART1,*letter);
     93                  letter++;
     94              }
     95          }
     96          
     97          void print_endstop(uint8_t p)
     98          {
     99              if (p&1) writeString("ENDSTOP X TRIGGERED\n");
    100              if (p&2) writeString("ENDSTOP Y TRIGGERED\n");
    101              if (p&4) writeString("ENDSTOP Z TRIGGERED\n");
    102              if (p&8) writeString("ENDSTOP P TRIGGERED\n");
    103          }
    104          
    105          uint8_t get_endstop()
    106          {
    107              uint8_t pin_stat=0;
    108              if (READ(X_STOP_PIN) == 0) pin_stat|=1;
    109              if (READ(Y_STOP_PIN) == 0) pin_stat|=2;
    110              if (READ(Z_STOP_PIN) == 0) pin_stat|=4;
    111              
    112              if (model==6 || model==8)
    113              {
    114                  SET_INPUT(Z_MIN_PIN);
    115                  if (READ(Z_MIN_PIN) == 0) pin_stat|=8;
    116              }
    117              else pin_stat|=8;
    118              return pin_stat;
    119          }
    120          
    121          void main()
    122          {
    123              extern void Config_RetrieveSettings(bool);
    124              
    125              __disable_irq();
    126              memcpy((void*)0x20000000, (void*)0x08002000, 0x100);
    127              SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SRAM);
    128              bDeviceState=0;
    129              com_opened=0;
    130              
    131              RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA|RCC_AHBPeriph_GPIOB|RCC_AHBPeriph_GPIOC, ENABLE);
    132              unlocked=false;
    133              if (MAGIC==0xDEADBEEF)
    134              {
    135                  unlocked=true;
    136                  USB_main();
    137              }
    138              serial_init(512000);
    139              writeString("serial_init\n");
    140              
    141              SetSysTick();
    142              writeString("SetSysTick\n");
    143              Config_RetrieveSettings(true);
    144              writeString("RetrieveSettings\n");
    145              port_init();
    146              writeString("port_init\n");
    147              
    148              if (model==6)
    149              {
    150                LED_WORKING_ON;LED_LINK_ON;LED_STOP_ON;
    151              }
    152              writeString("LED_ON\n");
    153          
    154              SET_INPUT(X_STOP_PIN);
    155              SET_INPUT(Y_STOP_PIN);
    156              SET_INPUT(Z_STOP_PIN);
    157              
    158              uint8_t pin_stat=0;
    159              pin_stat=get_endstop();
    160              print_endstop(pin_stat);
    161              
    162              pin_stat=get_endstop();
    163              print_endstop(pin_stat);
    164              
    165              if (pin_stat==0xF)
    166              {
    167                pin_stat=get_endstop();
    168                print_endstop(pin_stat);
    169                
    170                if (pin_stat==0xF)
    171                {
    172                    writeString("ENTER UPDATE_LCD\n");
    173                    update_LCD();
    174                }
    175              }
    176              
    177              setup();
    178              writeString("setup\n");
    179          
    180          #ifdef PRINT_INFO
    181              SEGGER_RTT_ConfigUpBuffer(0, NULL, NULL, 0, SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL);
    182          #endif
    183          
    184              extern const char VERSION[];
    185              wifi_writeString((char *)"{SYS:STARTED}");
    186              wifi_writeString((char *)"{VER:");
    187              while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
    188              USART_SendData(WIFI_UART,VERSION[0]+0x80);
    189              while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
    190              USART_SendData(WIFI_UART,VERSION[2]+0x80);
    191              wifi_writeString((char *)"}");
    192              
    193              store_char_usb('\n');
    194              
    195              __enable_irq();
    196              
    197              if (model==2)
    198              {
    199                  //delay(1000);
    200                  LED_WORKING_OFF;LED_LINK_OFF;LED_STOP_OFF;
    201              }
    202              else if (model==6)
    203              {
    204                  LED_WORKING_OFF;LED_LINK_OFF;LED_STOP_OFF;
    205              }
    206              
    207              GPIO_InitTypeDef GPIO_InitStructure;
    208              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5;
    209              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    210              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    211              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    212              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    213              GPIO_Init(GPIOB, &GPIO_InitStructure);
    214              if (MACHINE_TYPE[0]!='M') unlocked=false;
    215              while (1)
    216              {
    217                  loop();
    218              }
    219          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   get_endstop()
        32   -> GPIO_Init
        32   -> GPIO_ReadInputDataBit_filtered
      32   main
        32   -> Config_RetrieveSettings(bool)
        32   -> GPIO_Init
        32   -> GPIO_ResetBits
        32   -> GPIO_SetBits
        32   -> RCC_AHBPeriphClockCmd
        32   -> SYSCFG_MemoryRemapConfig
        32   -> SetSysTick
        32   -> USART_GetFlagStatus
        32   -> USART_SendData
        32   -> USB_main
        32   -> __aeabi_memcpy4
        32   -> get_endstop()
        32   -> loop()
        32   -> port_init
        32   -> print_endstop(uint8_t)
        32   -> serial_init(int)
        32   -> setup()
        32   -> store_char_usb
        32   -> update_LCD()
        32   -> wifi_writeString(char *)
        32   -> writeString(char *)
       8   print_endstop(uint8_t)
         8   -> writeString(char *)
      16   writeString(char *)
        16   -> USART_GetFlagStatus
        16   -> USART_SendData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      24  ?_0
      24  ?_1
       8  ?_10
      16  ?_11
       8  ?_12
       2  ?_13
      24  ?_2
      24  ?_3
      16  ?_4
      12  ?_5
      20  ?_6
      12  ?_7
       8  ?_8
      20  ?_9
       4  MAGIC
     130  get_endstop()
     532  main
      52  print_endstop(uint8_t)
       1  unlocked
      38  writeString(char *)

 
     1 byte  in section .bss
     4 bytes in section .noinit  (abs)
     2 bytes in section .rodata
 1'044 bytes in section .text
 
 1'044 bytes of CODE  memory
     2 bytes of CONST memory
     1 byte  of DATA  memory (+ 4 bytes shared)

Errors: none
Warnings: 16

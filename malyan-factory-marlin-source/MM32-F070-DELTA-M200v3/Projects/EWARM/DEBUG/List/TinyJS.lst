###############################################################################
#                                                                             #
# IAR ANSI C/C++ Compiler V6.70.1.5641/W32 for ARM      01/May/2017  16:30:37 #
# Copyright 1999-2013 IAR Systems AB.                                         #
#                                                                             #
#    Cpu mode     =  thumb                                                    #
#    Endian       =  little                                                   #
#    Source file  =  D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\src\js\ #
#                    TinyJS.cpp                                               #
#    Command line =  D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\src\js\ #
#                    TinyJS.cpp -D USE_STDPERIPH_DRIVER -D                    #
#                    USE_STM32072B_EVAL -D STM32F072 -lcN                     #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\D #
#                    EBUG\List\ -o D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Pr #
#                    ojects\EWARM\DEBUG\Obj\ --debug --endian=little          #
#                    --cpu=Cortex-M0 -e --fpu=None --dlib_config "C:\Program  #
#                    Files (x86)\IAR Systems\Embedded Workbench               #
#                    6.5\arm\INC\c\DLib_Config_Normal.h" -I                   #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\ -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\E #
#                    WARM\..\inc\ -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\ #
#                    Projects\EWARM\..\src\fs\ -I                             #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\src\js\ -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Pro #
#                    jects\EWARM\..\src\marlin\ -I                            #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\src\rtt\ -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Pr #
#                    ojects\EWARM\..\src\usb\ -I                              #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\ -I     #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\ -I        #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\..\Libraries\STM32_USB_Device_Driver\inc\ -I           #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\..\Libraries\STM32_USB_Device_Library\Core\inc\ -I     #
#                    D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\. #
#                    .\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\   #
#                    -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWAR #
#                    M\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc #
#                    \ -I D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EW #
#                    ARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_m #
#                    sc_wrapper\inc\ -I D:\Projects\3DPrint\SRC\MM32-F070-DEL #
#                    TA\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Libra #
#                    ry\Class\msc\inc\ -Ohz --eec++ --no_static_destruction   #
#                    -I "C:\Program Files (x86)\IAR Systems\Embedded          #
#                    Workbench 6.5\arm\CMSIS\Include\" --relaxed_fp           #
#    List file    =  D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\D #
#                    EBUG\List\TinyJS.lst                                     #
#    Object file  =  D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\EWARM\D #
#                    EBUG\Obj\TinyJS.o                                        #
#                                                                             #
#                                                                             #
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA\Projects\src\js\TinyJS.cpp
      1          /*
      2           * TinyJS
      3           *
      4           * A single-file Javascript-alike engine
      5           *
      6           * Authored By Gordon Williams <gw@pur3.co.uk>
      7           *
      8           * Copyright (C) 2009 Pur3 Ltd
      9           *
     10           * Permission is hereby granted, free of charge, to any person obtaining a copy of
     11           * this software and associated documentation files (the "Software"), to deal in
     12           * the Software without restriction, including without limitation the rights to
     13           * use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
     14           * of the Software, and to permit persons to whom the Software is furnished to do
     15           * so, subject to the following conditions:
     16          
     17           * The above copyright notice and this permission notice shall be included in all
     18           * copies or substantial portions of the Software.
     19          
     20           * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
     21           * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
     22           * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
     23           * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
     24           * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
     25           * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
     26           * SOFTWARE.
     27           */
     28          
     29          /* Version 0.1  :  (gw) First published on Google Code
     30             Version 0.11 :  Making sure the 'root' variable never changes
     31                             'symbol_base' added for the current base of the sybmbol table
     32             Version 0.12 :  Added findChildOrCreate, changed string passing to use references
     33                             Fixed broken string encoding in getJSString()
     34                             Removed getInitCode and added getJSON instead
     35                             Added nil
     36                             Added rough JSON parsing
     37                             Improved example app
     38             Version 0.13 :  Added tokenEnd/tokenLastEnd to lexer to avoid parsing whitespace
     39                             Ability to define functions without names
     40                             Can now do "var mine = function(a,b) { ... };"
     41                             Slightly better 'trace' function
     42                             Added findChildOrCreateByPath function
     43                             Added simple test suite
     44                             Added skipping of blocks when not executing
     45             Version 0.14 :  Added parsing of more number types
     46                             Added parsing of string defined with '
     47                             Changed nil to null as per spec, added 'undefined'
     48                             Now set variables with the correct scope, and treat unknown
     49                                        as 'undefined' rather than failing
     50                             Added proper (I hope) handling of null and undefined
     51                             Added === check
     52             Version 0.15 :  Fix for possible memory leaks
     53             Version 0.16 :  Removal of un-needed findRecursive calls
     54                             symbol_base removed and replaced with 'scopes' stack
     55                             Added reference counting a proper tree structure
     56                                 (Allowing pass by reference)
     57                             Allowed JSON output to output IDs, not strings
     58                             Added get/set for array indices
     59                             Changed Callbacks to include user data pointer
     60                             Added some support for objects
     61                             Added more Java-esque builtin functions
     62             Version 0.17 :  Now we don't deepCopy the parent object of the class
     63                             Added JSON.stringify and eval()
     64                             Nicer JSON indenting
     65                             Fixed function output in JSON
     66                             Added evaluateComplex
     67                             Fixed some reentrancy issues with evaluate/execute
     68             Version 0.18 :  Fixed some issues with code being executed when it shouldn't
     69             Version 0.19 :  Added array.length
     70                             Changed '__parent' to 'prototype' to bring it more in line with javascript
     71             Version 0.20 :  Added '%' operator
     72             Version 0.21 :  Added array type
     73                             String.length() no more - now String.length
     74                             Added extra constructors to reduce confusion
     75                             Fixed checks against undefined
     76             Version 0.22 :  First part of ardi's changes:
     77                                 sprintf -> sprintf_s
     78                                 extra tokens parsed
     79                                 array memory leak fixed
     80                             Fixed memory leak in evaluateComplex
     81                             Fixed memory leak in FOR loops
     82                             Fixed memory leak for unary minus
     83             Version 0.23 :  Allowed evaluate[Complex] to take in semi-colon separated
     84                               statements and then only return the value from the last one.
     85                               Also checks to make sure *everything* was parsed.
     86                             Ints + doubles are now stored in binary form (faster + more precise)
     87             Version 0.24 :  More useful error for maths ops
     88                             Don't dump everything on a match error.
     89             Version 0.25 :  Better string escaping
     90             Version 0.26 :  Add CScriptVar::equals
     91                             Add built-in array functions
     92             Version 0.27 :  Added OZLB's TinyJS.setVariable (with some tweaks)
     93                             Added OZLB's Maths Functions
     94             Version 0.28 :  Ternary operator
     95                             Rudimentary call stack on error
     96                             Added String Character functions
     97                             Added shift operators
     98             Version 0.29 :  Added new object via functions
     99                             Fixed getString() for double on some platforms
    100             Version 0.30 :  Rlyeh Mario's patch for Math Functions on VC++
    101             Version 0.31 :  Add exec() to TinyJS functions
    102                             Now print quoted JSON that can be read by PHP/Python parsers
    103                             Fixed postfix increment operator
    104             Version 0.32 :  Fixed Math.randInt on 32 bit PCs, where it was broken
    105             Version 0.33 :  Fixed Memory leak + brokenness on === comparison
    106          
    107              NOTE:
    108                    Constructing an array with an initial length 'Array(5)' doesn't work
    109                    Recursive loops of data such as a.foo = a; fail to be garbage collected
    110                    length variable cannot be set
    111                    The postfix increment operator returns the current value, not the previous as it should.
    112                    There is no prefix increment operator
    113                    Arrays are implemented as a linked list - hence a lookup time is O(n)
    114          
    115              TODO:
    116                    Utility va-args style function in TinyJS for executing a function directly
    117                    Merge the parsing of expressions/statements so eval("statement") works like we'd expect.
    118                    Move 'shift' implementation into mathsOp
    119          
    120           */
    121          
    122          #include "TinyJS.h"
    123          #include <assert.h>
    124          
    125          #define ASSERT(X) assert(X)
    126          /* Frees the given link IF it isn't owned by anything else */
    127          #define CLEAN(x) { CScriptVarLink *__v = x; if (__v && !__v->owned) { delete __v; } }
    128          /* Create a LINK to point to VAR and free the old link.
    129           * BUT this is more clever - it tries to keep the old link if it's not owned to save allocations */
    130          #define CREATE_LINK(LINK, VAR) { if (!LINK || LINK->owned) LINK = new CScriptVarLink(VAR); else LINK->replaceWith(VAR); }
    131          
    132          #include <string>
    133          //#include <string.h>
    134          #include <sstream>
    135          //#include <cstdlib>
    136          //#include <stdio.h>
    137          
    138          #define vsprintf_s vsnprintf
    139          #define sprintf_s snprintf
    140          #define _strdup strdup
    141          
    142          #ifdef _WIN32
    143          #ifdef _DEBUG
    144             #ifndef DBG_NEW
    145                #define DBG_NEW new ( _NORMAL_BLOCK , __FILE__ , __LINE__ )
    146                #define new DBG_NEW
    147             #endif
    148          #endif
    149          #endif
    150          
    151          #ifdef __GNUC__
    152          #define vsprintf_s vsnprintf
    153          #define sprintf_s snprintf
    154          #define _strdup strdup
    155          #endif
    156          
    157          // ----------------------------------------------------------------------------------- Memory Debug
    158          
    159          int putchar(int c)
    160          {
    161            return c;
    162          }
    163          
    164          #define DEBUG_MEMORY 0
    165          
    166          #if DEBUG_MEMORY
    167          
    168          vector<CScriptVar*> allocatedVars;
    169          vector<CScriptVarLink*> allocatedLinks;
    170          
    171          void mark_allocated(CScriptVar *v) {
    172              allocatedVars.push_back(v);
    173          }
    174          
    175          void mark_deallocated(CScriptVar *v) {
    176              for (size_t i=0;i<allocatedVars.size();i++) {
    177                if (allocatedVars[i] == v) {
    178                  allocatedVars.erase(allocatedVars.begin()+i);
    179                  break;
    180                }
    181              }
    182          }
    183          
    184          void mark_allocated(CScriptVarLink *v) {
    185              allocatedLinks.push_back(v);
    186          }
    187          
    188          void mark_deallocated(CScriptVarLink *v) {
    189              for (size_t i=0;i<allocatedLinks.size();i++) {
    190                if (allocatedLinks[i] == v) {
    191                  allocatedLinks.erase(allocatedLinks.begin()+i);
    192                  break;
    193                }
    194              }
    195          }
    196          
    197          void show_allocated() {
    198              for (size_t i=0;i<allocatedVars.size();i++) {
    199                printf("ALLOCATED, %d refs\n", allocatedVars[i]->getRefs());
    200                allocatedVars[i]->trace("  ");
    201              }
    202              for (size_t i=0;i<allocatedLinks.size();i++) {
    203                printf("ALLOCATED LINK %s, allocated[%d] to \n", allocatedLinks[i]->name.c_str(), allocatedLinks[i]->var->getRefs());
    204                allocatedLinks[i]->var->trace("  ");
    205              }
    206              allocatedVars.clear();
    207              allocatedLinks.clear();
    208          }
    209          #endif
    210          
    211          // ----------------------------------------------------------------------------------- Utils
    212          bool isWhitespace(char ch) {
    213              return (ch==' ') || (ch=='\t') || (ch=='\n') || (ch=='\r');
    214          }
    215          
    216          bool isNumeric(char ch) {
    217              return (ch>='0') && (ch<='9');
    218          }
    219          bool isNumber(const string &str) {
    220              for (size_t i=0;i<str.size();i++)
    221                if (!isNumeric(str[i])) return false;
    222              return true;
    223          }
    224          bool isHexadecimal(char ch) {
    225              return ((ch>='0') && (ch<='9')) ||
    226                     ((ch>='a') && (ch<='f')) ||
    227                     ((ch>='A') && (ch<='F'));
    228          }
    229          bool isAlpha(char ch) {
    230              return ((ch>='a') && (ch<='z')) || ((ch>='A') && (ch<='Z')) || ch=='_';
    231          }
    232          
    233          bool isIDString(const char *s) {
    234              if (!isAlpha(*s))
    235                  return false;
    236              while (*s) {
    237                  if (!(isAlpha(*s) || isNumeric(*s)))
    238                      return false;
    239                  s++;
    240              }
    241              return true;
    242          }
    243          
    244          void replace(string &str, char textFrom, const char *textTo) {
    245              int sLen = strlen(textTo);
    246              size_t p = str.find(textFrom);
    247              while (p != string::npos) {
    248                  str = str.substr(0, p) + textTo + str.substr(p+1);
    249                  p = str.find(textFrom, p+sLen);
    250              }
    251          }
    252          
    253          /// convert the given string into a quoted string suitable for javascript
    254          string getJSString(const string &str) {
    255              string nStr = str;
    256              for (size_t i=0;i<nStr.size();i++) {
    257                const char *replaceWith = "";
    258                bool replace = true;
    259          
    260                switch (nStr[i]) {
    261                  case '\\': replaceWith = "\\\\"; break;
    262                  case '\n': replaceWith = "\\n"; break;
    263                  case '\r': replaceWith = "\\r"; break;
    264                  case '\a': replaceWith = "\\a"; break;
    265                  case '"': replaceWith = "\\\""; break;
    266                  default: {
    267                    int nCh = ((int)nStr[i]) &0xFF;
    268                    if (nCh<32 || nCh>127) {
    269                      char buffer[5];
    270                      sprintf_s(buffer, 5, "\\x%02X", nCh);
    271                      replaceWith = buffer;
    272                    } else replace=false;
    273                  }
    274                }
    275          
    276                if (replace) {
    277                  nStr = nStr.substr(0, i) + replaceWith + nStr.substr(i+1);
    278                  i += strlen(replaceWith)-1;
    279                }
    280              }
    281              return "\"" + nStr + "\"";
    282          }
    283          
    284          /** Is the string alphanumeric */
    285          bool isAlphaNum(const string &str) {
    286              if (str.size()==0) return true;
    287              if (!isAlpha(str[0])) return false;
    288              for (size_t i=0;i<str.size();i++)
    289                if (!(isAlpha(str[i]) || isNumeric(str[i])))
    290                  return false;
    291              return true;
    292          }
    293          
    294          // ----------------------------------------------------------------------------------- CSCRIPTEXCEPTION
    295          
    296          CScriptException::CScriptException(const string &exceptionText) {
    297              text = exceptionText;
    298          }
    299          
    300          // ----------------------------------------------------------------------------------- CSCRIPTLEX
    301          
    302          CScriptLex::CScriptLex(const string &input) {
    303              data = _strdup(input.c_str());
    304              dataOwned = true;
    305              dataStart = 0;
    306              dataEnd = strlen(data);
    307              reset();
    308          }
    309          
    310          CScriptLex::CScriptLex(CScriptLex *owner, int startChar, int endChar) {
    311              data = owner->data;
    312              dataOwned = false;
    313              dataStart = startChar;
    314              dataEnd = endChar;
    315              reset();
    316          }
    317          
    318          CScriptLex::~CScriptLex(void)
    319          {
    320              if (dataOwned)
    321                  free((void*)data);
    322          }
    323          
    324          void CScriptLex::reset() {
    325              dataPos = dataStart;
    326              tokenStart = 0;
    327              tokenEnd = 0;
    328              tokenLastEnd = 0;
    329              tk = 0;
    330              tkStr = "";
    331              getNextCh();
    332              getNextCh();
    333              getNextToken();
    334          }
    335          
    336          void CScriptLex::match(int expected_tk) {
    337              if (tk!=expected_tk) {
    338                  ostringstream errorString;
    339                  errorString << "Got " << getTokenStr(tk) << " expected " << getTokenStr(expected_tk)
    340                   << " at " << getPosition(tokenStart);
    341                  /*throw*/ new CScriptException(errorString.str());
    342              }
    343              getNextToken();
    344          }
    345          
    346          string CScriptLex::getTokenStr(int token) {
    347              if (token>32 && token<128) {
    348                  char buf[4] = "' '";
    349                  buf[1] = (char)token;
    350                  return buf;
    351              }
    352              switch (token) {
    353                  case LEX_EOF : return "EOF";
    354                  case LEX_ID : return "ID";
    355                  case LEX_INT : return "INT";
    356                  case LEX_FLOAT : return "FLOAT";
    357                  case LEX_STR : return "STRING";
    358                  case LEX_EQUAL : return "==";
    359                  case LEX_TYPEEQUAL : return "===";
    360                  case LEX_NEQUAL : return "!=";
    361                  case LEX_NTYPEEQUAL : return "!==";
    362                  case LEX_LEQUAL : return "<=";
    363                  case LEX_LSHIFT : return "<<";
    364                  case LEX_LSHIFTEQUAL : return "<<=";
    365                  case LEX_GEQUAL : return ">=";
    366                  case LEX_RSHIFT : return ">>";
    367                  case LEX_RSHIFTUNSIGNED : return ">>";
    368                  case LEX_RSHIFTEQUAL : return ">>=";
    369                  case LEX_PLUSEQUAL : return "+=";
    370                  case LEX_MINUSEQUAL : return "-=";
    371                  case LEX_PLUSPLUS : return "++";
    372                  case LEX_MINUSMINUS : return "--";
    373                  case LEX_ANDEQUAL : return "&=";
    374                  case LEX_ANDAND : return "&&";
    375                  case LEX_OREQUAL : return "|=";
    376                  case LEX_OROR : return "||";
    377                  case LEX_XOREQUAL : return "^=";
    378                          // reserved words
    379                  case LEX_R_IF : return "if";
    380                  case LEX_R_ELSE : return "else";
    381                  case LEX_R_DO : return "do";
    382                  case LEX_R_WHILE : return "while";
    383                  case LEX_R_FOR : return "for";
    384                  case LEX_R_BREAK : return "break";
    385                  case LEX_R_CONTINUE : return "continue";
    386                  case LEX_R_FUNCTION : return "function";
    387                  case LEX_R_RETURN : return "return";
    388                  case LEX_R_VAR : return "var";
    389                  case LEX_R_TRUE : return "true";
    390                  case LEX_R_FALSE : return "false";
    391                  case LEX_R_NULL : return "null";
    392                  case LEX_R_UNDEFINED : return "undefined";
    393                  case LEX_R_NEW : return "new";
    394              }
    395          
    396              ostringstream msg;
    397              msg << "?[" << token << "]";
    398              return msg.str();
    399          }
    400          
    401          void CScriptLex::getNextCh() {
    402              currCh = nextCh;
    403              if (dataPos < dataEnd)
    404                  nextCh = data[dataPos];
    405              else
    406                  nextCh = 0;
    407              dataPos++;
    408          }
    409          
    410          void CScriptLex::getNextToken() {
    411              tk = LEX_EOF;
    412              tkStr.clear();
    413              while (currCh && isWhitespace(currCh)) getNextCh();
    414              // newline comments
    415              if (currCh=='/' && nextCh=='/') {
    416                  while (currCh && currCh!='\n') getNextCh();
    417                  getNextCh();
    418                  getNextToken();
    419                  return;
    420              }
    421              // block comments
    422              if (currCh=='/' && nextCh=='*') {
    423                  while (currCh && (currCh!='*' || nextCh!='/')) getNextCh();
    424                  getNextCh();
    425                  getNextCh();
    426                  getNextToken();
    427                  return;
    428              }
    429              // record beginning of this token
    430              tokenStart = dataPos-2;
    431              // tokens
    432              if (isAlpha(currCh)) { //  IDs
    433                  while (isAlpha(currCh) || isNumeric(currCh)) {
    434                      tkStr += currCh;
    435                      getNextCh();
    436                  }
    437                  tk = LEX_ID;
    438                       if (tkStr=="if") tk = LEX_R_IF;
    439                  else if (tkStr=="else") tk = LEX_R_ELSE;
    440                  else if (tkStr=="do") tk = LEX_R_DO;
    441                  else if (tkStr=="while") tk = LEX_R_WHILE;
    442                  else if (tkStr=="for") tk = LEX_R_FOR;
    443                  else if (tkStr=="break") tk = LEX_R_BREAK;
    444                  else if (tkStr=="continue") tk = LEX_R_CONTINUE;
    445                  else if (tkStr=="function") tk = LEX_R_FUNCTION;
    446                  else if (tkStr=="return") tk = LEX_R_RETURN;
    447                  else if (tkStr=="var") tk = LEX_R_VAR;
    448                  else if (tkStr=="true") tk = LEX_R_TRUE;
    449                  else if (tkStr=="false") tk = LEX_R_FALSE;
    450                  else if (tkStr=="null") tk = LEX_R_NULL;
    451                  else if (tkStr=="undefined") tk = LEX_R_UNDEFINED;
    452                  else if (tkStr=="new") tk = LEX_R_NEW;
    453              } else if (isNumeric(currCh)) { // Numbers
    454                  bool isHex = false;
    455                  if (currCh=='0') { tkStr += currCh; getNextCh(); }
    456                  if (currCh=='x') {
    457                    isHex = true;
    458                    tkStr += currCh; getNextCh();
    459                  }
    460                  tk = LEX_INT;
    461                  while (isNumeric(currCh) || (isHex && isHexadecimal(currCh))) {
    462                      tkStr += currCh;
    463                      getNextCh();
    464                  }
    465                  if (!isHex && currCh=='.') {
    466                      tk = LEX_FLOAT;
    467                      tkStr += '.';
    468                      getNextCh();
    469                      while (isNumeric(currCh)) {
    470                          tkStr += currCh;
    471                          getNextCh();
    472                      }
    473                  }
    474                  // do fancy e-style floating point
    475                  if (!isHex && (currCh=='e'||currCh=='E')) {
    476                    tk = LEX_FLOAT;
    477                    tkStr += currCh; getNextCh();
    478                    if (currCh=='-') { tkStr += currCh; getNextCh(); }
    479                    while (isNumeric(currCh)) {
    480                       tkStr += currCh; getNextCh();
    481                    }
    482                  }
    483              } else if (currCh=='"') {
    484                  // strings...
    485                  getNextCh();
    486                  while (currCh && currCh!='"') {
    487                      if (currCh == '\\') {
    488                          getNextCh();
    489                          switch (currCh) {
    490                          case 'n' : tkStr += '\n'; break;
    491                          case '"' : tkStr += '"'; break;
    492                          case '\\' : tkStr += '\\'; break;
    493                          default: tkStr += currCh;
    494                          }
    495                      } else {
    496                          tkStr += currCh;
    497                      }
    498                      getNextCh();
    499                  }
    500                  getNextCh();
    501                  tk = LEX_STR;
    502              } else if (currCh=='\'') {
    503                  // strings again...
    504                  getNextCh();
    505                  while (currCh && currCh!='\'') {
    506                      if (currCh == '\\') {
    507                          getNextCh();
    508                          switch (currCh) {
    509                          case 'n' : tkStr += '\n'; break;
    510                          case 'a' : tkStr += '\a'; break;
    511                          case 'r' : tkStr += '\r'; break;
    512                          case 't' : tkStr += '\t'; break;
    513                          case '\'' : tkStr += '\''; break;
    514                          case '\\' : tkStr += '\\'; break;
    515                          case 'x' : { // hex digits
    516                                        char buf[3] = "??";
    517                                        getNextCh(); buf[0] = currCh;
    518                                        getNextCh(); buf[1] = currCh;
    519                                        tkStr += (char)strtol(buf,0,16);
    520                                     } break;
    521                          default: if (currCh>='0' && currCh<='7') {
    522                                     // octal digits
    523                                     char buf[4] = "???";
    524                                     buf[0] = currCh;
    525                                     getNextCh(); buf[1] = currCh;
    526                                     getNextCh(); buf[2] = currCh;
    527                                     tkStr += (char)strtol(buf,0,8);
    528                                   } else
    529                                     tkStr += currCh;
    530                          }
    531                      } else {
    532                          tkStr += currCh;
    533                      }
    534                      getNextCh();
    535                  }
    536                  getNextCh();
    537                  tk = LEX_STR;
    538              } else {
    539                  // single chars
    540                  tk = currCh;
    541                  if (currCh) getNextCh();
    542                  if (tk=='=' && currCh=='=') { // ==
    543                      tk = LEX_EQUAL;
    544                      getNextCh();
    545                      if (currCh=='=') { // ===
    546                        tk = LEX_TYPEEQUAL;
    547                        getNextCh();
    548                      }
    549                  } else if (tk=='!' && currCh=='=') { // !=
    550                      tk = LEX_NEQUAL;
    551                      getNextCh();
    552                      if (currCh=='=') { // !==
    553                        tk = LEX_NTYPEEQUAL;
    554                        getNextCh();
    555                      }
    556                  } else if (tk=='<' && currCh=='=') {
    557                      tk = LEX_LEQUAL;
    558                      getNextCh();
    559                  } else if (tk=='<' && currCh=='<') {
    560                      tk = LEX_LSHIFT;
    561                      getNextCh();
    562                      if (currCh=='=') { // <<=
    563                        tk = LEX_LSHIFTEQUAL;
    564                        getNextCh();
    565                      }
    566                  } else if (tk=='>' && currCh=='=') {
    567                      tk = LEX_GEQUAL;
    568                      getNextCh();
    569                  } else if (tk=='>' && currCh=='>') {
    570                      tk = LEX_RSHIFT;
    571                      getNextCh();
    572                      if (currCh=='=') { // >>=
    573                        tk = LEX_RSHIFTEQUAL;
    574                        getNextCh();
    575                      } else if (currCh=='>') { // >>>
    576                        tk = LEX_RSHIFTUNSIGNED;
    577                        getNextCh();
    578                      }
    579                  }  else if (tk=='+' && currCh=='=') {
    580                      tk = LEX_PLUSEQUAL;
    581                      getNextCh();
    582                  }  else if (tk=='-' && currCh=='=') {
    583                      tk = LEX_MINUSEQUAL;
    584                      getNextCh();
    585                  }  else if (tk=='+' && currCh=='+') {
    586                      tk = LEX_PLUSPLUS;
    587                      getNextCh();
    588                  }  else if (tk=='-' && currCh=='-') {
    589                      tk = LEX_MINUSMINUS;
    590                      getNextCh();
    591                  } else if (tk=='&' && currCh=='=') {
    592                      tk = LEX_ANDEQUAL;
    593                      getNextCh();
    594                  } else if (tk=='&' && currCh=='&') {
    595                      tk = LEX_ANDAND;
    596                      getNextCh();
    597                  } else if (tk=='|' && currCh=='=') {
    598                      tk = LEX_OREQUAL;
    599                      getNextCh();
    600                  } else if (tk=='|' && currCh=='|') {
    601                      tk = LEX_OROR;
    602                      getNextCh();
    603                  } else if (tk=='^' && currCh=='=') {
    604                      tk = LEX_XOREQUAL;
    605                      getNextCh();
    606                  }
    607              }
    608              /* This isn't quite right yet */
    609              tokenLastEnd = tokenEnd;
    610              tokenEnd = dataPos-3;
    611          }
    612          
    613          string CScriptLex::getSubString(int lastPosition) {
    614              int lastCharIdx = tokenLastEnd+1;
    615              if (lastCharIdx < dataEnd) {
    616                  /* save a memory alloc by using our data array to create the
    617                     substring */
    618                  char old = data[lastCharIdx];
    619                  data[lastCharIdx] = 0;
    620                  string value = &data[lastPosition];
    621                  data[lastCharIdx] = old;
    622                  return value;
    623              } else {
    624                  return string(&data[lastPosition]);
    625              }
    626          }
    627          
    628          
    629          CScriptLex *CScriptLex::getSubLex(int lastPosition) {
    630              int lastCharIdx = tokenLastEnd+1;
    631              if (lastCharIdx < dataEnd)
    632                  return new CScriptLex(this, lastPosition, lastCharIdx);
    633              else
    634                  return new CScriptLex(this, lastPosition, dataEnd );
    635          }
    636          
    637          string CScriptLex::getPosition(int pos) {
    638              if (pos<0) pos=tokenLastEnd;
    639              int line = 1,col = 1;
    640              for (int i=0;i<pos;i++) {
    641                  char ch;
    642                  if (i < dataEnd)
    643                      ch = data[i];
    644                  else
    645                      ch = 0;
    646                  col++;
    647                  if (ch=='\n') {
    648                      line++;
    649                      col = 0;
    650                  }
    651              }
    652              char buf[256];
    653              sprintf_s(buf, 256, "(line: %d, col: %d)", line, col);
    654              return buf;
    655          }
    656          
    657          // ----------------------------------------------------------------------------------- CSCRIPTVARLINK
    658          
    659          CScriptVarLink::CScriptVarLink(CScriptVar *var, const string &name) {
    660          #if DEBUG_MEMORY
    661              mark_allocated(this);
    662          #endif
    663              this->name = name;
    664              this->nextSibling = 0;
    665              this->prevSibling = 0;
    666              this->var = var->ref();
    667              this->owned = false;
    668          }
    669          
    670          CScriptVarLink::CScriptVarLink(const CScriptVarLink &link) {
    671              // Copy constructor
    672          #if DEBUG_MEMORY
    673              mark_allocated(this);
    674          #endif
    675              this->name = link.name;
    676              this->nextSibling = 0;
    677              this->prevSibling = 0;
    678              this->var = link.var->ref();
    679              this->owned = false;
    680          }
    681          
    682          CScriptVarLink::~CScriptVarLink() {
    683          #if DEBUG_MEMORY
    684              mark_deallocated(this);
    685          #endif
    686              var->unref();
    687          }
    688          
    689          void CScriptVarLink::replaceWith(CScriptVar *newVar) {
    690              CScriptVar *oldVar = var;
    691              var = newVar->ref();
    692              oldVar->unref();
    693          }
    694          
    695          void CScriptVarLink::replaceWith(CScriptVarLink *newVar) {
    696              if (newVar)
    697                replaceWith(newVar->var);
    698              else
    699                replaceWith(new CScriptVar());
    700          }
    701          
    702          int CScriptVarLink::getIntName() {
    703              return atoi(name.c_str());
    704          }
    705          void CScriptVarLink::setIntName(int n) {
    706              char sIdx[64];
    707              sprintf_s(sIdx, sizeof(sIdx), "%d", n);
    708              name = sIdx;
    709          }
    710          
    711          // ----------------------------------------------------------------------------------- CSCRIPTVAR
    712          
    713          CScriptVar::CScriptVar() {
    714              refs = 0;
    715          #if DEBUG_MEMORY
    716              mark_allocated(this);
    717          #endif
    718              init();
    719              flags = SCRIPTVAR_UNDEFINED;
    720          }
    721          
    722          CScriptVar::CScriptVar(const string &str) {
    723              refs = 0;
    724          #if DEBUG_MEMORY
    725              mark_allocated(this);
    726          #endif
    727              init();
    728              flags = SCRIPTVAR_STRING;
    729              data = str;
    730          }
    731          
    732          
    733          CScriptVar::CScriptVar(const string &varData, int varFlags) {
    734              refs = 0;
    735          #if DEBUG_MEMORY
    736              mark_allocated(this);
    737          #endif
    738              init();
    739              flags = varFlags;
    740              if (varFlags & SCRIPTVAR_INTEGER) {
    741                intData = strtol(varData.c_str(),0,0);
    742              } else if (varFlags & SCRIPTVAR_DOUBLE) {
    743                doubleData = strtod(varData.c_str(),0);
    744              } else
    745                data = varData;
    746          }
    747          
    748          CScriptVar::CScriptVar(double val) {
    749              refs = 0;
    750          #if DEBUG_MEMORY
    751              mark_allocated(this);
    752          #endif
    753              init();
    754              setDouble(val);
    755          }
    756          
    757          CScriptVar::CScriptVar(int val) {
    758              refs = 0;
    759          #if DEBUG_MEMORY
    760              mark_allocated(this);
    761          #endif
    762              init();
    763              setInt(val);
    764          }
    765          
    766          CScriptVar::~CScriptVar(void) {
    767          #if DEBUG_MEMORY
    768              mark_deallocated(this);
    769          #endif
    770              removeAllChildren();
    771          }
    772          
    773          void CScriptVar::init() {
    774              firstChild = 0;
    775              lastChild = 0;
    776              flags = 0;
    777              jsCallback = 0;
    778              jsCallbackUserData = 0;
    779              data = TINYJS_BLANK_DATA;
    780              intData = 0;
    781              doubleData = 0;
    782          }
    783          
    784          CScriptVar *CScriptVar::getReturnVar() {
    785              return getParameter(TINYJS_RETURN_VAR);
    786          }
    787          
    788          void CScriptVar::setReturnVar(CScriptVar *var) {
    789              findChildOrCreate(TINYJS_RETURN_VAR)->replaceWith(var);
    790          }
    791          
    792          
    793          CScriptVar *CScriptVar::getParameter(const string &name) {
    794              return findChildOrCreate(name)->var;
    795          }
    796          
    797          CScriptVarLink *CScriptVar::findChild(const string &childName) {
    798              CScriptVarLink *v = firstChild;
    799              while (v) {
    800                  if (v->name.compare(childName)==0)
    801                      return v;
    802                  v = v->nextSibling;
    803              }
    804              return 0;
    805          }
    806          
    807          CScriptVarLink *CScriptVar::findChildOrCreate(const string &childName, int varFlags) {
    808              CScriptVarLink *l = findChild(childName);
    809              if (l) return l;
    810          
    811              return addChild(childName, new CScriptVar(TINYJS_BLANK_DATA, varFlags));
    812          }
    813          
    814          CScriptVarLink *CScriptVar::findChildOrCreateByPath(const string &path) {
    815            size_t p = path.find('.');
    816            if (p == string::npos)
    817              return findChildOrCreate(path);
    818          
    819            return findChildOrCreate(path.substr(0,p), SCRIPTVAR_OBJECT)->var->
    820                      findChildOrCreateByPath(path.substr(p+1));
    821          }
    822          
    823          CScriptVarLink *CScriptVar::addChild(const string &childName, CScriptVar *child) {
    824            if (isUndefined()) {
    825              flags = SCRIPTVAR_OBJECT;
    826            }
    827              // if no child supplied, create one
    828              if (!child)
    829                child = new CScriptVar();
    830          
    831              CScriptVarLink *link = new CScriptVarLink(child, childName);
    832              link->owned = true;
    833              if (lastChild) {
    834                  lastChild->nextSibling = link;
    835                  link->prevSibling = lastChild;
    836                  lastChild = link;
    837              } else {
    838                  firstChild = link;
    839                  lastChild = link;
    840              }
    841              return link;
    842          }
    843          
    844          CScriptVarLink *CScriptVar::addChildNoDup(const string &childName, CScriptVar *child) {
    845              // if no child supplied, create one
    846              if (!child)
    847                child = new CScriptVar();
    848          
    849              CScriptVarLink *v = findChild(childName);
    850              if (v) {
    851                  v->replaceWith(child);
    852              } else {
    853                  v = addChild(childName, child);
    854              }
    855          
    856              return v;
    857          }
    858          
    859          void CScriptVar::removeChild(CScriptVar *child) {
    860              CScriptVarLink *link = firstChild;
    861              while (link) {
    862                  if (link->var == child)
    863                      break;
    864                  link = link->nextSibling;
    865              }
    866              ASSERT(link);
    867              removeLink(link);
    868          }
    869          
    870          void CScriptVar::removeLink(CScriptVarLink *link) {
    871              if (!link) return;
    872              if (link->nextSibling)
    873                link->nextSibling->prevSibling = link->prevSibling;
    874              if (link->prevSibling)
    875                link->prevSibling->nextSibling = link->nextSibling;
    876              if (lastChild == link)
    877                  lastChild = link->prevSibling;
    878              if (firstChild == link)
    879                  firstChild = link->nextSibling;
    880              delete link;
    881          }
    882          
    883          void CScriptVar::removeAllChildren() {
    884              CScriptVarLink *c = firstChild;
    885              while (c) {
    886                  CScriptVarLink *t = c->nextSibling;
    887                  delete c;
    888                  c = t;
    889              }
    890              firstChild = 0;
    891              lastChild = 0;
    892          }
    893          
    894          CScriptVar *CScriptVar::getArrayIndex(int idx) {
    895              char sIdx[64];
    896              sprintf_s(sIdx, sizeof(sIdx), "%d", idx);
    897              CScriptVarLink *link = findChild(sIdx);
    898              if (link) return link->var;
    899              else return new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_NULL); // undefined
    900          }
    901          
    902          void CScriptVar::setArrayIndex(int idx, CScriptVar *value) {
    903              char sIdx[64];
    904              sprintf_s(sIdx, sizeof(sIdx), "%d", idx);
    905              CScriptVarLink *link = findChild(sIdx);
    906          
    907              if (link) {
    908                if (value->isUndefined())
    909                  removeLink(link);
    910                else
    911                  link->replaceWith(value);
    912              } else {
    913                if (!value->isUndefined())
    914                  addChild(sIdx, value);
    915              }
    916          }
    917          
    918          int CScriptVar::getArrayLength() {
    919              int highest = -1;
    920              if (!isArray()) return 0;
    921          
    922              CScriptVarLink *link = firstChild;
    923              while (link) {
    924                if (isNumber(link->name)) {
    925                  int val = atoi(link->name.c_str());
    926                  if (val > highest) highest = val;
    927                }
    928                link = link->nextSibling;
    929              }
    930              return highest+1;
    931          }
    932          
    933          int CScriptVar::getChildren() {
    934              int n = 0;
    935              CScriptVarLink *link = firstChild;
    936              while (link) {
    937                n++;
    938                link = link->nextSibling;
    939              }
    940              return n;
    941          }
    942          
    943          int CScriptVar::getInt() {
    944              /* strtol understands about hex and octal */
    945              if (isInt()) return intData;
    946              if (isNull()) return 0;
    947              if (isUndefined()) return 0;
    948              if (isDouble()) return (int)doubleData;
    949              return 0;
    950          }
    951          
    952          double CScriptVar::getDouble() {
    953              if (isDouble()) return doubleData;
    954              if (isInt()) return intData;
    955              if (isNull()) return 0;
    956              if (isUndefined()) return 0;
    957              return 0; /* or NaN? */
    958          }
    959          
    960          const string &CScriptVar::getString() {
    961              /* Because we can't return a string that is generated on demand.
    962               * I should really just use char* :) */
    963              static string s_null = "null";
    964              static string s_undefined = "undefined";
    965              if (isInt()) {
    966                char buffer[32];
    967                sprintf_s(buffer, sizeof(buffer), "%ld", intData);
    968                data = buffer;
    969                return data;
    970              }
    971              if (isDouble()) {
    972                char buffer[32];
    973                sprintf_s(buffer, sizeof(buffer), "%f", doubleData);
    974                data = buffer;
    975                return data;
    976              }
    977              if (isNull()) return s_null;
    978              if (isUndefined()) return s_undefined;
    979              // are we just a string here?
    980              return data;
    981          }
    982          
    983          void CScriptVar::setInt(int val) {
    984              flags = (flags&~SCRIPTVAR_VARTYPEMASK) | SCRIPTVAR_INTEGER;
    985              intData = val;
    986              doubleData = 0;
    987              data = TINYJS_BLANK_DATA;
    988          }
    989          
    990          void CScriptVar::setDouble(double val) {
    991              flags = (flags&~SCRIPTVAR_VARTYPEMASK) | SCRIPTVAR_DOUBLE;
    992              doubleData = val;
    993              intData = 0;
    994              data = TINYJS_BLANK_DATA;
    995          }
    996          
    997          void CScriptVar::setString(const string &str) {
    998              // name sure it's not still a number or integer
    999              flags = (flags&~SCRIPTVAR_VARTYPEMASK) | SCRIPTVAR_STRING;
   1000              data = str;
   1001              intData = 0;
   1002              doubleData = 0;
   1003          }
   1004          
   1005          void CScriptVar::setUndefined() {
   1006              // name sure it's not still a number or integer
   1007              flags = (flags&~SCRIPTVAR_VARTYPEMASK) | SCRIPTVAR_UNDEFINED;
   1008              data = TINYJS_BLANK_DATA;
   1009              intData = 0;
   1010              doubleData = 0;
   1011              removeAllChildren();
   1012          }
   1013          
   1014          void CScriptVar::setArray() {
   1015              // name sure it's not still a number or integer
   1016              flags = (flags&~SCRIPTVAR_VARTYPEMASK) | SCRIPTVAR_ARRAY;
   1017              data = TINYJS_BLANK_DATA;
   1018              intData = 0;
   1019              doubleData = 0;
   1020              removeAllChildren();
   1021          }
   1022          
   1023          bool CScriptVar::equals(CScriptVar *v) {
   1024              CScriptVar *resV = mathsOp(v, LEX_EQUAL);
   1025              bool res = resV->getBool();
   1026              delete resV;
   1027              return res;
   1028          }
   1029          
   1030          CScriptVar *CScriptVar::mathsOp(CScriptVar *b, int op) {
   1031              CScriptVar *a = this;
   1032              // Type equality check
   1033              if (op == LEX_TYPEEQUAL || op == LEX_NTYPEEQUAL) {
   1034                // check type first, then call again to check data
   1035                bool eql = ((a->flags & SCRIPTVAR_VARTYPEMASK) ==
   1036                            (b->flags & SCRIPTVAR_VARTYPEMASK));
   1037                if (eql) {
   1038                  CScriptVar *contents = a->mathsOp(b, LEX_EQUAL);
   1039                  if (!contents->getBool()) eql = false;
   1040                  if (!contents->refs) delete contents;
   1041                }
   1042                           ;
   1043                if (op == LEX_TYPEEQUAL)
   1044                  return new CScriptVar(eql);
   1045                else
   1046                  return new CScriptVar(!eql);
   1047              }
   1048              // do maths...
   1049              if (a->isUndefined() && b->isUndefined()) {
   1050                if (op == LEX_EQUAL) return new CScriptVar(true);
   1051                else if (op == LEX_NEQUAL) return new CScriptVar(false);
   1052                else return new CScriptVar(); // undefined
   1053              } else if ((a->isNumeric() || a->isUndefined()) &&
   1054                         (b->isNumeric() || b->isUndefined())) {
   1055                  if (!a->isDouble() && !b->isDouble()) {
   1056                      // use ints
   1057                      int da = a->getInt();
   1058                      int db = b->getInt();
   1059                      switch (op) {
   1060                          case '+': return new CScriptVar(da+db);
   1061                          case '-': return new CScriptVar(da-db);
   1062                          case '*': return new CScriptVar(da*db);
   1063                          case '/': return new CScriptVar(da/db);
   1064                          case '&': return new CScriptVar(da&db);
   1065                          case '|': return new CScriptVar(da|db);
   1066                          case '^': return new CScriptVar(da^db);
   1067                          case '%': return new CScriptVar(da%db);
   1068                          case LEX_EQUAL:     return new CScriptVar(da==db);
   1069                          case LEX_NEQUAL:    return new CScriptVar(da!=db);
   1070                          case '<':     return new CScriptVar(da<db);
   1071                          case LEX_LEQUAL:    return new CScriptVar(da<=db);
   1072                          case '>':     return new CScriptVar(da>db);
   1073                          case LEX_GEQUAL:    return new CScriptVar(da>=db);
   1074                          default: /*throw*/ new CScriptException("Operation "+CScriptLex::getTokenStr(op)+" not supported on the Int datatype");
   1075                      }
   1076                  } else {
   1077                      // use doubles
   1078                      double da = a->getDouble();
   1079                      double db = b->getDouble();
   1080                      switch (op) {
   1081                          case '+': return new CScriptVar(da+db);
   1082                          case '-': return new CScriptVar(da-db);
   1083                          case '*': return new CScriptVar(da*db);
   1084                          case '/': return new CScriptVar(da/db);
   1085                          case LEX_EQUAL:     return new CScriptVar(da==db);
   1086                          case LEX_NEQUAL:    return new CScriptVar(da!=db);
   1087                          case '<':     return new CScriptVar(da<db);
   1088                          case LEX_LEQUAL:    return new CScriptVar(da<=db);
   1089                          case '>':     return new CScriptVar(da>db);
   1090                          case LEX_GEQUAL:    return new CScriptVar(da>=db);
   1091                          default: /*throw*/ new CScriptException("Operation "+CScriptLex::getTokenStr(op)+" not supported on the Double datatype");
   1092                      }
   1093                  }
   1094              } else if (a->isArray()) {
   1095                /* Just check pointers */
   1096                switch (op) {
   1097                     case LEX_EQUAL: return new CScriptVar(a==b);
   1098                     case LEX_NEQUAL: return new CScriptVar(a!=b);
   1099                     default: /*throw*/ new CScriptException("Operation "+CScriptLex::getTokenStr(op)+" not supported on the Array datatype");
   1100                }
   1101              } else if (a->isObject()) {
   1102                    /* Just check pointers */
   1103                    switch (op) {
   1104                         case LEX_EQUAL: return new CScriptVar(a==b);
   1105                         case LEX_NEQUAL: return new CScriptVar(a!=b);
   1106                         default: /*throw*/ new CScriptException("Operation "+CScriptLex::getTokenStr(op)+" not supported on the Object datatype");
   1107                    }
   1108              } else {
   1109                 string da = a->getString();
   1110                 string db = b->getString();
   1111                 // use strings
   1112                 switch (op) {
   1113                     case '+':           return new CScriptVar(da+db, SCRIPTVAR_STRING);
   1114                     case LEX_EQUAL:     return new CScriptVar(da==db);
   1115                     case LEX_NEQUAL:    return new CScriptVar(da!=db);
   1116                     case '<':     return new CScriptVar(da<db);
   1117                     case LEX_LEQUAL:    return new CScriptVar(da<=db);
   1118                     case '>':     return new CScriptVar(da>db);
   1119                     case LEX_GEQUAL:    return new CScriptVar(da>=db);
   1120                     default: /*throw*/ new CScriptException("Operation "+CScriptLex::getTokenStr(op)+" not supported on the string datatype");
   1121                 }
   1122              }
   1123              ASSERT(0);
   1124              return 0;
   1125          }
   1126          
   1127          void CScriptVar::copySimpleData(CScriptVar *val) {
   1128              data = val->data;
   1129              intData = val->intData;
   1130              doubleData = val->doubleData;
   1131              flags = (flags & ~SCRIPTVAR_VARTYPEMASK) | (val->flags & SCRIPTVAR_VARTYPEMASK);
   1132          }
   1133          
   1134          void CScriptVar::copyValue(CScriptVar *val) {
   1135              if (val) {
   1136                copySimpleData(val);
   1137                // remove all current children
   1138                removeAllChildren();
   1139                // copy children of 'val'
   1140                CScriptVarLink *child = val->firstChild;
   1141                while (child) {
   1142                  CScriptVar *copied;
   1143                  // don't copy the 'parent' object...
   1144                  if (child->name != TINYJS_PROTOTYPE_CLASS)
   1145                    copied = child->var->deepCopy();
   1146                  else
   1147                    copied = child->var;
   1148          
   1149                  addChild(child->name, copied);
   1150          
   1151                  child = child->nextSibling;
   1152                }
   1153              } else {
   1154                setUndefined();
   1155              }
   1156          }
   1157          
   1158          CScriptVar *CScriptVar::deepCopy() {
   1159              CScriptVar *newVar = new CScriptVar();
   1160              newVar->copySimpleData(this);
   1161              // copy children
   1162              CScriptVarLink *child = firstChild;
   1163              while (child) {
   1164                  CScriptVar *copied;
   1165                  // don't copy the 'parent' object...
   1166                  if (child->name != TINYJS_PROTOTYPE_CLASS)
   1167                    copied = child->var->deepCopy();
   1168                  else
   1169                    copied = child->var;
   1170          
   1171                  newVar->addChild(child->name, copied);
   1172                  child = child->nextSibling;
   1173              }
   1174              return newVar;
   1175          }
   1176          
   1177          void CScriptVar::trace(string indentStr, const string &name) {
   1178              TRACE("%s'%s' = '%s' %s\n",
   1179                  indentStr.c_str(),
   1180                  name.c_str(),
   1181                  getString().c_str(),
   1182                  getFlagsAsString().c_str());
   1183              string indent = indentStr+" ";
   1184              CScriptVarLink *link = firstChild;
   1185              while (link) {
   1186                link->var->trace(indent, link->name);
   1187                link = link->nextSibling;
   1188              }
   1189          }
   1190          
   1191          string CScriptVar::getFlagsAsString() {
   1192            string flagstr = "";
   1193            if (flags&SCRIPTVAR_FUNCTION) flagstr = flagstr + "FUNCTION ";
   1194            if (flags&SCRIPTVAR_OBJECT) flagstr = flagstr + "OBJECT ";
   1195            if (flags&SCRIPTVAR_ARRAY) flagstr = flagstr + "ARRAY ";
   1196            if (flags&SCRIPTVAR_NATIVE) flagstr = flagstr + "NATIVE ";
   1197            if (flags&SCRIPTVAR_DOUBLE) flagstr = flagstr + "DOUBLE ";
   1198            if (flags&SCRIPTVAR_INTEGER) flagstr = flagstr + "INTEGER ";
   1199            if (flags&SCRIPTVAR_STRING) flagstr = flagstr + "STRING ";
   1200            return flagstr;
   1201          }
   1202          
   1203          string CScriptVar::getParsableString() {
   1204            // Numbers can just be put in directly
   1205            if (isNumeric())
   1206              return getString();
   1207            if (isFunction()) {
   1208              ostringstream funcStr;
   1209              funcStr << "function (";
   1210              // get list of parameters
   1211              CScriptVarLink *link = firstChild;
   1212              while (link) {
   1213                funcStr << link->name;
   1214                if (link->nextSibling) funcStr << ",";
   1215                link = link->nextSibling;
   1216              }
   1217              // add function body
   1218              funcStr << ") " << getString();
   1219              return funcStr.str();
   1220            }
   1221            // if it is a string then we quote it
   1222            if (isString())
   1223              return getJSString(getString());
   1224            if (isNull())
   1225                return "null";
   1226            return "undefined";
   1227          }
   1228          
   1229          void CScriptVar::getJSON(ostringstream &destination, const string linePrefix) {
   1230             if (isObject()) {
   1231                string indentedLinePrefix = linePrefix+"  ";
   1232                // children - handle with bracketed list
   1233                destination << "{ \n";
   1234                CScriptVarLink *link = firstChild;
   1235                while (link) {
   1236                  destination << indentedLinePrefix;
   1237                  destination  << getJSString(link->name);
   1238                  destination  << " : ";
   1239                  link->var->getJSON(destination, indentedLinePrefix);
   1240                  link = link->nextSibling;
   1241                  if (link) {
   1242                    destination  << ",\n";
   1243                  }
   1244                }
   1245                destination << "\n" << linePrefix << "}";
   1246              } else if (isArray()) {
   1247                string indentedLinePrefix = linePrefix+"  ";
   1248                destination << "[\n";
   1249                int len = getArrayLength();
   1250                if (len>10000) len=10000; // we don't want to get stuck here!
   1251          
   1252                for (int i=0;i<len;i++) {
   1253                  getArrayIndex(i)->getJSON(destination, indentedLinePrefix);
   1254                  if (i<len-1) destination  << ",\n";
   1255                }
   1256          
   1257                destination << "\n" << linePrefix << "]";
   1258              } else {
   1259                // no children or a function... just write value directly
   1260                destination << getParsableString();
   1261              }
   1262          }
   1263          
   1264          
   1265          void CScriptVar::setCallback(JSCallback callback, void *userdata) {
   1266              jsCallback = callback;
   1267              jsCallbackUserData = userdata;
   1268          }
   1269          
   1270          CScriptVar *CScriptVar::ref() {
   1271              refs++;
   1272              return this;
   1273          }
   1274          
   1275          void CScriptVar::unref() {
   1276              if (refs<=0) printf("OMFG, we have unreffed too far!\n");
   1277              if ((--refs)==0) {
   1278                delete this;
   1279              }
   1280          }
   1281          
   1282          int CScriptVar::getRefs() {
   1283              return refs;
   1284          }
   1285          
   1286          
   1287          // ----------------------------------------------------------------------------------- CSCRIPT
   1288          
   1289          CTinyJS::CTinyJS() {
   1290              l = 0;
   1291              root = (new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT))->ref();
   1292              // Add built-in classes
   1293              stringClass = (new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT))->ref();
   1294              arrayClass = (new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT))->ref();
   1295              objectClass = (new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT))->ref();
   1296              root->addChild("String", stringClass);
   1297              root->addChild("Array", arrayClass);
   1298              root->addChild("Object", objectClass);
   1299          }
   1300          
   1301          CTinyJS::~CTinyJS() {
   1302              ASSERT(!l);
   1303              scopes.clear();
   1304              stringClass->unref();
   1305              arrayClass->unref();
   1306              objectClass->unref();
   1307              root->unref();
   1308          
   1309          #if DEBUG_MEMORY
   1310              show_allocated();
   1311          #endif
   1312          }
   1313          
   1314          void CTinyJS::trace() {
   1315              root->trace();
   1316          }
   1317          
   1318          void CTinyJS::execute(const string &code) {
   1319              CScriptLex *oldLex = l;
   1320              vector<CScriptVar*> oldScopes = scopes;
   1321              l = new CScriptLex(code);
   1322          #ifdef TINYJS_CALL_STACK
   1323              call_stack.clear();
   1324          #endif
   1325              scopes.clear();
   1326              scopes.push_back(root);
   1327              /*try*/ {
   1328                  bool execute = true;
   1329                  while (l->tk) statement(execute);
   1330              } 
   1331          #if 0
   1332              catch (CScriptException *e) {
   1333                  ostringstream msg;
   1334                  msg << "Error " << e->text;
   1335          #ifdef TINYJS_CALL_STACK
   1336                  for (int i=(int)call_stack.size()-1;i>=0;i--)
   1337                    msg << "\n" << i << ": " << call_stack.at(i);
   1338          #endif
   1339                  msg << " at " << l->getPosition();
   1340                  delete l;
   1341                  l = oldLex;
   1342          
   1343                  /*throw*/ new CScriptException(msg.str());
   1344              }
   1345          #endif
   1346              delete l;
   1347              l = oldLex;
   1348              scopes = oldScopes;
   1349          }
   1350          
   1351          CScriptVarLink CTinyJS::evaluateComplex(const string &code) {
   1352              CScriptLex *oldLex = l;
   1353              vector<CScriptVar*> oldScopes = scopes;
   1354          
   1355              l = new CScriptLex(code);
   1356          #ifdef TINYJS_CALL_STACK
   1357              call_stack.clear();
   1358          #endif
   1359              scopes.clear();
   1360              scopes.push_back(root);
   1361              CScriptVarLink *v = 0;
   1362              /*try*/ {
   1363                  bool execute = true;
   1364                  do {
   1365                    CLEAN(v);
   1366                    v = base(execute);
   1367                    if (l->tk!=LEX_EOF) l->match(';');
   1368                  } while (l->tk!=LEX_EOF);
   1369              } 
   1370          #if 0
   1371              catch (CScriptException *e) {
   1372                ostringstream msg;
   1373                msg << "Error " << e->text;
   1374          #ifdef TINYJS_CALL_STACK
   1375                for (int i=(int)call_stack.size()-1;i>=0;i--)
   1376                  msg << "\n" << i << ": " << call_stack.at(i);
   1377          #endif
   1378                msg << " at " << l->getPosition();
   1379                delete l;
   1380                l = oldLex;
   1381          
   1382                  /*throw*/ new CScriptException(msg.str());
   1383              }
   1384          #endif
   1385              delete l;
   1386              l = oldLex;
   1387              scopes = oldScopes;
   1388          
   1389              if (v) {
   1390                  CScriptVarLink r = *v;
   1391                  CLEAN(v);
   1392                  return r;
   1393              }
   1394              // return undefined...
   1395              return CScriptVarLink(new CScriptVar());
   1396          }
   1397          
   1398          string CTinyJS::evaluate(const string &code) {
   1399              return evaluateComplex(code).var->getString();
   1400          }
   1401          
   1402          void CTinyJS::parseFunctionArguments(CScriptVar *funcVar) {
   1403            l->match('(');
   1404            while (l->tk!=')') {
   1405                funcVar->addChildNoDup(l->tkStr);
   1406                l->match(LEX_ID);
   1407                if (l->tk!=')') l->match(',');
   1408            }
   1409            l->match(')');
   1410          }
   1411          
   1412          void CTinyJS::addNative(const string &funcDesc, JSCallback ptr, void *userdata) {
   1413              CScriptLex *oldLex = l;
   1414              l = new CScriptLex(funcDesc);
   1415          
   1416              CScriptVar *base = root;
   1417          
   1418              l->match(LEX_R_FUNCTION);
   1419              string funcName = l->tkStr;
   1420              l->match(LEX_ID);
   1421              /* Check for dots, we might want to do something like function String.substring ... */
   1422              while (l->tk == '.') {
   1423                l->match('.');
   1424                CScriptVarLink *link = base->findChild(funcName);
   1425                // if it doesn't exist, make an object class
   1426                if (!link) link = base->addChild(funcName, new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT));
   1427                base = link->var;
   1428                funcName = l->tkStr;
   1429                l->match(LEX_ID);
   1430              }
   1431          
   1432              CScriptVar *funcVar = new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_FUNCTION | SCRIPTVAR_NATIVE);
   1433              funcVar->setCallback(ptr, userdata);
   1434              parseFunctionArguments(funcVar);
   1435              delete l;
   1436              l = oldLex;
   1437          
   1438              base->addChild(funcName, funcVar);
   1439          }
   1440          
   1441          CScriptVarLink *CTinyJS::parseFunctionDefinition() {
   1442            // actually parse a function...
   1443            l->match(LEX_R_FUNCTION);
   1444            string funcName = TINYJS_TEMP_NAME;
   1445            /* we can have functions without names */
   1446            if (l->tk==LEX_ID) {
   1447              funcName = l->tkStr;
   1448              l->match(LEX_ID);
   1449            }
   1450            CScriptVarLink *funcVar = new CScriptVarLink(new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_FUNCTION), funcName);
   1451            parseFunctionArguments(funcVar->var);
   1452            int funcBegin = l->tokenStart;
   1453            bool noexecute = false;
   1454            block(noexecute);
   1455            funcVar->var->data = l->getSubString(funcBegin);
   1456            return funcVar;
   1457          }
   1458          
   1459          /** Handle a function call (assumes we've parsed the function name and we're
   1460           * on the start bracket). 'parent' is the object that contains this method,
   1461           * if there was one (otherwise it's just a normnal function).
   1462           */
   1463          CScriptVarLink *CTinyJS::functionCall(bool &execute, CScriptVarLink *function, CScriptVar *parent) {
   1464            if (execute) {
   1465              if (!function->var->isFunction()) {
   1466                  string errorMsg = "Expecting '";
   1467                  errorMsg = errorMsg + function->name + "' to be a function";
   1468                  /*throw*/ new CScriptException(errorMsg.c_str());
   1469              }
   1470              l->match('(');
   1471              // create a new symbol table entry for execution of this function
   1472              CScriptVar *functionRoot = new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_FUNCTION);
   1473              if (parent)
   1474                functionRoot->addChildNoDup("this", parent);
   1475              // grab in all parameters
   1476              CScriptVarLink *v = function->var->firstChild;
   1477              while (v) {
   1478                  CScriptVarLink *value = base(execute);
   1479                  if (execute) {
   1480                      if (value->var->isBasic()) {
   1481                        // pass by value
   1482                        functionRoot->addChild(v->name, value->var->deepCopy());
   1483                      } else {
   1484                        // pass by reference
   1485                        functionRoot->addChild(v->name, value->var);
   1486                      }
   1487                  }
   1488                  CLEAN(value);
   1489                  if (l->tk!=')') l->match(',');
   1490                  v = v->nextSibling;
   1491              }
   1492              l->match(')');
   1493              // setup a return variable
   1494              CScriptVarLink *returnVar = NULL;
   1495              // execute function!
   1496              // add the function's execute space to the symbol table so we can recurse
   1497              CScriptVarLink *returnVarLink = functionRoot->addChild(TINYJS_RETURN_VAR);
   1498              scopes.push_back(functionRoot);
   1499          #ifdef TINYJS_CALL_STACK
   1500              call_stack.push_back(function->name + " from " + l->getPosition());
   1501          #endif
   1502          
   1503              if (function->var->isNative()) {
   1504                  ASSERT(function->var->jsCallback);
   1505                  function->var->jsCallback(functionRoot, function->var->jsCallbackUserData);
   1506              } else {
   1507                  /* we just want to execute the block, but something could
   1508                   * have messed up and left us with the wrong ScriptLex, so
   1509                   * we want to be careful here... */
   1510                  CScriptException *exception = 0;
   1511                  CScriptLex *oldLex = l;
   1512                  CScriptLex *newLex = new CScriptLex(function->var->getString());
   1513                  l = newLex;
   1514                  /*try*/ {
   1515                    block(execute);
   1516                    // because return will probably have called this, and set execute to false
   1517                    execute = true;
   1518                  } 
   1519                  /*catch (CScriptException *e) {
   1520                    exception = e;
   1521                  }*/
   1522                  delete newLex;
   1523                  l = oldLex;
   1524          
   1525                  if (exception)
   1526                    /*throw*/ exception;
   1527              }
   1528          #ifdef TINYJS_CALL_STACK
   1529              if (!call_stack.empty()) call_stack.pop_back();
   1530          #endif
   1531              scopes.pop_back();
   1532              /* get the real return var before we remove it from our function */
   1533              returnVar = new CScriptVarLink(returnVarLink->var);
   1534              functionRoot->removeLink(returnVarLink);
   1535              delete functionRoot;
   1536              if (returnVar)
   1537                return returnVar;
   1538              else
   1539                return new CScriptVarLink(new CScriptVar());
   1540            } else {
   1541              // function, but not executing - just parse args and be done
   1542              l->match('(');
   1543              while (l->tk != ')') {
   1544                CScriptVarLink *value = base(execute);
   1545                CLEAN(value);
   1546                if (l->tk!=')') l->match(',');
   1547              }
   1548              l->match(')');
   1549              if (l->tk == '{') { // TODO: why is this here?
   1550                block(execute);
   1551              }
   1552              /* function will be a blank scriptvarlink if we're not executing,
   1553               * so just return it rather than an alloc/free */
   1554              return function;
   1555            }
   1556          }
   1557          
   1558          CScriptVarLink *CTinyJS::factor(bool &execute) {
   1559              if (l->tk=='(') {
   1560                  l->match('(');
   1561                  CScriptVarLink *a = base(execute);
   1562                  l->match(')');
   1563                  return a;
   1564              }
   1565              if (l->tk==LEX_R_TRUE) {
   1566                  l->match(LEX_R_TRUE);
   1567                  return new CScriptVarLink(new CScriptVar(1));
   1568              }
   1569              if (l->tk==LEX_R_FALSE) {
   1570                  l->match(LEX_R_FALSE);
   1571                  return new CScriptVarLink(new CScriptVar(0));
   1572              }
   1573              if (l->tk==LEX_R_NULL) {
   1574                  l->match(LEX_R_NULL);
   1575                  return new CScriptVarLink(new CScriptVar(TINYJS_BLANK_DATA,SCRIPTVAR_NULL));
   1576              }
   1577              if (l->tk==LEX_R_UNDEFINED) {
   1578                  l->match(LEX_R_UNDEFINED);
   1579                  return new CScriptVarLink(new CScriptVar(TINYJS_BLANK_DATA,SCRIPTVAR_UNDEFINED));
   1580              }
   1581              if (l->tk==LEX_ID) {
   1582                  CScriptVarLink *a = execute ? findInScopes(l->tkStr) : new CScriptVarLink(new CScriptVar());
   1583                  //printf("0x%08X for %s at %s\n", (unsigned int)a, l->tkStr.c_str(), l->getPosition().c_str());
   1584                  /* The parent if we're executing a method call */
   1585                  CScriptVar *parent = 0;
   1586          
   1587                  if (execute && !a) {
   1588                    /* Variable doesn't exist! JavaScript says we should create it
   1589                     * (we won't add it here. This is done in the assignment operator)*/
   1590                    a = new CScriptVarLink(new CScriptVar(), l->tkStr);
   1591                  }
   1592                  l->match(LEX_ID);
   1593                  while (l->tk=='(' || l->tk=='.' || l->tk=='[') {
   1594                      if (l->tk=='(') { // ------------------------------------- Function Call
   1595                          a = functionCall(execute, a, parent);
   1596                      } else if (l->tk == '.') { // ------------------------------------- Record Access
   1597                          l->match('.');
   1598                          if (execute) {
   1599                            const string &name = l->tkStr;
   1600                            CScriptVarLink *child = a->var->findChild(name);
   1601                            if (!child) child = findInParentClasses(a->var, name);
   1602                            if (!child) {
   1603                              /* if we haven't found this defined yet, use the built-in
   1604                                 'length' properly */
   1605                              if (a->var->isArray() && name == "length") {
   1606                                int l = a->var->getArrayLength();
   1607                                child = new CScriptVarLink(new CScriptVar(l));
   1608                              } else if (a->var->isString() && name == "length") {
   1609                                int l = a->var->getString().size();
   1610                                child = new CScriptVarLink(new CScriptVar(l));
   1611                              } else {
   1612                                child = a->var->addChild(name);
   1613                              }
   1614                            }
   1615                            parent = a->var;
   1616                            a = child;
   1617                          }
   1618                          l->match(LEX_ID);
   1619                      } else if (l->tk == '[') { // ------------------------------------- Array Access
   1620                          l->match('[');
   1621                          CScriptVarLink *index = base(execute);
   1622                          l->match(']');
   1623                          if (execute) {
   1624                            CScriptVarLink *child = a->var->findChildOrCreate(index->var->getString());
   1625                            parent = a->var;
   1626                            a = child;
   1627                          }
   1628                          CLEAN(index);
   1629                      } else ASSERT(0);
   1630                  }
   1631                  return a;
   1632              }
   1633              if (l->tk==LEX_INT || l->tk==LEX_FLOAT) {
   1634                  CScriptVar *a = new CScriptVar(l->tkStr,
   1635                      ((l->tk==LEX_INT)?SCRIPTVAR_INTEGER:SCRIPTVAR_DOUBLE));
   1636                  l->match(l->tk);
   1637                  return new CScriptVarLink(a);
   1638              }
   1639              if (l->tk==LEX_STR) {
   1640                  CScriptVar *a = new CScriptVar(l->tkStr, SCRIPTVAR_STRING);
   1641                  l->match(LEX_STR);
   1642                  return new CScriptVarLink(a);
   1643              }
   1644              if (l->tk=='{') {
   1645                  CScriptVar *contents = new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT);
   1646                  /* JSON-style object definition */
   1647                  l->match('{');
   1648                  while (l->tk != '}') {
   1649                    string id = l->tkStr;
   1650                    // we only allow strings or IDs on the left hand side of an initialisation
   1651                    if (l->tk==LEX_STR) l->match(LEX_STR);
   1652                    else l->match(LEX_ID);
   1653                    l->match(':');
   1654                    if (execute) {
   1655                      CScriptVarLink *a = base(execute);
   1656                      contents->addChild(id, a->var);
   1657                      CLEAN(a);
   1658                    }
   1659                    // no need to clean here, as it will definitely be used
   1660                    if (l->tk != '}') l->match(',');
   1661                  }
   1662          
   1663                  l->match('}');
   1664                  return new CScriptVarLink(contents);
   1665              }
   1666              if (l->tk=='[') {
   1667                  CScriptVar *contents = new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_ARRAY);
   1668                  /* JSON-style array */
   1669                  l->match('[');
   1670                  int idx = 0;
   1671                  while (l->tk != ']') {
   1672                    if (execute) {
   1673                      char idx_str[16]; // big enough for 2^32
   1674                      sprintf_s(idx_str, sizeof(idx_str), "%d",idx);
   1675          
   1676                      CScriptVarLink *a = base(execute);
   1677                      contents->addChild(idx_str, a->var);
   1678                      CLEAN(a);
   1679                    }
   1680                    // no need to clean here, as it will definitely be used
   1681                    if (l->tk != ']') l->match(',');
   1682                    idx++;
   1683                  }
   1684                  l->match(']');
   1685                  return new CScriptVarLink(contents);
   1686              }
   1687              if (l->tk==LEX_R_FUNCTION) {
   1688                CScriptVarLink *funcVar = parseFunctionDefinition();
   1689                  if (funcVar->name != TINYJS_TEMP_NAME)
   1690                    TRACE("Functions not defined at statement-level are not meant to have a name");
   1691                  return funcVar;
   1692              }
   1693              if (l->tk==LEX_R_NEW) {
   1694                // new -> create a new object
   1695                l->match(LEX_R_NEW);
   1696                const string &className = l->tkStr;
   1697                if (execute) {
   1698                  CScriptVarLink *objClassOrFunc = findInScopes(className);
   1699                  if (!objClassOrFunc) {
   1700                    TRACE("%s is not a valid class name", className.c_str());
   1701                    return new CScriptVarLink(new CScriptVar());
   1702                  }
   1703                  l->match(LEX_ID);
   1704                  CScriptVar *obj = new CScriptVar(TINYJS_BLANK_DATA, SCRIPTVAR_OBJECT);
   1705                  CScriptVarLink *objLink = new CScriptVarLink(obj);
   1706                  if (objClassOrFunc->var->isFunction()) {
   1707                    CLEAN(functionCall(execute, objClassOrFunc, obj));
   1708                  } else {
   1709                    obj->addChild(TINYJS_PROTOTYPE_CLASS, objClassOrFunc->var);
   1710                    if (l->tk == '(') {
   1711                      l->match('(');
   1712                      l->match(')');
   1713                    }
   1714                  }
   1715                  return objLink;
   1716                } else {
   1717                  l->match(LEX_ID);
   1718                  if (l->tk == '(') {
   1719                    l->match('(');
   1720                    l->match(')');
   1721                  }
   1722                }
   1723              }
   1724              // Nothing we can do here... just hope it's the end...
   1725              l->match(LEX_EOF);
   1726              return 0;
   1727          }
   1728          
   1729          CScriptVarLink *CTinyJS::unary(bool &execute) {
   1730              CScriptVarLink *a;
   1731              if (l->tk=='!') {
   1732                  l->match('!'); // binary not
   1733                  a = factor(execute);
   1734                  if (execute) {
   1735                      CScriptVar zero(0);
   1736                      CScriptVar *res = a->var->mathsOp(&zero, LEX_EQUAL);
   1737                      CREATE_LINK(a, res);
   1738                  }
   1739              } else
   1740                  a = factor(execute);
   1741              return a;
   1742          }
   1743          
   1744          CScriptVarLink *CTinyJS::term(bool &execute) {
   1745              CScriptVarLink *a = unary(execute);
   1746              while (l->tk=='*' || l->tk=='/' || l->tk=='%') {
   1747                  int op = l->tk;
   1748                  l->match(l->tk);
   1749                  CScriptVarLink *b = unary(execute);
   1750                  if (execute) {
   1751                      CScriptVar *res = a->var->mathsOp(b->var, op);
   1752                      CREATE_LINK(a, res);
   1753                  }
   1754                  CLEAN(b);
   1755              }
   1756              return a;
   1757          }
   1758          
   1759          CScriptVarLink *CTinyJS::expression(bool &execute) {
   1760              bool negate = false;
   1761              if (l->tk=='-') {
   1762                  l->match('-');
   1763                  negate = true;
   1764              }
   1765              CScriptVarLink *a = term(execute);
   1766              if (negate) {
   1767                  CScriptVar zero(0);
   1768                  CScriptVar *res = zero.mathsOp(a->var, '-');
   1769                  CREATE_LINK(a, res);
   1770              }
   1771          
   1772              while (l->tk=='+' || l->tk=='-' ||
   1773                  l->tk==LEX_PLUSPLUS || l->tk==LEX_MINUSMINUS) {
   1774                  int op = l->tk;
   1775                  l->match(l->tk);
   1776                  if (op==LEX_PLUSPLUS || op==LEX_MINUSMINUS) {
   1777                      if (execute) {
   1778                          CScriptVar one(1);
   1779                          CScriptVar *res = a->var->mathsOp(&one, op==LEX_PLUSPLUS ? '+' : '-');
   1780                          CScriptVarLink *oldValue = new CScriptVarLink(a->var);
   1781                          // in-place add/subtract
   1782                          a->replaceWith(res);
   1783                          CLEAN(a);
   1784                          a = oldValue;
   1785                      }
   1786                  } else {
   1787                      CScriptVarLink *b = term(execute);
   1788                      if (execute) {
   1789                          // not in-place, so just replace
   1790                          CScriptVar *res = a->var->mathsOp(b->var, op);
   1791                          CREATE_LINK(a, res);
   1792                      }
   1793                      CLEAN(b);
   1794                  }
   1795              }
   1796              return a;
   1797          }
   1798          
   1799          CScriptVarLink *CTinyJS::shift(bool &execute) {
   1800            CScriptVarLink *a = expression(execute);
   1801            if (l->tk==LEX_LSHIFT || l->tk==LEX_RSHIFT || l->tk==LEX_RSHIFTUNSIGNED) {
   1802              int op = l->tk;
   1803              l->match(op);
   1804              CScriptVarLink *b = base(execute);
   1805              int shift = execute ? b->var->getInt() : 0;
   1806              CLEAN(b);
   1807              if (execute) {
   1808                if (op==LEX_LSHIFT) a->var->setInt(a->var->getInt() << shift);
   1809                if (op==LEX_RSHIFT) a->var->setInt(a->var->getInt() >> shift);
   1810                if (op==LEX_RSHIFTUNSIGNED) a->var->setInt(((unsigned int)a->var->getInt()) >> shift);
   1811              }
   1812            }
   1813            return a;
   1814          }
   1815          
   1816          CScriptVarLink *CTinyJS::condition(bool &execute) {
   1817              CScriptVarLink *a = shift(execute);
   1818              CScriptVarLink *b;
   1819              while (l->tk==LEX_EQUAL || l->tk==LEX_NEQUAL ||
   1820                     l->tk==LEX_TYPEEQUAL || l->tk==LEX_NTYPEEQUAL ||
   1821                     l->tk==LEX_LEQUAL || l->tk==LEX_GEQUAL ||
   1822                     l->tk=='<' || l->tk=='>') {
   1823                  int op = l->tk;
   1824                  l->match(l->tk);
   1825                  b = shift(execute);
   1826                  if (execute) {
   1827                      CScriptVar *res = a->var->mathsOp(b->var, op);
   1828                      CREATE_LINK(a,res);
   1829                  }
   1830                  CLEAN(b);
   1831              }
   1832              return a;
   1833          }
   1834          
   1835          CScriptVarLink *CTinyJS::logic(bool &execute) {
   1836              CScriptVarLink *a = condition(execute);
   1837              CScriptVarLink *b;
   1838              while (l->tk=='&' || l->tk=='|' || l->tk=='^' || l->tk==LEX_ANDAND || l->tk==LEX_OROR) {
   1839                  bool noexecute = false;
   1840                  int op = l->tk;
   1841                  l->match(l->tk);
   1842                  bool shortCircuit = false;
   1843                  bool boolean = false;
   1844                  // if we have short-circuit ops, then if we know the outcome
   1845                  // we don't bother to execute the other op. Even if not
   1846                  // we need to tell mathsOp it's an & or |
   1847                  if (op==LEX_ANDAND) {
   1848                      op = '&';
   1849                      shortCircuit = !a->var->getBool();
   1850                      boolean = true;
   1851                  } else if (op==LEX_OROR) {
   1852                      op = '|';
   1853                      shortCircuit = a->var->getBool();
   1854                      boolean = true;
   1855                  }
   1856                  b = condition(shortCircuit ? noexecute : execute);
   1857                  if (execute && !shortCircuit) {
   1858                      if (boolean) {
   1859                        CScriptVar *newa = new CScriptVar(a->var->getBool());
   1860                        CScriptVar *newb = new CScriptVar(b->var->getBool());
   1861                        CREATE_LINK(a, newa);
   1862                        CREATE_LINK(b, newb);
   1863                      }
   1864                      CScriptVar *res = a->var->mathsOp(b->var, op);
   1865                      CREATE_LINK(a, res);
   1866                  }
   1867                  CLEAN(b);
   1868              }
   1869              return a;
   1870          }
   1871          
   1872          CScriptVarLink *CTinyJS::ternary(bool &execute) {
   1873            CScriptVarLink *lhs = logic(execute);
   1874            bool noexec = false;
   1875            if (l->tk=='?') {
   1876              l->match('?');
   1877              if (!execute) {
   1878                CLEAN(lhs);
   1879                CLEAN(base(noexec));
   1880                l->match(':');
   1881                CLEAN(base(noexec));
   1882              } else {
   1883                bool first = lhs->var->getBool();
   1884                CLEAN(lhs);
   1885                if (first) {
   1886                  lhs = base(execute);
   1887                  l->match(':');
   1888                  CLEAN(base(noexec));
   1889                } else {
   1890                  CLEAN(base(noexec));
   1891                  l->match(':');
   1892                  lhs = base(execute);
   1893                }
   1894              }
   1895            }
   1896          
   1897            return lhs;
   1898          }
   1899          
   1900          CScriptVarLink *CTinyJS::base(bool &execute) {
   1901              CScriptVarLink *lhs = ternary(execute);
   1902              if (l->tk=='=' || l->tk==LEX_PLUSEQUAL || l->tk==LEX_MINUSEQUAL) {
   1903                  /* If we're assigning to this and we don't have a parent,
   1904                   * add it to the symbol table root as per JavaScript. */
   1905                  if (execute && !lhs->owned) {
   1906                    if (lhs->name.length()>0) {
   1907                      CScriptVarLink *realLhs = root->addChildNoDup(lhs->name, lhs->var);
   1908                      CLEAN(lhs);
   1909                      lhs = realLhs;
   1910                    } else
   1911                      TRACE("Trying to assign to an un-named type\n");
   1912                  }
   1913          
   1914                  int op = l->tk;
   1915                  l->match(l->tk);
   1916                  CScriptVarLink *rhs = base(execute);
   1917                  if (execute) {
   1918                      if (op=='=') {
   1919                          lhs->replaceWith(rhs);
   1920                      } else if (op==LEX_PLUSEQUAL) {
   1921                          CScriptVar *res = lhs->var->mathsOp(rhs->var, '+');
   1922                          lhs->replaceWith(res);
   1923                      } else if (op==LEX_MINUSEQUAL) {
   1924                          CScriptVar *res = lhs->var->mathsOp(rhs->var, '-');
   1925                          lhs->replaceWith(res);
   1926                      } else ASSERT(0);
   1927                  }
   1928                  CLEAN(rhs);
   1929              }
   1930              return lhs;
   1931          }
   1932          
   1933          void CTinyJS::block(bool &execute) {
   1934              l->match('{');
   1935              if (execute) {
   1936                while (l->tk && l->tk!='}')
   1937                  statement(execute);
   1938                l->match('}');
   1939              } else {
   1940                // fast skip of blocks
   1941                int brackets = 1;
   1942                while (l->tk && brackets) {
   1943                  if (l->tk == '{') brackets++;
   1944                  if (l->tk == '}') brackets--;
   1945                  l->match(l->tk);
   1946                }
   1947              }
   1948          
   1949          }
   1950          
   1951          void CTinyJS::statement(bool &execute) {
   1952              if (l->tk==LEX_ID ||
   1953                  l->tk==LEX_INT ||
   1954                  l->tk==LEX_FLOAT ||
   1955                  l->tk==LEX_STR ||
   1956                  l->tk=='-') {
   1957                  /* Execute a simple statement that only contains basic arithmetic... */
   1958                  CLEAN(base(execute));
   1959                  l->match(';');
   1960              } else if (l->tk=='{') {
   1961                  /* A block of code */
   1962                  block(execute);
   1963              } else if (l->tk==';') {
   1964                  /* Empty statement - to allow things like ;;; */
   1965                  l->match(';');
   1966              } else if (l->tk==LEX_R_VAR) {
   1967                  /* variable creation. TODO - we need a better way of parsing the left
   1968                   * hand side. Maybe just have a flag called can_create_var that we
   1969                   * set and then we parse as if we're doing a normal equals.*/
   1970                  l->match(LEX_R_VAR);
   1971                  while (l->tk != ';') {
   1972                    CScriptVarLink *a = 0;
   1973                    if (execute)
   1974                      a = scopes.back()->findChildOrCreate(l->tkStr);
   1975                    l->match(LEX_ID);
   1976                    // now do stuff defined with dots
   1977                    while (l->tk == '.') {
   1978                        l->match('.');
   1979                        if (execute) {
   1980                            CScriptVarLink *lastA = a;
   1981                            a = lastA->var->findChildOrCreate(l->tkStr);
   1982                        }
   1983                        l->match(LEX_ID);
   1984                    }
   1985                    // sort out initialiser
   1986                    if (l->tk == '=') {
   1987                        l->match('=');
   1988                        CScriptVarLink *var = base(execute);
   1989                        if (execute)
   1990                            a->replaceWith(var);
   1991                        CLEAN(var);
   1992                    }
   1993                    if (l->tk != ';')
   1994                      l->match(',');
   1995                  }       
   1996                  l->match(';');
   1997              } else if (l->tk==LEX_R_IF) {
   1998                  l->match(LEX_R_IF);
   1999                  l->match('(');
   2000                  CScriptVarLink *var = base(execute);
   2001                  l->match(')');
   2002                  bool cond = execute && var->var->getBool();
   2003                  CLEAN(var);
   2004                  bool noexecute = false; // because we need to be abl;e to write to it
   2005                  statement(cond ? execute : noexecute);
   2006                  if (l->tk==LEX_R_ELSE) {
   2007                      l->match(LEX_R_ELSE);
   2008                      statement(cond ? noexecute : execute);
   2009                  }
   2010              } else if (l->tk==LEX_R_WHILE) {
   2011                  // We do repetition by pulling out the string representing our statement
   2012                  // there's definitely some opportunity for optimisation here
   2013                  l->match(LEX_R_WHILE);
   2014                  l->match('(');
   2015                  int whileCondStart = l->tokenStart;
   2016                  bool noexecute = false;
   2017                  CScriptVarLink *cond = base(execute);
   2018                  bool loopCond = execute && cond->var->getBool();
   2019                  CLEAN(cond);
   2020                  CScriptLex *whileCond = l->getSubLex(whileCondStart);
   2021                  l->match(')');
   2022                  int whileBodyStart = l->tokenStart;
   2023                  statement(loopCond ? execute : noexecute);
   2024                  CScriptLex *whileBody = l->getSubLex(whileBodyStart);
   2025                  CScriptLex *oldLex = l;
   2026                  int loopCount = TINYJS_LOOP_MAX_ITERATIONS;
   2027                  while (loopCond && loopCount-->0) {
   2028                      whileCond->reset();
   2029                      l = whileCond;
   2030                      cond = base(execute);
   2031                      loopCond = execute && cond->var->getBool();
   2032                      CLEAN(cond);
   2033                      if (loopCond) {
   2034                          whileBody->reset();
   2035                          l = whileBody;
   2036                          statement(execute);
   2037                      }
   2038                  }
   2039                  l = oldLex;
   2040                  delete whileCond;
   2041                  delete whileBody;
   2042          
   2043                  if (loopCount<=0) {
   2044                      root->trace();
   2045                      TRACE("WHILE Loop exceeded %d iterations at %s\n", TINYJS_LOOP_MAX_ITERATIONS, l->getPosition().c_str());
   2046                      /*throw*/ new CScriptException("LOOP_ERROR");
   2047                  }
   2048              } else if (l->tk==LEX_R_FOR) {
   2049                  l->match(LEX_R_FOR);
   2050                  l->match('(');
   2051                  statement(execute); // initialisation
   2052                  //l->match(';');
   2053                  int forCondStart = l->tokenStart;
   2054                  bool noexecute = false;
   2055                  CScriptVarLink *cond = base(execute); // condition
   2056                  bool loopCond = execute && cond->var->getBool();
   2057                  CLEAN(cond);
   2058                  CScriptLex *forCond = l->getSubLex(forCondStart);
   2059                  l->match(';');
   2060                  int forIterStart = l->tokenStart;
   2061                  CLEAN(base(noexecute)); // iterator
   2062                  CScriptLex *forIter = l->getSubLex(forIterStart);
   2063                  l->match(')');
   2064                  int forBodyStart = l->tokenStart;
   2065                  statement(loopCond ? execute : noexecute);
   2066                  CScriptLex *forBody = l->getSubLex(forBodyStart);
   2067                  CScriptLex *oldLex = l;
   2068                  if (loopCond) {
   2069                      forIter->reset();
   2070                      l = forIter;
   2071                      CLEAN(base(execute));
   2072                  }
   2073                  int loopCount = TINYJS_LOOP_MAX_ITERATIONS;
   2074                  while (execute && loopCond && loopCount-->0) {
   2075                      forCond->reset();
   2076                      l = forCond;
   2077                      cond = base(execute);
   2078                      loopCond = cond->var->getBool();
   2079                      CLEAN(cond);
   2080                      if (execute && loopCond) {
   2081                          forBody->reset();
   2082                          l = forBody;
   2083                          statement(execute);
   2084                      }
   2085                      if (execute && loopCond) {
   2086                          forIter->reset();
   2087                          l = forIter;
   2088                          CLEAN(base(execute));
   2089                      }
   2090                  }
   2091                  l = oldLex;
   2092                  delete forCond;
   2093                  delete forIter;
   2094                  delete forBody;
   2095                  if (loopCount<=0) {
   2096                      root->trace();
   2097                      TRACE("FOR Loop exceeded %d iterations at %s\n", TINYJS_LOOP_MAX_ITERATIONS, l->getPosition().c_str());
   2098                      /*throw*/ new CScriptException("LOOP_ERROR");
   2099                  }
   2100              } else if (l->tk==LEX_R_RETURN) {
   2101                  l->match(LEX_R_RETURN);
   2102                  CScriptVarLink *result = 0;
   2103                  if (l->tk != ';')
   2104                    result = base(execute);
   2105                  if (execute) {
   2106                    CScriptVarLink *resultVar = scopes.back()->findChild(TINYJS_RETURN_VAR);
   2107                    if (resultVar)
   2108                      resultVar->replaceWith(result);
   2109                    else
   2110                      TRACE("RETURN statement, but not in a function.\n");
   2111                    execute = false;
   2112                  }
   2113                  CLEAN(result);
   2114                  l->match(';');
   2115              } else if (l->tk==LEX_R_FUNCTION) {
   2116                  CScriptVarLink *funcVar = parseFunctionDefinition();
   2117                  if (execute) {
   2118                    if (funcVar->name == TINYJS_TEMP_NAME)
   2119                      TRACE("Functions defined at statement-level are meant to have a name\n");
   2120                    else
   2121                      scopes.back()->addChildNoDup(funcVar->name, funcVar->var);
   2122                  }
   2123                  CLEAN(funcVar);
   2124              } else l->match(LEX_EOF);
   2125          }
   2126          
   2127          /// Get the given variable specified by a path (var1.var2.etc), or return 0
   2128          CScriptVar *CTinyJS::getScriptVariable(const string &path) {
   2129              // traverse path
   2130              size_t prevIdx = 0;
   2131              size_t thisIdx = path.find('.');
   2132              if (thisIdx == string::npos) thisIdx = path.length();
   2133              CScriptVar *var = root;
   2134              while (var && prevIdx<path.length()) {
   2135                  string el = path.substr(prevIdx, thisIdx-prevIdx);
   2136                  CScriptVarLink *varl = var->findChild(el);
   2137                  var = varl?varl->var:0;
   2138                  prevIdx = thisIdx+1;
   2139                  thisIdx = path.find('.', prevIdx);
   2140                  if (thisIdx == string::npos) thisIdx = path.length();
   2141              }
   2142              return var;
   2143          }
   2144          
   2145          /// Get the value of the given variable, or return 0
   2146          const string *CTinyJS::getVariable(const string &path) {
   2147              CScriptVar *var = getScriptVariable(path);
   2148              // return result
   2149              if (var)
   2150                  return &var->getString();
   2151              else
   2152                  return 0;
   2153          }
   2154          
   2155          /// set the value of the given variable, return trur if it exists and gets set
   2156          bool CTinyJS::setVariable(const string &path, const string &varData) {
   2157              CScriptVar *var = getScriptVariable(path);
   2158              // return result
   2159              if (var) {
   2160                  if (var->isInt())
   2161                      var->setInt((int)strtol(varData.c_str(),0,0));
   2162                  else if (var->isDouble())
   2163                      var->setDouble(strtod(varData.c_str(),0));
   2164                  else
   2165                      var->setString(varData.c_str());
   2166                  return true;
   2167              }    
   2168              else
   2169                  return false;
   2170          }
   2171          
   2172          /// Finds a child, looking recursively up the scopes
   2173          CScriptVarLink *CTinyJS::findInScopes(const string &childName) {
   2174              for (int s=scopes.size()-1;s>=0;s--) {
   2175                CScriptVarLink *v = scopes[s]->findChild(childName);
   2176                if (v) return v;
   2177              }
   2178              return NULL;
   2179          
   2180          }
   2181          
   2182          /// Look up in any parent classes of the given object
   2183          CScriptVarLink *CTinyJS::findInParentClasses(CScriptVar *object, const string &name) {
   2184              // Look for links to actual parent classes
   2185              CScriptVarLink *parentClass = object->findChild(TINYJS_PROTOTYPE_CLASS);
   2186              while (parentClass) {
   2187                CScriptVarLink *implementation = parentClass->var->findChild(name);
   2188                if (implementation) return implementation;
   2189                parentClass = parentClass->var->findChild(TINYJS_PROTOTYPE_CLASS);
   2190              }
   2191              // else fake it for strings and finally objects
   2192              if (object->isString()) {
   2193                CScriptVarLink *implementation = stringClass->findChild(name);
   2194                if (implementation) return implementation;
   2195              }
   2196              if (object->isArray()) {
   2197                CScriptVarLink *implementation = arrayClass->findChild(name);
   2198                if (implementation) return implementation;
   2199              }
   2200              CScriptVarLink *implementation = objectClass->findChild(name);
   2201              if (implementation) return implementation;
   2202          
   2203              return 0;
   2204          }
   2205          
   2206          #include "TinyJS_Functions.h"
   2207          extern "C" unsigned int CDC_Send_DATA_str (unsigned char *ptrBuffer);
   2208          
   2209          void js_print(CScriptVar *v, void *userdata) {
   2210              //printf("> %s\n", v->getParameter("text")->getString().c_str());
   2211              CDC_Send_DATA_str((unsigned char*)v->getParameter("text")->getString().c_str());
   2212          }
   2213          
   2214          void exec()
   2215          {
   2216            const char *code = "{ var t=0;for (var b=1;b<=100;b++){t=t+b;}print(t); }";
   2217            CTinyJS *js = new CTinyJS();
   2218            /* add the functions from TinyJS_Functions.cpp */
   2219            //registerFunctions(js);
   2220            /* Add a native function */
   2221            js->addNative("function print(text)", &js_print, 0);
   2222            js->execute(code);
   2223            delete js;
   2224            return;
   2225            //js->addNative("function dump()", &js_dump, js);
   2226            /* Execute out bit of code - we could call 'evaluate' here if
   2227               we wanted something returned */
   2228            {
   2229              js->execute("var lets_quit = 0; function quit() { lets_quit = 1; }");
   2230              js->execute("print(\"Interactive mode... Type quit(); to exit, or print(...); to print something, or dump() to dump the symbol table!\");");
   2231            } 
   2232          
   2233            while (js->evaluate("lets_quit") == "0") {
   2234               {
   2235                js->execute(code);
   2236              } 
   2237            }
   2238            delete js;
   2239          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   CScriptException::CScriptException(string const &)
        16   -> string::operator=(string const &)
        16   -> string::string()
       8   CScriptException::subobject CScriptException(string const &)
         8   -> CScriptException::CScriptException(string const &)
      24   CScriptLex::CScriptLex(CScriptLex *, int, int)
        24   -> CScriptLex::reset()
        24   -> string::string()
      16   CScriptLex::CScriptLex(string const &)
        16   -> CScriptLex::reset()
        16   -> strdup
        16   -> string::c_str() const
        16   -> string::string()
        16   -> strlen
       0   CScriptLex::getNextCh()
      24   CScriptLex::getNextToken()
        24   -> CScriptLex::getNextCh()
        24   -> CScriptLex::getNextToken()
        24   -> isAlpha(char)
        24   -> isHexadecimal(char)
        24   -> isNumeric(char)
        24   -> isWhitespace(char)
        24   -> operator==(string const &, char const *)
        24   -> string::clear()
        24   -> string::operator+=(char)
        24   -> strtol
     280   CScriptLex::getPosition(int)
       280   -> snprintf
       280   -> string::string(char const *)
      24   CScriptLex::getSubLex(int)
        24   -> CScriptLex::CScriptLex(CScriptLex *, int, int)
        24   -> operator new(size_t)
      48   CScriptLex::getSubString(int)
        48   -> string::string(char const *)
        48   -> string::string(string const &)
        48   -> string::~string()
     144   CScriptLex::getTokenStr(int)
       144   -> operator<<(ostream &, char const *)
       144   -> ostream::operator<<(int)
       144   -> ostringstream::ostringstream(int)
       144   -> ostringstream::str() const
       144   -> ostringstream::~ostringstream()
       144   -> string::string(char const *)
     248   CScriptLex::match(int)
       248   -> CScriptException::CScriptException(string const &)
       248   -> CScriptLex::getNextToken()
       248   -> CScriptLex::getPosition(int)
       248   -> CScriptLex::getTokenStr(int)
       248   -> operator new(size_t)
       248   -> operator<<(ostream &, char const *)
       248   -> operator<<(ostream &, string const &)
       248   -> ostringstream::ostringstream(int)
       248   -> ostringstream::str() const
       248   -> ostringstream::~ostringstream()
       248   -> string::~string()
       8   CScriptLex::reset()
         8   -> CScriptLex::getNextCh()
         8   -> CScriptLex::getNextToken()
         8   -> string::operator=(char const *)
       8   CScriptLex::subobject CScriptLex(CScriptLex *, int, int)
         8   -> CScriptLex::CScriptLex(CScriptLex *, int, int)
       8   CScriptLex::subobject CScriptLex(string const &)
         8   -> CScriptLex::CScriptLex(string const &)
       8   CScriptLex::subobject ~CScriptLex()
         8   -> CScriptLex::~CScriptLex()
       8   CScriptLex::~CScriptLex()
         8   -> free
         8   -> string::~string()
      16   CScriptVar::CScriptVar()
        16   -> CScriptVar::init()
        16   -> string::string()
      16   CScriptVar::CScriptVar(double)
        16   -> CScriptVar::init()
        16   -> CScriptVar::setDouble(double)
        16   -> string::string()
      16   CScriptVar::CScriptVar(int)
        16   -> CScriptVar::init()
        16   -> CScriptVar::setInt(int)
        16   -> string::string()
      16   CScriptVar::CScriptVar(string const &)
        16   -> CScriptVar::init()
        16   -> string::operator=(string const &)
        16   -> string::string()
      16   CScriptVar::CScriptVar(string const &, int)
        16   -> CScriptVar::init()
        16   -> string::c_str() const
        16   -> string::operator=(string const &)
        16   -> string::string()
        16   -> strtod
        16   -> strtol
      16   CScriptVar::addChild(string const &, CScriptVar *)
        16   -> CScriptVar::CScriptVar()
        16   -> CScriptVar::isUndefined()
        16   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
        16   -> operator new(size_t)
      24   CScriptVar::addChildNoDup(string const &, CScriptVar *)
        24   -> CScriptVar::CScriptVar()
        24   -> CScriptVar::addChild(string const &, CScriptVar *)
        24   -> CScriptVar::findChild(string const &)
        24   -> CScriptVarLink::replaceWith(CScriptVar *)
        24   -> operator new(size_t)
      16   CScriptVar::copySimpleData(CScriptVar *)
        16   -> string::operator=(string const &)
      16   CScriptVar::copyValue(CScriptVar *)
        16   -> CScriptVar::addChild(string const &, CScriptVar *)
        16   -> CScriptVar::copySimpleData(CScriptVar *)
        16   -> CScriptVar::deepCopy()
        16   -> CScriptVar::removeAllChildren()
        16   -> CScriptVar::setUndefined()
        16   -> operator!=(string const &, char const *)
      16   CScriptVar::deepCopy()
        16   -> CScriptVar::CScriptVar()
        16   -> CScriptVar::addChild(string const &, CScriptVar *)
        16   -> CScriptVar::copySimpleData(CScriptVar *)
        16   -> CScriptVar::deepCopy()
        16   -> operator new(size_t)
        16   -> operator!=(string const &, char const *)
      16   CScriptVar::equals(CScriptVar *)
        16   -> CScriptVar::getBool()
        16   -> CScriptVar::mathsOp(CScriptVar *, int)
        16   -> CScriptVar::~CScriptVar()
        16   -> operator delete(void *)
      16   CScriptVar::findChild(string const &)
        16   -> string::compare(string const &) const
      48   CScriptVar::findChildOrCreate(string const &, int)
        48   -> CScriptVar::CScriptVar(string const &, int)
        48   -> CScriptVar::addChild(string const &, CScriptVar *)
        48   -> CScriptVar::findChild(string const &)
        48   -> operator new(size_t)
        48   -> string::string(char const *)
        48   -> string::~string()
      80   CScriptVar::findChildOrCreateByPath(string const &)
        80   -> CScriptVar::findChildOrCreate(string const &, int)
        80   -> CScriptVar::findChildOrCreateByPath(string const &)
        80   -> string::find(char, size_t) const
        80   -> string::substr(size_t, size_t) const
        80   -> string::~string()
     104   CScriptVar::getArrayIndex(int)
       104   -> CScriptVar::CScriptVar(string const &, int)
       104   -> CScriptVar::findChild(string const &)
       104   -> operator new(size_t)
       104   -> snprintf
       104   -> string::string(char const *)
       104   -> string::~string()
      16   CScriptVar::getArrayLength()
        16   -> CScriptVar::isArray()
        16   -> atoi
        16   -> isNumber(string const &)
        16   -> string::c_str() const
       8   CScriptVar::getBool()
         8   -> CScriptVar::getInt()
       0   CScriptVar::getChildren()
       8   CScriptVar::getDouble()
         8   -> CScriptVar::isDouble()
         8   -> CScriptVar::isInt()
         8   -> CScriptVar::isNull()
         8   -> CScriptVar::isUndefined()
         8   -> __aeabi_i2d
      40   CScriptVar::getFlagsAsString()
        40   -> operator+(string const &, char const *)
        40   -> string::operator=(string const &)
        40   -> string::string(char const *)
        40   -> string::~string()
       8   CScriptVar::getInt()
         8   -> CScriptVar::isDouble()
         8   -> CScriptVar::isInt()
         8   -> CScriptVar::isNull()
         8   -> CScriptVar::isUndefined()
         8   -> __aeabi_d2iz
     112   CScriptVar::getJSON(ostringstream &, string)
       112   -> CScriptVar::getArrayIndex(int)
       112   -> CScriptVar::getArrayLength()
       112   -> CScriptVar::getJSON(ostringstream &, string)
       112   -> CScriptVar::getParsableString()
       112   -> CScriptVar::isArray()
       112   -> CScriptVar::isObject()
       112   -> getJSString(string const &)
       112   -> operator+(string const &, char const *)
       112   -> operator<<(ostream &, char const *)
       112   -> operator<<(ostream &, string const &)
       112   -> string::string(string const &)
       112   -> string::~string()
       8   CScriptVar::getParameter(string const &)
         8   -> CScriptVar::findChildOrCreate(string const &, int)
     144   CScriptVar::getParsableString()
       144   -> CScriptVar::getString()
       144   -> CScriptVar::isFunction()
       144   -> CScriptVar::isNull()
       144   -> CScriptVar::isNumeric()
       144   -> CScriptVar::isString()
       144   -> getJSString(string const &)
       144   -> operator<<(ostream &, char const *)
       144   -> operator<<(ostream &, string const &)
       144   -> ostringstream::ostringstream(int)
       144   -> ostringstream::str() const
       144   -> ostringstream::~ostringstream()
       144   -> string::string(char const *)
       144   -> string::string(string const &)
       0   CScriptVar::getRefs()
      40   CScriptVar::getReturnVar()
        40   -> CScriptVar::getParameter(string const &)
        40   -> string::string(char const *)
        40   -> string::~string()
      56   CScriptVar::getString()
        56   -> CScriptVar::isDouble()
        56   -> CScriptVar::isInt()
        56   -> CScriptVar::isNull()
        56   -> CScriptVar::isUndefined()
        56   -> snprintf
        56   -> string::operator=(char const *)
        56   -> string::string(char const *)
      16   CScriptVar::init()
        16   -> string::operator=(char const *)
       0   CScriptVar::isArray()
       0   CScriptVar::isDouble()
       0   CScriptVar::isFunction()
       0   CScriptVar::isInt()
       0   CScriptVar::isNull()
       0   CScriptVar::isNumeric()
       0   CScriptVar::isObject()
       0   CScriptVar::isString()
       0   CScriptVar::isUndefined()
     184   CScriptVar::mathsOp(CScriptVar *, int)
       184   -> CScriptException::CScriptException(string const &)
       184   -> CScriptLex::getTokenStr(int)
       184   -> CScriptVar::CScriptVar()
       184   -> CScriptVar::CScriptVar(double)
       184   -> CScriptVar::CScriptVar(int)
       184   -> CScriptVar::CScriptVar(string const &, int)
       184   -> CScriptVar::getBool()
       184   -> CScriptVar::getDouble()
       184   -> CScriptVar::getInt()
       184   -> CScriptVar::getString()
       184   -> CScriptVar::isArray()
       184   -> CScriptVar::isDouble()
       184   -> CScriptVar::isNumeric()
       184   -> CScriptVar::isObject()
       184   -> CScriptVar::isUndefined()
       184   -> CScriptVar::mathsOp(CScriptVar *, int)
       184   -> CScriptVar::~CScriptVar()
       184   -> __aeabi_assert
       184   -> __aeabi_cdcmpeq
       184   -> __aeabi_cdcmple
       184   -> __aeabi_cdrcmple
       184   -> __aeabi_dadd
       184   -> __aeabi_ddiv
       184   -> __aeabi_dmul
       184   -> __aeabi_dsub
       184   -> __aeabi_idiv
       184   -> __aeabi_idivmod
       184   -> __iar_EmptyStepPoint
       184   -> operator delete(void *)
       184   -> operator new(size_t)
       184   -> operator+(char const *, string const &)
       184   -> operator+(string const &, char const *)
       184   -> operator+(string const &, string const &)
       184   -> operator<(string const &, string const &)
       184   -> operator==(string const &, string const &)
       184   -> string::string(string const &)
       184   -> string::~string()
       0   CScriptVar::ref()
      16   CScriptVar::removeAllChildren()
        16   -> CScriptVarLink::~CScriptVarLink()
        16   -> operator delete(void *)
      16   CScriptVar::removeChild(CScriptVar *)
        16   -> CScriptVar::removeLink(CScriptVarLink *)
        16   -> __aeabi_assert
        16   -> __iar_EmptyStepPoint
       8   CScriptVar::removeLink(CScriptVarLink *)
         8   -> CScriptVarLink::~CScriptVarLink()
         8   -> operator delete(void *)
       8   CScriptVar::setArray()
         8   -> CScriptVar::removeAllChildren()
         8   -> string::operator=(char const *)
     112   CScriptVar::setArrayIndex(int, CScriptVar *)
       112   -> CScriptVar::addChild(string const &, CScriptVar *)
       112   -> CScriptVar::findChild(string const &)
       112   -> CScriptVar::isUndefined()
       112   -> CScriptVar::removeLink(CScriptVarLink *)
       112   -> CScriptVarLink::replaceWith(CScriptVar *)
       112   -> snprintf
       112   -> string::string(char const *)
       112   -> string::~string()
       0   CScriptVar::setCallback(JSCallback, void *)
       8   CScriptVar::setDouble(double)
         8   -> string::operator=(char const *)
       8   CScriptVar::setInt(int)
         8   -> string::operator=(char const *)
      40   CScriptVar::setReturnVar(CScriptVar *)
        40   -> CScriptVar::findChildOrCreate(string const &, int)
        40   -> CScriptVarLink::replaceWith(CScriptVar *)
        40   -> string::string(char const *)
        40   -> string::~string()
       8   CScriptVar::setString(string const &)
         8   -> string::operator=(string const &)
       8   CScriptVar::setUndefined()
         8   -> CScriptVar::removeAllChildren()
         8   -> string::operator=(char const *)
       8   CScriptVar::subobject CScriptVar()
         8   -> CScriptVar::CScriptVar()
       8   CScriptVar::subobject CScriptVar(double)
         8   -> CScriptVar::CScriptVar(double)
       8   CScriptVar::subobject CScriptVar(int)
         8   -> CScriptVar::CScriptVar(int)
       8   CScriptVar::subobject CScriptVar(string const &)
         8   -> CScriptVar::CScriptVar(string const &)
       8   CScriptVar::subobject CScriptVar(string const &, int)
         8   -> CScriptVar::CScriptVar(string const &, int)
       8   CScriptVar::subobject ~CScriptVar()
         8   -> CScriptVar::~CScriptVar()
      72   CScriptVar::trace(string, string const &)
        72   -> CScriptVar::getFlagsAsString()
        72   -> CScriptVar::getString()
        72   -> CScriptVar::trace(string, string const &)
        72   -> operator+(string const &, char const *)
        72   -> string::c_str() const
        72   -> string::string(string const &)
        72   -> string::~string()
       8   CScriptVar::unref()
         8   -> CScriptVar::~CScriptVar()
         8   -> operator delete(void *)
         8   -> printf
       8   CScriptVar::~CScriptVar()
         8   -> CScriptVar::removeAllChildren()
         8   -> string::~string()
      24   CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
        24   -> CScriptVar::ref()
        24   -> string::operator=(string const &)
        24   -> string::string()
      24   CScriptVarLink::CScriptVarLink(CScriptVarLink const &)
        24   -> CScriptVar::ref()
        24   -> string::operator=(string const &)
        24   -> string::string()
       8   CScriptVarLink::getIntName()
         8   -> atoi
         8   -> string::c_str() const
      16   CScriptVarLink::replaceWith(CScriptVar *)
        16   -> CScriptVar::ref()
        16   -> CScriptVar::unref()
       8   CScriptVarLink::replaceWith(CScriptVarLink *)
         8   -> CScriptVar::CScriptVar()
         8   -> CScriptVarLink::replaceWith(CScriptVar *)
         8   -> operator new(size_t)
      72   CScriptVarLink::setIntName(int)
        72   -> snprintf
        72   -> string::operator=(char const *)
       8   CScriptVarLink::subobject CScriptVarLink(CScriptVar *, string const &)
         8   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       8   CScriptVarLink::subobject CScriptVarLink(CScriptVarLink const &)
         8   -> CScriptVarLink::CScriptVarLink(CScriptVarLink const &)
       8   CScriptVarLink::subobject ~CScriptVarLink()
         8   -> CScriptVarLink::~CScriptVarLink()
       8   CScriptVarLink::~CScriptVarLink()
         8   -> CScriptVar::unref()
         8   -> string::~string()
     136   CTinyJS::CTinyJS()
       136   -> CScriptVar::CScriptVar(string const &, int)
       136   -> CScriptVar::addChild(string const &, CScriptVar *)
       136   -> CScriptVar::ref()
       136   -> operator new(size_t)
       136   -> string::string(char const *)
       136   -> string::~string()
       136   -> vector<CScriptVar *>::vector()
      88   CTinyJS::addNative(string const &, JSCallback, void *)
        88   -> CScriptLex::CScriptLex(string const &)
        88   -> CScriptLex::match(int)
        88   -> CScriptLex::~CScriptLex()
        88   -> CScriptVar::CScriptVar(string const &, int)
        88   -> CScriptVar::addChild(string const &, CScriptVar *)
        88   -> CScriptVar::findChild(string const &)
        88   -> CScriptVar::setCallback(JSCallback, void *)
        88   -> CTinyJS::parseFunctionArguments(CScriptVar *)
        88   -> operator delete(void *)
        88   -> operator new(size_t)
        88   -> string::operator=(string const &)
        88   -> string::string(char const *)
        88   -> string::string(string const &)
        88   -> string::~string()
      24   CTinyJS::base(bool &)
        24   -> CScriptLex::match(int)
        24   -> CScriptVar::addChildNoDup(string const &, CScriptVar *)
        24   -> CScriptVar::mathsOp(CScriptVar *, int)
        24   -> CScriptVarLink::replaceWith(CScriptVar *)
        24   -> CScriptVarLink::replaceWith(CScriptVarLink *)
        24   -> CScriptVarLink::~CScriptVarLink()
        24   -> CTinyJS::base(bool &)
        24   -> CTinyJS::ternary(bool &)
        24   -> __aeabi_assert
        24   -> __iar_EmptyStepPoint
        24   -> operator delete(void *)
      16   CTinyJS::block(bool &)
        16   -> CScriptLex::match(int)
        16   -> CTinyJS::statement(bool &)
      56   CTinyJS::condition(bool &)
        56   -> CScriptLex::match(int)
        56   -> CScriptVar::mathsOp(CScriptVar *, int)
        56   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
        56   -> CScriptVarLink::replaceWith(CScriptVar *)
        56   -> CScriptVarLink::~CScriptVarLink()
        56   -> CTinyJS::shift(bool &)
        56   -> operator delete(void *)
        56   -> operator new(size_t)
        56   -> string::string(char const *)
        56   -> string::~string()
      56   CTinyJS::evaluate(string const &)
        56   -> CScriptVar::getString()
        56   -> CScriptVarLink::~CScriptVarLink()
        56   -> CTinyJS::evaluateComplex(string const &)
        56   -> string::string(string const &)
     112   CTinyJS::evaluateComplex(string const &)
       112   -> CScriptLex::CScriptLex(string const &)
       112   -> CScriptLex::match(int)
       112   -> CScriptLex::~CScriptLex()
       112   -> CScriptVar::CScriptVar()
       112   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       112   -> CScriptVarLink::CScriptVarLink(CScriptVarLink const &)
       112   -> CScriptVarLink::~CScriptVarLink()
       112   -> CTinyJS::base(bool &)
       112   -> operator delete(void *)
       112   -> operator new(size_t)
       112   -> string::string(char const *)
       112   -> string::~string()
       112   -> vector<CScriptVar *>::clear()
       112   -> vector<CScriptVar *>::operator=(vector<CScriptVar *> const &)
       112   -> vector<CScriptVar *>::push_back(CScriptVar *)
       112   -> vector<CScriptVar *>::vector(vector<CScriptVar *> const &)
       112   -> vector<CScriptVar *>::~vector()
      32   CTinyJS::execute(string const &)
        32   -> CScriptLex::CScriptLex(string const &)
        32   -> CScriptLex::~CScriptLex()
        32   -> CTinyJS::statement(bool &)
        32   -> operator delete(void *)
        32   -> operator new(size_t)
        32   -> vector<CScriptVar *>::clear()
        32   -> vector<CScriptVar *>::operator=(vector<CScriptVar *> const &)
        32   -> vector<CScriptVar *>::push_back(CScriptVar *)
        32   -> vector<CScriptVar *>::vector(vector<CScriptVar *> const &)
        32   -> vector<CScriptVar *>::~vector()
     136   CTinyJS::expression(bool &)
       136   -> CScriptLex::match(int)
       136   -> CScriptVar::CScriptVar(int)
       136   -> CScriptVar::mathsOp(CScriptVar *, int)
       136   -> CScriptVar::~CScriptVar()
       136   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       136   -> CScriptVarLink::replaceWith(CScriptVar *)
       136   -> CScriptVarLink::~CScriptVarLink()
       136   -> CTinyJS::term(bool &)
       136   -> operator delete(void *)
       136   -> operator new(size_t)
       136   -> string::string(char const *)
       136   -> string::~string()
     104   CTinyJS::factor(bool &)
       104   -> CScriptLex::match(int)
       104   -> CScriptVar::CScriptVar()
       104   -> CScriptVar::CScriptVar(int)
       104   -> CScriptVar::CScriptVar(string const &, int)
       104   -> CScriptVar::addChild(string const &, CScriptVar *)
       104   -> CScriptVar::findChild(string const &)
       104   -> CScriptVar::findChildOrCreate(string const &, int)
       104   -> CScriptVar::getArrayLength()
       104   -> CScriptVar::getString()
       104   -> CScriptVar::isArray()
       104   -> CScriptVar::isFunction()
       104   -> CScriptVar::isString()
       104   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       104   -> CScriptVarLink::~CScriptVarLink()
       104   -> CTinyJS::base(bool &)
       104   -> CTinyJS::findInParentClasses(CScriptVar *, string const &)
       104   -> CTinyJS::findInScopes(string const &)
       104   -> CTinyJS::functionCall(bool &, CScriptVarLink *, CScriptVar *)
       104   -> CTinyJS::parseFunctionDefinition()
       104   -> operator delete(void *)
       104   -> operator new(size_t)
       104   -> operator!=(string const &, char const *)
       104   -> operator==(string const &, char const *)
       104   -> snprintf
       104   -> string::c_str() const
       104   -> string::string(char const *)
       104   -> string::string(string const &)
       104   -> string::~string()
      48   CTinyJS::findInParentClasses(CScriptVar *, string const &)
        48   -> CScriptVar::findChild(string const &)
        48   -> CScriptVar::isArray()
        48   -> CScriptVar::isString()
        48   -> string::string(char const *)
        48   -> string::~string()
      16   CTinyJS::findInScopes(string const &)
        16   -> CScriptVar::findChild(string const &)
        16   -> _Vector_value<allocator<void>>::_Size<4U>() const
     152   CTinyJS::functionCall(bool &, CScriptVarLink *, CScriptVar *)
       152   -- Indirect call
       152   -> CScriptException::CScriptException(string const &)
       152   -> CScriptLex::CScriptLex(string const &)
       152   -> CScriptLex::match(int)
       152   -> CScriptLex::~CScriptLex()
       152   -> CScriptVar::CScriptVar()
       152   -> CScriptVar::CScriptVar(string const &, int)
       152   -> CScriptVar::addChild(string const &, CScriptVar *)
       152   -> CScriptVar::addChildNoDup(string const &, CScriptVar *)
       152   -> CScriptVar::deepCopy()
       152   -> CScriptVar::getString()
       152   -> CScriptVar::isFunction()
       152   -> CScriptVar::removeLink(CScriptVarLink *)
       152   -> CScriptVar::~CScriptVar()
       152   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       152   -> CScriptVarLink::~CScriptVarLink()
       152   -> CTinyJS::base(bool &)
       152   -> CTinyJS::block(bool &)
       152   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Pop_back()
       152   -> __aeabi_assert
       152   -> __iar_EmptyStepPoint
       152   -> operator delete(void *)
       152   -> operator new(size_t)
       152   -> operator+(string const &, char const *)
       152   -> operator+(string const &, string const &)
       152   -> string::c_str() const
       152   -> string::operator=(string const &)
       152   -> string::string(char const *)
       152   -> string::~string()
       152   -> vector<CScriptVar *>::push_back(CScriptVar *)
      56   CTinyJS::getScriptVariable(string const &)
        56   -> CScriptVar::findChild(string const &)
        56   -> string::find(char, size_t) const
        56   -> string::substr(size_t, size_t) const
        56   -> string::~string()
       8   CTinyJS::getVariable(string const &)
         8   -> CScriptVar::getString()
         8   -> CTinyJS::getScriptVariable(string const &)
      64   CTinyJS::logic(bool &)
        64   -> CScriptLex::match(int)
        64   -> CScriptVar::CScriptVar(int)
        64   -> CScriptVar::getBool()
        64   -> CScriptVar::mathsOp(CScriptVar *, int)
        64   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
        64   -> CScriptVarLink::replaceWith(CScriptVar *)
        64   -> CScriptVarLink::~CScriptVarLink()
        64   -> CTinyJS::condition(bool &)
        64   -> operator delete(void *)
        64   -> operator new(size_t)
        64   -> string::string(char const *)
        64   -> string::~string()
      16   CTinyJS::parseFunctionArguments(CScriptVar *)
        16   -> CScriptLex::match(int)
        16   -> CScriptVar::addChildNoDup(string const &, CScriptVar *)
     112   CTinyJS::parseFunctionDefinition()
       112   -> CScriptLex::getSubString(int)
       112   -> CScriptLex::match(int)
       112   -> CScriptVar::CScriptVar(string const &, int)
       112   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       112   -> CTinyJS::block(bool &)
       112   -> CTinyJS::parseFunctionArguments(CScriptVar *)
       112   -> operator new(size_t)
       112   -> string::operator=(string const &)
       112   -> string::string(char const *)
       112   -> string::~string()
      40   CTinyJS::setVariable(string const &, string const &)
        40   -> CScriptVar::isDouble()
        40   -> CScriptVar::isInt()
        40   -> CScriptVar::setDouble(double)
        40   -> CScriptVar::setInt(int)
        40   -> CScriptVar::setString(string const &)
        40   -> CTinyJS::getScriptVariable(string const &)
        40   -> string::c_str() const
        40   -> string::string(char const *)
        40   -> string::~string()
        40   -> strtod
        40   -> strtol
      24   CTinyJS::shift(bool &)
        24   -> CScriptLex::match(int)
        24   -> CScriptVar::getInt()
        24   -> CScriptVar::setInt(int)
        24   -> CScriptVarLink::~CScriptVarLink()
        24   -> CTinyJS::base(bool &)
        24   -> CTinyJS::expression(bool &)
        24   -> operator delete(void *)
     160   CTinyJS::statement(bool &)
       160   -> CScriptException::CScriptException(string const &)
       160   -> CScriptLex::getPosition(int)
       160   -> CScriptLex::getSubLex(int)
       160   -> CScriptLex::match(int)
       160   -> CScriptLex::reset()
       160   -> CScriptLex::~CScriptLex()
       160   -> CScriptVar::addChildNoDup(string const &, CScriptVar *)
       160   -> CScriptVar::findChild(string const &)
       160   -> CScriptVar::findChildOrCreate(string const &, int)
       160   -> CScriptVar::getBool()
       160   -> CScriptVar::trace(string, string const &)
       160   -> CScriptVarLink::replaceWith(CScriptVarLink *)
       160   -> CScriptVarLink::~CScriptVarLink()
       160   -> CTinyJS::base(bool &)
       160   -> CTinyJS::block(bool &)
       160   -> CTinyJS::parseFunctionDefinition()
       160   -> CTinyJS::statement(bool &)
       160   -> operator delete(void *)
       160   -> operator new(size_t)
       160   -> operator==(string const &, char const *)
       160   -> string::c_str() const
       160   -> string::string(char const *)
       160   -> string::~string()
       160   -> vector<CScriptVar *>::back()
       8   CTinyJS::subobject CTinyJS()
         8   -> CTinyJS::CTinyJS()
       8   CTinyJS::subobject ~CTinyJS()
         8   -> CTinyJS::~CTinyJS()
      56   CTinyJS::term(bool &)
        56   -> CScriptLex::match(int)
        56   -> CScriptVar::mathsOp(CScriptVar *, int)
        56   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
        56   -> CScriptVarLink::replaceWith(CScriptVar *)
        56   -> CScriptVarLink::~CScriptVarLink()
        56   -> CTinyJS::unary(bool &)
        56   -> operator delete(void *)
        56   -> operator new(size_t)
        56   -> string::string(char const *)
        56   -> string::~string()
      32   CTinyJS::ternary(bool &)
        32   -> CScriptLex::match(int)
        32   -> CScriptVar::getBool()
        32   -> CScriptVarLink::~CScriptVarLink()
        32   -> CTinyJS::base(bool &)
        32   -> CTinyJS::logic(bool &)
        32   -> operator delete(void *)
      72   CTinyJS::trace()
        72   -> CScriptVar::trace(string, string const &)
        72   -> string::string(char const *)
        72   -> string::~string()
     120   CTinyJS::unary(bool &)
       120   -> CScriptLex::match(int)
       120   -> CScriptVar::CScriptVar(int)
       120   -> CScriptVar::mathsOp(CScriptVar *, int)
       120   -> CScriptVar::~CScriptVar()
       120   -> CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
       120   -> CScriptVarLink::replaceWith(CScriptVar *)
       120   -> CTinyJS::factor(bool &)
       120   -> operator new(size_t)
       120   -> string::string(char const *)
       120   -> string::~string()
       8   CTinyJS::~CTinyJS()
         8   -> CScriptVar::unref()
         8   -> __aeabi_assert
         8   -> __iar_EmptyStepPoint
         8   -> vector<CScriptVar *>::clear()
         8   -> vector<CScriptVar *>::~vector()
       8   _Allocator<void>::allocate(unsigned int)
         8   -> operator new(size_t)
       8   _Copy_backward_opt(unsigned int const *, unsigned int const *, unsigned int *)
         8   -> __iar_Copy_backward_a4
       8   _Copy_opt(unsigned int const *, unsigned int const *, unsigned int *)
         8   -> __iar_Copy_a4
       4   _String_val::subobject _String_val(char_allocator)
       8   _Uninit_copier<unsigned int, true>::_Copy(unsigned int const *, unsigned int const *, unsigned int *)
         8   -> __iar_Copy_a4
       8   _Uninit_copy(unsigned int const *, unsigned int const *, unsigned int *, allocator<unsigned int> &)
         8   -> _Uninit_copier<unsigned int, true>::_Copy(unsigned int const *, unsigned int const *, unsigned int *)
       0   _Uninitialized_fill_n(unsigned int *, unsigned int, unsigned int const &, allocator<unsigned int> &)
       0   _Vector_impl<unsigned int, allocator<unsigned int>>::_Altyval() const
      24   _Vector_impl<unsigned int, allocator<unsigned int>>::_Assign(_Vector_impl<unsigned int, allocator<unsigned int>> const &)
        24   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Altyval() const
        24   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy()
        24   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Ucopy(unsigned int const *, unsigned int const *, unsigned int *)
        24   -> _Vector_impl<unsigned int, allocator<unsigned int>>::capacity() const
        24   -> _Vector_impl<unsigned int, allocator<unsigned int>>::size() const
        24   -> _Vector_value<allocator<void>>::_Bsize() const
        24   -> _Vector_value<allocator<void>>::_Buy(unsigned int)
        24   -> allocator<unsigned int>::deallocate(unsigned int *, unsigned int)
        24   -> copy(unsigned int *, unsigned int *, unsigned int *)
       0   _Vector_impl<unsigned int, allocator<unsigned int>>::_EraseAll()
      16   _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert0(unsigned int *, unsigned int)
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert_n(unsigned int *, unsigned int, unsigned int const &)
      16   _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert_n(unsigned int *, unsigned int, unsigned int const &)
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Make_room(unsigned int *, unsigned int)
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Ufill(unsigned int *, unsigned int, unsigned int)
      40   _Vector_impl<unsigned int, allocator<unsigned int>>::_Make_room(unsigned int *, unsigned int)
        40   -> _Allocator<void>::allocate(unsigned int)
        40   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy0()
        40   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Ucopy(unsigned int const *, unsigned int const *, unsigned int *)
        40   -> _Vector_impl<unsigned int, allocator<unsigned int>>::capacity() const
        40   -> _Vector_impl<unsigned int, allocator<unsigned int>>::size() const
        40   -> copy_backward(unsigned int *, unsigned int *, unsigned int *)
       8   _Vector_impl<unsigned int, allocator<unsigned int>>::_Pop_back()
         8   -> _Vector_value<allocator<void>>::_Bsize() const
       8   _Vector_impl<unsigned int, allocator<unsigned int>>::_Push_back0(unsigned int)
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert0(unsigned int *, unsigned int)
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Ufill(unsigned int *, unsigned int, unsigned int)
       8   _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy()
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy0()
         8   -> _Vector_value<allocator<void>>::_Zero()
      16   _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy0()
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Altyval() const
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_EraseAll()
        16   -> allocator<unsigned int>::deallocate(unsigned int *, unsigned int)
       8   _Vector_impl<unsigned int, allocator<unsigned int>>::_Ucopy(unsigned int const *, unsigned int const *, unsigned int *)
         8   -> _Uninit_copy(unsigned int const *, unsigned int const *, unsigned int *, allocator<unsigned int> &)
      24   _Vector_impl<unsigned int, allocator<unsigned int>>::_Ufill(unsigned int *, unsigned int, unsigned int)
        24   -> _Uninitialized_fill_n(unsigned int *, unsigned int, unsigned int const &, allocator<unsigned int> &)
      16   _Vector_impl<unsigned int, allocator<unsigned int>>::_Vector_impl(allocator<unsigned int>)
        16   -> _Vector_value<allocator<void>>::_Vector_value(allocator<void>)
       0   _Vector_impl<unsigned int, allocator<unsigned int>>::capacity() const
       8   _Vector_impl<unsigned int, allocator<unsigned int>>::size() const
         8   -> _Vector_value<allocator<void>>::_Size<4U>() const
       0   _Vector_value<allocator<void>>::_Bsize() const
      16   _Vector_value<allocator<void>>::_Buy(unsigned int)
        16   -> _Allocator<void>::allocate(unsigned int)
        16   -> _Vector_value<allocator<void>>::_Zero()
       8   _Vector_value<allocator<void>>::_Size<4U>() const
         8   -> _Vector_value<allocator<void>>::_Bsize() const
       0   _Vector_value<allocator<void>>::_Vector_value(allocator<void>)
       0   _Vector_value<allocator<void>>::_Zero()
       8   allocator<unsigned int>::deallocate(unsigned int *, unsigned int)
         8   -> operator delete(void *)
       8   char_traits::copy(char *, char const *, size_t)
         8   -> __aeabi_memcpy
       0   char_traits::eq_int_type(int const &, int const &)
       8   char_traits::length(char const *)
         8   -> strlen
       8   copy(unsigned int *, unsigned int *, unsigned int *)
         8   -> _Copy_opt(unsigned int const *, unsigned int const *, unsigned int *)
       8   copy_backward(unsigned int *, unsigned int *, unsigned int *)
         8   -> _Copy_backward_opt(unsigned int const *, unsigned int const *, unsigned int *)
      64   exec()
        64   -> CTinyJS::CTinyJS()
        64   -> CTinyJS::addNative(string const &, JSCallback, void *)
        64   -> CTinyJS::execute(string const &)
        64   -> CTinyJS::~CTinyJS()
        64   -> operator delete(void *)
        64   -> operator new(size_t)
        64   -> string::string(char const *)
        64   -> string::~string()
       8   fpos::fpos(long)
         8   -> __aeabi_memcpy4
     176   getJSString(string const &)
       176   -> operator+(char const *, string const &)
       176   -> operator+(string const &, char const *)
       176   -> operator+(string const &, string const &)
       176   -> snprintf
       176   -> string::operator=(string const &)
       176   -> string::operator[](size_t)
       176   -> string::string(string const &)
       176   -> string::substr(size_t, size_t) const
       176   -> string::~string()
       176   -> strlen
       8   ios::deleter ~ios()
         8   -> ios::~ios()
         8   -> operator delete(void *)
       8   ios::setstate(int, bool)
         8   -> ios_base::clear(int, bool)
       8   ios::~ios()
         8   -> ios_base::subobject ~ios_base()
       0   isAlpha(char)
      16   isAlphaNum(string const &)
        16   -> isAlpha(char)
        16   -> isNumeric(char)
        16   -> string::operator[](size_t) const
       0   isHexadecimal(char)
       8   isIDString(char const *)
         8   -> isAlpha(char)
         8   -> isNumeric(char)
      16   isNumber(string const &)
        16   -> isNumeric(char)
        16   -> string::operator[](size_t) const
       0   isNumeric(char)
       0   isWhitespace(char)
      40   js_print(CScriptVar *, void *)
        40   -> CDC_Send_DATA_str
        40   -> CScriptVar::getParameter(string const &)
        40   -> CScriptVar::getString()
        40   -> string::c_str() const
        40   -> string::string(char const *)
        40   -> string::~string()
       8   operator!=(string const &, char const *)
         8   -> operator==(string const &, char const *)
      40   operator+(char const *, string const &)
        40   -> string::operator+=(string const &)
        40   -> string::string(char const *)
        40   -> string::string(string const &)
        40   -> string::~string()
      40   operator+(string const &, char const *)
        40   -> char_traits::length(char const *)
        40   -> string::append(char const *, size_t)
        40   -> string::string(string const &)
        40   -> string::~string()
      40   operator+(string const &, string const &)
        40   -> string::operator+=(string const &)
        40   -> string::string(string const &)
        40   -> string::~string()
       8   operator<(string const &, string const &)
         8   -> string::compare(string const &) const
      16   operator==(string const &, char const *)
        16   -> char_traits::length(char const *)
        16   -> string::compare(size_t, size_t, char const *, size_t) const
       8   operator==(string const &, string const &)
         8   -> string::compare(string const &) const
       8   ostream::deleter ~ostream()
         8   -> operator delete(void *)
         8   -> ostream::~ostream()
      16   ostream::ostream(streambuf *, bool)
        16   -> ios::setstate(int, bool)
        16   -> ios_base::_Addstd()
        16   -> ios_base::_Init()
       8   ostream::~ostream()
         8   -> ios::~ios()
       8   ostringstream::deleter ~ostringstream()
         8   -> operator delete(void *)
         8   -> ostringstream::~ostringstream()
      16   ostringstream::ostringstream(int)
        16   -> ostream::ostream(streambuf *, bool)
        16   -> stringbuf::stringbuf(int)
       8   ostringstream::str() const
         8   -> stringbuf::str() const
       8   ostringstream::~ostringstream()
         8   -> ostream::~ostream()
         8   -> stringbuf::~stringbuf()
       0   putchar
     144   replace(string &, char, char const *)
       144   -> operator+(string const &, char const *)
       144   -> operator+(string const &, string const &)
       144   -> string::find(char, size_t) const
       144   -> string::operator=(string const &)
       144   -> string::substr(size_t, size_t) const
       144   -> string::~string()
       144   -> strlen
       0   streambuf::_Init()
       8   streambuf::_Lock()
         8   -> __iar_Mutex::_Lock()
       8   streambuf::_Unlock()
         8   -> __iar_Mutex::_Unlock()
       8   streambuf::deleter ~streambuf()
         8   -> operator delete(void *)
         8   -> streambuf::~streambuf()
       0   streambuf::imbue(locale const &)
       0   streambuf::overflow(int)
       0   streambuf::pbackfail(int)
      40   streambuf::seekoff(long, int, int)
        40   -> __aeabi_memcpy4
        40   -> fpos::fpos(long)
      48   streambuf::seekpos(fpos, int)
        48   -> __aeabi_memcpy4
        48   -> fpos::fpos(long)
       0   streambuf::setbuf(char *, int)
       0   streambuf::showmanyc()
       0   streambuf::sync()
      24   streambuf::uflow()
        24   -- Indirect call
        24   -> char_traits::eq_int_type(int const &, int const &)
       0   streambuf::underflow()
      32   streambuf::xsgetn(char *, int)
        32   -- Indirect call
        32   -> char_traits::copy(char *, char const *, size_t)
        32   -> char_traits::eq_int_type(int const &, int const &)
      32   streambuf::xsputn(char const *, int)
        32   -- Indirect call
        32   -> char_traits::copy(char *, char const *, size_t)
        32   -> char_traits::eq_int_type(int const &, int const &)
       8   streambuf::~streambuf()
         8   -> __iar_Mutex::~__iar_Mutex()
         8   -> operator delete(void *)
       0   string::_Myptr()
       0   string::_Myptr() const
       0   string::_Pdif(char const *, char const *)
      16   string::assign(char const *)
        16   -> char_traits::length(char const *)
        16   -> string::assign(char const *, size_t)
       8   string::begin()
         8   -> string::_Myptr()
       8   string::c_str() const
         8   -> string::_Myptr() const
      24   string::clear()
        24   -> string::_Myptr()
        24   -> string::_Pdif(char const *, char const *)
        24   -> string::begin()
        24   -> string::erase(size_t, size_t)
      16   string::compare(string const &) const
        16   -> string::_Myptr() const
        16   -> string::compare(size_t, size_t, char const *, size_t) const
       8   string::find(char, size_t) const
         8   -> string::find(char const *, size_t, size_t) const
       8   string::operator+=(char)
         8   -> string::append(size_t, char)
       8   string::operator+=(string const &)
         8   -> string::append(string const &, size_t, size_t)
       8   string::operator=(char const *)
         8   -> string::assign(char const *)
       8   string::operator=(string const &)
         8   -> string::assign(string const &, size_t, size_t)
       8   string::operator[](size_t)
         8   -> string::_Myptr()
       8   string::operator[](size_t) const
         8   -> string::_Myptr() const
      16   string::string()
        16   -> _String_val::subobject _String_val(char_allocator)
        16   -> string::_Tidy(bool, size_t)
      16   string::string(char const *)
        16   -> _String_val::subobject _String_val(char_allocator)
        16   -> string::_Tidy(bool, size_t)
        16   -> string::assign(char const *)
      16   string::string(string const &)
        16   -> _String_val::subobject _String_val(char_allocator)
        16   -> string::_Tidy(bool, size_t)
        16   -> string::assign(string const &, size_t, size_t)
      24   string::string(string const &, size_t, size_t, string::_Alloc const &)
        24   -> _String_val::subobject _String_val(char_allocator)
        24   -> string::_Tidy(bool, size_t)
        24   -> string::assign(string const &, size_t, size_t)
      16   string::substr(size_t, size_t) const
        16   -> string::string(string const &, size_t, size_t, string::_Alloc const &)
       8   string::~string()
         8   -> string::_Tidy(bool, size_t)
      16   stringbuf::stringbuf(int)
        16   -> __iar_Mutex::__iar_Mutex()
        16   -> operator new(size_t)
        16   -> streambuf::_Init()
        16   -> stringbuf::_Getstate(int)
        16   -> stringbuf::_Init(char const *, size_t, int)
       8   stringbuf::~stringbuf()
         8   -> streambuf::~streambuf()
         8   -> stringbuf::_Tidy()
       0   vector<CScriptVar *>::back()
       8   vector<CScriptVar *>::clear()
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy()
       8   vector<CScriptVar *>::operator=(vector<CScriptVar *> const &)
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Assign(_Vector_impl<unsigned int, allocator<unsigned int>> const &)
       8   vector<CScriptVar *>::push_back(CScriptVar *)
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Push_back0(unsigned int)
       8   vector<CScriptVar *>::vector()
         8   -> _Vector_value<allocator<void>>::_Zero()
      16   vector<CScriptVar *>::vector(vector<CScriptVar *> const &)
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Altyval() const
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Assign(_Vector_impl<unsigned int, allocator<unsigned int>> const &)
        16   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Vector_impl(allocator<unsigned int>)
        16   -> _Vector_value<allocator<void>>::_Zero()
       8   vector<CScriptVar *>::~vector()
         8   -> _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ?<Constant "  ">
       2  ?<Constant " ">
       4  ?<Constant " : ">
       8  ?<Constant " at ">
      12  ?<Constant " expected ">
      36  ?<Constant " not supported on the...">
      40  ?<Constant " not supported on the...">_1
      40  ?<Constant " not supported on the...">_2
      40  ?<Constant " not supported on the...">_3
      40  ?<Constant " not supported on the...">_4
       4  ?<Constant "!=">
       4  ?<Constant "!==">
       4  ?<Constant "!l">
       1  ?<Constant "">
       4  ?<Constant "%d">
       4  ?<Constant "%f">
       4  ?<Constant "%ld">
       4  ?<Constant "&&">
       4  ?<Constant "&=">
      20  ?<Constant "(line: %d, col: %d)">
       4  ?<Constant ") ">
       4  ?<Constant "++">
       4  ?<Constant "+=">
       2  ?<Constant ",">
       4  ?<Constant ",\n">
       4  ?<Constant "--">
       4  ?<Constant "-=">
       2  ?<Constant "0">
       4  ?<Constant "<<">
       4  ?<Constant "<<=">
       4  ?<Constant "<=">
       4  ?<Constant "==">
       4  ?<Constant "===">
       4  ?<Constant ">=">
       4  ?<Constant ">>">
       4  ?<Constant ">>=">
       4  ?<Constant "??">
       4  ?<Constant "???">
       4  ?<Constant "?[">
       8  ?<Constant "ARRAY ">
       8  ?<Constant "Array">
      68  ?<Constant "D:\\Projects\\3DPrint\\S...">
       8  ?<Constant "DOUBLE ">
       4  ?<Constant "EOF">
      12  ?<Constant "Expecting \'">
       8  ?<Constant "FLOAT">
      12  ?<Constant "FUNCTION ">
       8  ?<Constant "Got ">
       4  ?<Constant "ID">
       4  ?<Constant "INT">
      12  ?<Constant "INTEGER ">
      12  ?<Constant "LOOP_ERROR">
       8  ?<Constant "NATIVE ">
       8  ?<Constant "OBJECT ">
      36  ?<Constant "OMFG, we have unreffe...">
       8  ?<Constant "Object">
      12  ?<Constant "Operation ">
       8  ?<Constant "STRING ">
       8  ?<Constant "STRING">
       8  ?<Constant "String">
       4  ?<Constant "[\n">
       2  ?<Constant "\"">
       4  ?<Constant "\' \'">
      20  ?<Constant "\' to be a function">
       4  ?<Constant "\\\"">
       4  ?<Constant "\\\\">
       4  ?<Constant "\\a">
       4  ?<Constant "\\n">
       4  ?<Constant "\\r">
       8  ?<Constant "\\x%02X">
       2  ?<Constant "\n">
       2  ?<Constant "]">
       4  ?<Constant "^=">
       8  ?<Constant "break">
      12  ?<Constant "continue">
       4  ?<Constant "do">
       8  ?<Constant "else">
       8  ?<Constant "false">
       4  ?<Constant "for">
      12  ?<Constant "function (">
      24  ?<Constant "function print(text)">
      12  ?<Constant "function">
      28  ?<Constant "function->var->jsCall...">
       4  ?<Constant "if">
       8  ?<Constant "length">
       8  ?<Constant "link">
       4  ?<Constant "new">
       8  ?<Constant "null">
      12  ?<Constant "prototype">
       8  ?<Constant "return">
       8  ?<Constant "text">
       8  ?<Constant "this">
       8  ?<Constant "true">
      12  ?<Constant "undefined">
       4  ?<Constant "var">
       8  ?<Constant "while">
       4  ?<Constant "{ \n">
      56  ?<Constant "{ var t=0;for (var b=...">
       4  ?<Constant "|=">
       4  ?<Constant "||">
       2  ?<Constant "}">
       4  ??DataTable103
       4  ??DataTable103_1
       4  ??DataTable103_2
       4  ??DataTable103_3
       4  ??DataTable103_4
       4  ??DataTable103_5
       4  ??DataTable103_6
       4  ??DataTable103_7
       4  ??DataTable103_8
       4  ??DataTable104
       4  ??DataTable104_1
       4  ??DataTable104_10
       4  ??DataTable104_11
       4  ??DataTable104_12
       4  ??DataTable104_13
       4  ??DataTable104_14
       4  ??DataTable104_15
       4  ??DataTable104_16
       4  ??DataTable104_17
       4  ??DataTable104_18
       4  ??DataTable104_19
       4  ??DataTable104_2
       4  ??DataTable104_20
       4  ??DataTable104_21
       4  ??DataTable104_22
       4  ??DataTable104_23
       4  ??DataTable104_24
       4  ??DataTable104_25
       4  ??DataTable104_26
       4  ??DataTable104_27
       4  ??DataTable104_28
       4  ??DataTable104_29
       4  ??DataTable104_3
       4  ??DataTable104_30
       4  ??DataTable104_31
       4  ??DataTable104_32
       4  ??DataTable104_33
       4  ??DataTable104_34
       4  ??DataTable104_35
       4  ??DataTable104_36
       4  ??DataTable104_37
       4  ??DataTable104_38
       4  ??DataTable104_39
       4  ??DataTable104_4
       4  ??DataTable104_40
       4  ??DataTable104_41
       4  ??DataTable104_5
       4  ??DataTable104_6
       4  ??DataTable104_7
       4  ??DataTable104_8
       4  ??DataTable104_9
       4  ??DataTable105
       4  ??DataTable105_1
       4  ??DataTable112
       4  ??DataTable113
       4  ??DataTable114
       4  ??DataTable114_1
       4  ??DataTable116
       4  ??DataTable117
       4  ??DataTable118
       4  ??DataTable118_1
       4  ??DataTable118_2
       4  ??DataTable118_3
       4  ??DataTable118_4
       4  ??DataTable118_5
       4  ??DataTable118_6
       4  ??DataTable119
       4  ??DataTable121
       4  ??DataTable122
       4  ??DataTable123
       4  ??DataTable123_1
       4  ??DataTable123_2
       4  ??DataTable124
       4  ??DataTable124_1
       4  ??DataTable124_2
       4  ??DataTable124_3
       4  ??DataTable125
       4  ??DataTable125_1
       4  ??DataTable126
       4  ??DataTable127
       4  ??DataTable128
       4  ??DataTable128_1
       4  ??DataTable128_2
       4  ??DataTable128_3
       4  ??DataTable128_4
       4  ??DataTable128_5
       4  ??DataTable128_6
       4  ??DataTable128_7
       4  ??DataTable129
       4  ??DataTable130
       4  ??DataTable130_1
       4  ??DataTable130_2
       4  ??DataTable131
       4  ??DataTable132
       4  ??DataTable132_1
       4  ??DataTable132_2
       4  ??DataTable132_3
       4  ??DataTable132_4
       4  ??DataTable132_5
       4  ??DataTable132_6
       4  ??DataTable135
       4  ??DataTable135_1
       4  ??DataTable136
       4  ??DataTable138
       4  ??DataTable139
       4  ??DataTable139_1
       4  ??DataTable140
       4  ??DataTable140_1
       4  ??DataTable142
       4  ??DataTable142_1
       4  ??DataTable142_2
       8  ?Subroutine0
      30  ?Subroutine1
       8  ?Subroutine2
      12  ?Subroutine3
      18  CScriptException::CScriptException(string const &)
       8  CScriptException::subobject CScriptException(string const &)
      42  CScriptLex::CScriptLex(CScriptLex *, int, int)
      52  CScriptLex::CScriptLex(string const &)
      28  CScriptLex::getNextCh()
    1308  CScriptLex::getNextToken()
      76  CScriptLex::getPosition(int)
      52  CScriptLex::getSubLex(int)
      70  CScriptLex::getSubString(int)
     406  CScriptLex::getTokenStr(int)
     154  CScriptLex::match(int)
      48  CScriptLex::reset()
       8  CScriptLex::subobject CScriptLex(CScriptLex *, int, int)
       8  CScriptLex::subobject CScriptLex(string const &)
       8  CScriptLex::subobject ~CScriptLex()
      26  CScriptLex::~CScriptLex()
      26  CScriptVar::CScriptVar()
      38  CScriptVar::CScriptVar(double)
      34  CScriptVar::CScriptVar(int)
      32  CScriptVar::CScriptVar(string const &)
      86  CScriptVar::CScriptVar(string const &, int)
      84  CScriptVar::addChild(string const &, CScriptVar *)
      62  CScriptVar::addChildNoDup(string const &, CScriptVar *)
      50  CScriptVar::copySimpleData(CScriptVar *)
      66  CScriptVar::copyValue(CScriptVar *)
      78  CScriptVar::deepCopy()
      36  CScriptVar::equals(CScriptVar *)
      34  CScriptVar::findChild(string const &)
      74  CScriptVar::findChildOrCreate(string const &, int)
     102  CScriptVar::findChildOrCreateByPath(string const &)
      96  CScriptVar::getArrayIndex(int)
      56  CScriptVar::getArrayLength()
      16  CScriptVar::getBool()
      18  CScriptVar::getChildren()
      62  CScriptVar::getDouble()
     244  CScriptVar::getFlagsAsString()
      60  CScriptVar::getInt()
     288  CScriptVar::getJSON(ostringstream &, string)
      12  CScriptVar::getParameter(string const &)
     184  CScriptVar::getParsableString()
       4  CScriptVar::getRefs()
      36  CScriptVar::getReturnVar()
     150  CScriptVar::getString()
      36  CScriptVar::init()
       8  CScriptVar::isArray()
       8  CScriptVar::isDouble()
      10  CScriptVar::isFunction()
       8  CScriptVar::isInt()
       8  CScriptVar::isNull()
      16  CScriptVar::isNumeric()
       8  CScriptVar::isObject()
       8  CScriptVar::isString()
      16  CScriptVar::isUndefined()
    1608  CScriptVar::mathsOp(CScriptVar *, int)
       8  CScriptVar::ref()
      32  CScriptVar::removeAllChildren()
      44  CScriptVar::removeChild(CScriptVar *)
      60  CScriptVar::removeLink(CScriptVarLink *)
      16  CScriptVar::setArray()
     116  CScriptVar::setArrayIndex(int, CScriptVar *)
       6  CScriptVar::setCallback(JSCallback, void *)
      34  CScriptVar::setDouble(double)
      36  CScriptVar::setInt(int)
      42  CScriptVar::setReturnVar(CScriptVar *)
      36  CScriptVar::setString(string const &)
      14  CScriptVar::setUndefined()
       8  CScriptVar::subobject CScriptVar()
       8  CScriptVar::subobject CScriptVar(double)
       8  CScriptVar::subobject CScriptVar(int)
       8  CScriptVar::subobject CScriptVar(string const &)
       8  CScriptVar::subobject CScriptVar(string const &, int)
       8  CScriptVar::subobject ~CScriptVar()
     106  CScriptVar::trace(string, string const &)
      42  CScriptVar::unref()
      14  CScriptVar::~CScriptVar()
      34  CScriptVarLink::CScriptVarLink(CScriptVar *, string const &)
      30  CScriptVarLink::CScriptVarLink(CScriptVarLink const &)
      12  CScriptVarLink::getIntName()
      22  CScriptVarLink::replaceWith(CScriptVar *)
      36  CScriptVarLink::replaceWith(CScriptVarLink *)
      30  CScriptVarLink::setIntName(int)
       8  CScriptVarLink::subobject CScriptVarLink(CScriptVar *, string const &)
       8  CScriptVarLink::subobject CScriptVarLink(CScriptVarLink const &)
       8  CScriptVarLink::subobject ~CScriptVarLink()
      12  CScriptVarLink::~CScriptVarLink()
     274  CTinyJS::CTinyJS()
     246  CTinyJS::addNative(string const &, JSCallback, void *)
     212  CTinyJS::base(bool &)
      82  CTinyJS::block(bool &)
     194  CTinyJS::condition(bool &)
      36  CTinyJS::evaluate(string const &)
     246  CTinyJS::evaluateComplex(string const &)
     110  CTinyJS::execute(string const &)
     402  CTinyJS::expression(bool &)
    1670  CTinyJS::factor(bool &)
     126  CTinyJS::findInParentClasses(CScriptVar *, string const &)
      44  CTinyJS::findInScopes(string const &)
     670  CTinyJS::functionCall(bool &, CScriptVarLink *, CScriptVar *)
     112  CTinyJS::getScriptVariable(string const &)
      16  CTinyJS::getVariable(string const &)
     442  CTinyJS::logic(bool &)
      64  CTinyJS::parseFunctionArguments(CScriptVar *)
     180  CTinyJS::parseFunctionDefinition()
     118  CTinyJS::setVariable(string const &, string const &)
     162  CTinyJS::shift(bool &)
    1472  CTinyJS::statement(bool &)
       8  CTinyJS::subobject CTinyJS()
       8  CTinyJS::subobject ~CTinyJS()
     160  CTinyJS::term(bool &)
     222  CTinyJS::ternary(bool &)
      50  CTinyJS::trace()
     146  CTinyJS::unary(bool &)
      68  CTinyJS::~CTinyJS()
       8  _Allocator<void>::allocate(unsigned int)
       8  _Copy_backward_opt(unsigned int const *, unsigned int const *, unsigned int *)
       8  _Copy_opt(unsigned int const *, unsigned int const *, unsigned int *)
      12  _String_val::subobject _String_val(char_allocator)
       8  _Uninit_copier<unsigned int, true>::_Copy(unsigned int const *, unsigned int const *, unsigned int *)
       8  _Uninit_copy(unsigned int const *, unsigned int const *, unsigned int *, allocator<unsigned int> &)
      16  _Uninitialized_fill_n(unsigned int *, unsigned int, unsigned int const &, allocator<unsigned int> &)
       2  _Vector_impl<unsigned int, allocator<unsigned int>>::_Altyval() const
     152  _Vector_impl<unsigned int, allocator<unsigned int>>::_Assign(_Vector_impl<unsigned int, allocator<unsigned int>> const &)
       6  _Vector_impl<unsigned int, allocator<unsigned int>>::_EraseAll()
      32  _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert0(unsigned int *, unsigned int)
      26  _Vector_impl<unsigned int, allocator<unsigned int>>::_Insert_n(unsigned int *, unsigned int, unsigned int const &)
     164  _Vector_impl<unsigned int, allocator<unsigned int>>::_Make_room(unsigned int *, unsigned int)
      20  _Vector_impl<unsigned int, allocator<unsigned int>>::_Pop_back()
      36  _Vector_impl<unsigned int, allocator<unsigned int>>::_Push_back0(unsigned int)
      16  _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy()
      42  _Vector_impl<unsigned int, allocator<unsigned int>>::_Tidy0()
      16  _Vector_impl<unsigned int, allocator<unsigned int>>::_Ucopy(unsigned int const *, unsigned int const *, unsigned int *)
      26  _Vector_impl<unsigned int, allocator<unsigned int>>::_Ufill(unsigned int *, unsigned int, unsigned int)
      16  _Vector_impl<unsigned int, allocator<unsigned int>>::_Vector_impl(allocator<unsigned int>)
      10  _Vector_impl<unsigned int, allocator<unsigned int>>::capacity() const
       8  _Vector_impl<unsigned int, allocator<unsigned int>>::size() const
       8  _Vector_value<allocator<void>>::_Bsize() const
      38  _Vector_value<allocator<void>>::_Buy(unsigned int)
      10  _Vector_value<allocator<void>>::_Size<4U>() const
       2  _Vector_value<allocator<void>>::_Vector_value(allocator<void>)
      10  _Vector_value<allocator<void>>::_Zero()
      60  _ZGVs_null
          _ZGVs_undefined
          s_null
          s_undefined
      10  allocator<unsigned int>::deallocate(unsigned int *, unsigned int)
      12  char_traits::copy(char *, char const *, size_t)
      16  char_traits::eq_int_type(int const &, int const &)
       8  char_traits::length(char const *)
       8  copy(unsigned int *, unsigned int *, unsigned int *)
       8  copy_backward(unsigned int *, unsigned int *, unsigned int *)
      92  exec()
      40  fpos::fpos(long)
     232  getJSString(string const &)
      18  ios::deleter ~ios()
      30  ios::setstate(int, bool)
      12  ios::~ios()
      28  isAlpha(char)
      84  isAlphaNum(string const &)
      30  isHexadecimal(char)
      50  isIDString(char const *)
      40  isNumber(string const &)
      10  isNumeric(char)
      24  isWhitespace(char)
      46  js_print(CScriptVar *, void *)
      16  operator!=(string const &, char const *)
      38  operator+(char const *, string const &)
      48  operator+(string const &, char const *)
      38  operator+(string const &, string const &)
      10  operator<(string const &, string const &)
      34  operator==(string const &, char const *)
      14  operator==(string const &, string const &)
      18  ostream::deleter ~ostream()
      80  ostream::ostream(streambuf *, bool)
      12  ostream::~ostream()
      18  ostringstream::deleter ~ostringstream()
      40  ostringstream::ostringstream(int)
      10  ostringstream::str() const
      32  ostringstream::~ostringstream()
       2  putchar
     132  replace(string &, char, char const *)
      64  streambuf::_Init()
      10  streambuf::_Lock()
      10  streambuf::_Unlock()
      18  streambuf::deleter ~streambuf()
       2  streambuf::imbue(locale const &)
       6  streambuf::overflow(int)
       6  streambuf::pbackfail(int)
      36  streambuf::seekoff(long, int, int)
      44  streambuf::seekpos(fpos, int)
       2  streambuf::setbuf(char *, int)
       4  streambuf::showmanyc()
       4  streambuf::sync()
      46  streambuf::uflow()
       6  streambuf::underflow()
     112  streambuf::xsgetn(char *, int)
     110  streambuf::xsputn(char const *, int)
      28  streambuf::~streambuf()
      14  string::_Myptr()
      14  string::_Myptr() const
       8  string::_Pdif(char const *, char const *)
      24  string::assign(char const *)
       8  string::begin()
       8  string::c_str() const
      62  string::clear()
      28  string::compare(string const &) const
      12  string::find(char, size_t) const
      12  string::operator+=(char)
      20  string::operator+=(string const &)
       8  string::operator=(char const *)
      20  string::operator=(string const &)
      12  string::operator[](size_t)
      12  string::operator[](size_t) const
      26  string::string()
      34  string::string(char const *)
      52  string::string(string const &)
      50  string::string(string const &, size_t, size_t, string::_Alloc const &)
      12  string::substr(size_t, size_t) const
      16  string::~string()
      68  stringbuf::stringbuf(int)
      28  stringbuf::~stringbuf()
       6  vector<CScriptVar *>::back()
       8  vector<CScriptVar *>::clear()
      12  vector<CScriptVar *>::operator=(vector<CScriptVar *> const &)
       8  vector<CScriptVar *>::push_back(CScriptVar *)
      12  vector<CScriptVar *>::vector()
      38  vector<CScriptVar *>::vector(vector<CScriptVar *> const &)
      12  vector<CScriptVar *>::~vector()
     125  -- Other

 
     60 bytes in section .bss
    684 bytes in section .rodata
 18 582 bytes in section .text
 
 16 046 bytes of CODE  memory (+ 2 536 bytes shared)
    559 bytes of CONST memory (+   125 bytes shared)
     60 bytes of DATA  memory

Errors: none
Warnings: 12

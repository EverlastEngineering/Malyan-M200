###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Oct/2019  17:00:22
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_spi.c
#    Command line =
#        -f C:\Users\yongzong\AppData\Local\Temp\EW44C2.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_spi.c
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\stm32f0xx_spi.lst
#    Object file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\stm32f0xx_spi.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Libraries\STM32F0xx_StdPeriph_Driver\src\stm32f0xx_spi.c
      1          /**
      2            ******************************************************************************
      3            * @file    stm32f0xx_spi.c
      4            * @author  MCD Application Team
      5            * @version V1.3.0
      6            * @date    16-January-2014
      7            * @brief   This file provides firmware functions to manage the following 
      8            *          functionalities of the Serial peripheral interface (SPI):
      9            *           + Initialization and Configuration
     10            *           + Data transfers functions
     11            *           + Hardware CRC Calculation
     12            *           + DMA transfers management
     13            *           + Interrupts and flags management
     14            *
     15            *  @verbatim
     16          
     17           ===============================================================================
     18                                 ##### How to use this driver #####
     19           ===============================================================================
     20              [..]
     21                  (#) Enable peripheral clock using RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE)
     22                      function for SPI1 or using RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE)
     23                      function for SPI2.
     24            
     25                  (#) Enable SCK, MOSI, MISO and NSS GPIO clocks using 
     26                      RCC_AHBPeriphClockCmd() function. 
     27            
     28                  (#) Peripherals alternate function: 
     29                      (++) Connect the pin to the desired peripherals' Alternate 
     30                           Function (AF) using GPIO_PinAFConfig() function.
     31                      (++) Configure the desired pin in alternate function by:
     32                           GPIO_InitStruct->GPIO_Mode = GPIO_Mode_AF.
     33                      (++) Select the type, pull-up/pull-down and output speed via 
     34                           GPIO_PuPd, GPIO_OType and GPIO_Speed members.
     35                      (++) Call GPIO_Init() function.
     36            
     37                  (#) Program the Polarity, Phase, First Data, Baud Rate Prescaler, Slave 
     38                      Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
     39                      function.In I2S mode, program the Mode, Standard, Data Format, MCLK 
     40                      Output, Audio frequency and Polarity using I2S_Init() function.
     41            
     42                  (#) Configure the FIFO threshold using SPI_RxFIFOThresholdConfig() to select 
     43                      at which threshold the RXNE event is generated.
     44                      
     45                  (#) Enable the NVIC and the corresponding interrupt using the function 
     46                      SPI_ITConfig() if you need to use interrupt mode. 
     47            
     48                  (#) When using the DMA mode 
     49                      (++) Configure the DMA using DMA_Init() function.
     50                      (++) Active the needed channel Request using SPI_I2S_DMACmd() function.
     51             
     52                  (#) Enable the SPI using the SPI_Cmd() function or enable the I2S using
     53                      I2S_Cmd().
     54             
     55                  (#) Enable the DMA using the DMA_Cmd() function when using DMA mode. 
     56            
     57                  (#) Optionally, you can enable/configure the following parameters without
     58                      re-initialization (i.e there is no need to call again SPI_Init() function):
     59                      (++) When bidirectional mode (SPI_Direction_1Line_Rx or SPI_Direction_1Line_Tx)
     60                           is programmed as Data direction parameter using the SPI_Init() 
     61                           function it can be possible to switch between SPI_Direction_Tx 
     62                           or SPI_Direction_Rx using the SPI_BiDirectionalLineConfig() function.
     63                      (++) When SPI_NSS_Soft is selected as Slave Select Management parameter 
     64                           using the SPI_Init() function it can be possible to manage the 
     65                           NSS internal signal using the SPI_NSSInternalSoftwareConfig() function.
     66                      (++) Reconfigure the data size using the SPI_DataSizeConfig() function.
     67                      (++) Enable or disable the SS output using the SPI_SSOutputCmd() function.  
     68            
     69                  (#) To use the CRC Hardware calculation feature refer to the Peripheral 
     70                      CRC hardware Calculation subsection.
     71            
     72              @endverbatim 
     73            ******************************************************************************
     74            * @attention
     75            *
     76            * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
     77            *
     78            * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
     79            * You may not use this file except in compliance with the License.
     80            * You may obtain a copy of the License at:
     81            *
     82            *        http://www.st.com/software_license_agreement_liberty_v2
     83            *
     84            * Unless required by applicable law or agreed to in writing, software 
     85            * distributed under the License is distributed on an "AS IS" BASIS, 
     86            * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     87            * See the License for the specific language governing permissions and
     88            * limitations under the License.
     89            *
     90            ******************************************************************************
     91            */
     92          
     93          /* Includes ------------------------------------------------------------------*/
     94          #include "stm32f0xx_spi.h"
     95          #include "stm32f0xx_rcc.h"
     96          
     97          /** @addtogroup STM32F0xx_StdPeriph_Driver
     98            * @{
     99            */
    100          
    101          /** @defgroup SPI
    102            * @brief SPI driver modules
    103            * @{
    104            */
    105          
    106          /* Private typedef -----------------------------------------------------------*/
    107          /* Private define ------------------------------------------------------------*/
    108          /* SPI registers Masks */
    109          #define CR1_CLEAR_MASK       ((uint16_t)0x3040)
    110          #define CR1_CLEAR_MASK2      ((uint16_t)0xFFFB)
    111          #define CR2_LDMA_MASK        ((uint16_t)0x9FFF)
    112          
    113          #define I2SCFGR_CLEAR_Mask   ((uint16_t)0xF040)
    114          
    115          /* Private macro -------------------------------------------------------------*/
    116          /* Private variables ---------------------------------------------------------*/
    117          /* Private function prototypes -----------------------------------------------*/
    118          /* Private functions ---------------------------------------------------------*/
    119          
    120          /** @defgroup SPI_Private_Functions
    121            * @{
    122            */
    123          
    124          /** @defgroup SPI_Group1 Initialization and Configuration functions
    125           *  @brief   Initialization and Configuration functions 
    126           *
    127          @verbatim   
    128           ===============================================================================
    129                     ##### Initialization and Configuration functions #####
    130           ===============================================================================
    131              [..] This section provides a set of functions allowing to initialize the SPI Direction,
    132                   SPI Mode, SPI Data Size, SPI Polarity, SPI Phase, SPI NSS Management, SPI Baud
    133                   Rate Prescaler, SPI First Bit and SPI CRC Polynomial.
    134          
    135              [..] The SPI_Init() function follows the SPI configuration procedures for Master mode
    136                   and Slave mode (details for these procedures are available in reference manual).
    137                   
    138              [..] When the Software NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Soft) is selected,
    139                   use the following function to manage the NSS bit:
    140                   void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft);
    141          
    142              [..] In Master mode, when the Hardware NSS management (SPI_InitStruct->SPI_NSS = SPI_NSS_Hard)
    143                   is selected, use the follwoing function to enable the NSS output feature.
    144                   void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    145          
    146              [..] The NSS pulse mode can be managed by the SPI TI mode when enabling it using the following function:
    147                   void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    148                   And it can be managed by software in the SPI Motorola mode using this function: 
    149                   void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState);
    150          
    151              [..] This section provides also functions to initialize the I2S Mode, Standard, 
    152                   Data Format, MCLK Output, Audio frequency and Polarity.
    153            
    154              [..] The I2S_Init() function follows the I2S configuration procedures for Master mode
    155                   and Slave mode.
    156            
    157          @endverbatim
    158            * @{
    159            */
    160          
    161          /**
    162            * @brief  Deinitializes the SPIx peripheral registers to their default
    163            *         reset values.
    164            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    165            * @note   SPI2 is not available for STM32F031 devices.
    166            *         I2S mode is not supported for STM32F030 devices.      
    167            * @retval None
    168            */
    169          void SPI_I2S_DeInit(SPI_TypeDef* SPIx)
    170          {
    171            /* Check the parameters */
    172            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    173          
    174            if (SPIx == SPI1)
    175            {
    176              /* Enable SPI1 reset state */
    177              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, ENABLE);
    178              /* Release SPI1 from reset state */
    179              RCC_APB2PeriphResetCmd(RCC_APB2Periph_SPI1, DISABLE);
    180            }
    181            else
    182            {
    183              if (SPIx == SPI2)
    184              {
    185                /* Enable SPI2 reset state */
    186                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, ENABLE);
    187                /* Release SPI2 from reset state */
    188                RCC_APB1PeriphResetCmd(RCC_APB1Periph_SPI2, DISABLE);
    189              }
    190            }
    191          }
    192          
    193          /**
    194            * @brief  Fills each SPI_InitStruct member with its default value.
    195            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure which will be initialized.
    196            * @retval None
    197            */
    198          void SPI_StructInit(SPI_InitTypeDef* SPI_InitStruct)
    199          {
    200          /*--------------- Reset SPI init structure parameters values -----------------*/
    201            /* Initialize the SPI_Direction member */
    202            SPI_InitStruct->SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    203            /* Initialize the SPI_Mode member */
    204            SPI_InitStruct->SPI_Mode = SPI_Mode_Slave;
    205            /* Initialize the SPI_DataSize member */
    206            SPI_InitStruct->SPI_DataSize = SPI_DataSize_8b;
    207            /* Initialize the SPI_CPOL member */
    208            SPI_InitStruct->SPI_CPOL = SPI_CPOL_Low;
    209            /* Initialize the SPI_CPHA member */
    210            SPI_InitStruct->SPI_CPHA = SPI_CPHA_1Edge;
    211            /* Initialize the SPI_NSS member */
    212            SPI_InitStruct->SPI_NSS = SPI_NSS_Hard;
    213            /* Initialize the SPI_BaudRatePrescaler member */
    214            SPI_InitStruct->SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;
    215            /* Initialize the SPI_FirstBit member */
    216            SPI_InitStruct->SPI_FirstBit = SPI_FirstBit_MSB;
    217            /* Initialize the SPI_CRCPolynomial member */
    218            SPI_InitStruct->SPI_CRCPolynomial = 7;
    219          }
    220          
    221          /**
    222            * @brief  Initializes the SPIx peripheral according to the specified 
    223            *         parameters in the SPI_InitStruct.
    224            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    225            * @note   SPI2 is not available for STM32F031 devices. 
    226            * @param  SPI_InitStruct: pointer to a SPI_InitTypeDef structure that
    227            *         contains the configuration information for the specified SPI peripheral.
    228            * @retval None
    229            */
    230          void SPI_Init(SPI_TypeDef* SPIx, SPI_InitTypeDef* SPI_InitStruct)
    231          {
    232            uint16_t tmpreg = 0;
    233          
    234            /* check the parameters */
    235            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    236          
    237            /* Check the SPI parameters */
    238            assert_param(IS_SPI_DIRECTION_MODE(SPI_InitStruct->SPI_Direction));
    239            assert_param(IS_SPI_MODE(SPI_InitStruct->SPI_Mode));
    240            assert_param(IS_SPI_DATA_SIZE(SPI_InitStruct->SPI_DataSize));
    241            assert_param(IS_SPI_CPOL(SPI_InitStruct->SPI_CPOL));
    242            assert_param(IS_SPI_CPHA(SPI_InitStruct->SPI_CPHA));
    243            assert_param(IS_SPI_NSS(SPI_InitStruct->SPI_NSS));
    244            assert_param(IS_SPI_BAUDRATE_PRESCALER(SPI_InitStruct->SPI_BaudRatePrescaler));
    245            assert_param(IS_SPI_FIRST_BIT(SPI_InitStruct->SPI_FirstBit));
    246            assert_param(IS_SPI_CRC_POLYNOMIAL(SPI_InitStruct->SPI_CRCPolynomial));
    247          
    248            /*---------------------------- SPIx CR1 Configuration ------------------------*/
    249            /* Get the SPIx CR1 value */
    250            tmpreg = SPIx->CR1;
    251            /* Clear BIDIMode, BIDIOE, RxONLY, SSM, SSI, LSBFirst, BR, CPOL and CPHA bits */
    252            tmpreg &= CR1_CLEAR_MASK;
    253            /* Configure SPIx: direction, NSS management, first transmitted bit, BaudRate prescaler
    254            master/slave mode, CPOL and CPHA */
    255            /* Set BIDImode, BIDIOE and RxONLY bits according to SPI_Direction value */
    256            /* Set SSM, SSI bit according to SPI_NSS values */
    257            /* Set LSBFirst bit according to SPI_FirstBit value */
    258            /* Set BR bits according to SPI_BaudRatePrescaler value */
    259            /* Set CPOL bit according to SPI_CPOL value */
    260            /* Set CPHA bit according to SPI_CPHA value */
    261            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Direction | SPI_InitStruct->SPI_FirstBit |
    262                                SPI_InitStruct->SPI_CPOL | SPI_InitStruct->SPI_CPHA |
    263                                SPI_InitStruct->SPI_NSS | SPI_InitStruct->SPI_BaudRatePrescaler);  
    264            /* Write to SPIx CR1 */
    265            SPIx->CR1 = tmpreg;
    266            /*-------------------------Data Size Configuration -----------------------*/
    267            /* Get the SPIx CR2 value */
    268            tmpreg = SPIx->CR2;
    269            /* Clear DS[3:0] bits */
    270            tmpreg &=(uint16_t)~SPI_CR2_DS;
    271            /* Configure SPIx: Data Size */
    272            tmpreg |= (uint16_t)(SPI_InitStruct->SPI_DataSize);
    273            /* Write to SPIx CR2 */
    274            SPIx->CR2 = tmpreg;
    275            
    276            /*---------------------------- SPIx CRCPOLY Configuration --------------------*/
    277            /* Write to SPIx CRCPOLY */
    278            SPIx->CRCPR = SPI_InitStruct->SPI_CRCPolynomial;
    279            
    280            /*---------------------------- SPIx CR1 Configuration ------------------------*/
    281            /* Get the SPIx CR1 value */
    282            tmpreg = SPIx->CR1;
    283            /* Clear MSTR bit */
    284            tmpreg &= CR1_CLEAR_MASK2;
    285            /* Configure SPIx: master/slave mode */  
    286            /* Set MSTR bit according to SPI_Mode */
    287            tmpreg |= (uint16_t)((uint32_t)SPI_InitStruct->SPI_Mode);  
    288            /* Write to SPIx CR1 */
    289            SPIx->CR1 = tmpreg;  
    290            
    291            /* Activate the SPI mode (Reset I2SMOD bit in I2SCFGR register) */
    292            SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SMOD);
    293          }
    294          
    295          /**
    296            * @brief  Fills each I2S_InitStruct member with its default value.
    297            * @note   This mode is not supported for STM32F030 devices.  
    298            * @param  I2S_InitStruct: pointer to a I2S_InitTypeDef structure which will be initialized.
    299            * @retval None
    300            */
    301          void I2S_StructInit(I2S_InitTypeDef* I2S_InitStruct)
    302          {
    303          /*--------------- Reset I2S init structure parameters values -----------------*/
    304            /* Initialize the I2S_Mode member */
    305            I2S_InitStruct->I2S_Mode = I2S_Mode_SlaveTx;
    306          
    307            /* Initialize the I2S_Standard member */
    308            I2S_InitStruct->I2S_Standard = I2S_Standard_Phillips;
    309          
    310            /* Initialize the I2S_DataFormat member */
    311            I2S_InitStruct->I2S_DataFormat = I2S_DataFormat_16b;
    312          
    313            /* Initialize the I2S_MCLKOutput member */
    314            I2S_InitStruct->I2S_MCLKOutput = I2S_MCLKOutput_Disable;
    315          
    316            /* Initialize the I2S_AudioFreq member */
    317            I2S_InitStruct->I2S_AudioFreq = I2S_AudioFreq_Default;
    318          
    319            /* Initialize the I2S_CPOL member */
    320            I2S_InitStruct->I2S_CPOL = I2S_CPOL_Low;
    321          }
    322          
    323          /**
    324            * @brief  Initializes the SPIx peripheral according to the specified 
    325            *         parameters in the I2S_InitStruct.
    326            * @note   This mode is not supported for STM32F030 devices.  
    327            * @param  SPIx: where x can be 1 to select the SPI peripheral (configured in I2S mode).  
    328            * @param  I2S_InitStruct: pointer to an I2S_InitTypeDef structure that
    329            *         contains the configuration information for the specified SPI peripheral
    330            *         configured in I2S mode.
    331            * @note   This function calculates the optimal prescaler needed to obtain the most 
    332            *         accurate audio frequency (depending on the I2S clock source, the PLL values 
    333            *         and the product configuration). But in case the prescaler value is greater 
    334            *         than 511, the default value (0x02) will be configured instead.
    335            * @retval None
    336            */
    337          void I2S_Init(SPI_TypeDef* SPIx, I2S_InitTypeDef* I2S_InitStruct)
    338          {
    339            uint16_t tmpreg = 0, i2sdiv = 2, i2sodd = 0, packetlength = 1;
    340            uint32_t tmp = 0;
    341            RCC_ClocksTypeDef RCC_Clocks;
    342            uint32_t sourceclock = 0;
    343          
    344            /* Check the I2S parameters */
    345            assert_param(IS_SPI_1_PERIPH(SPIx));
    346            assert_param(IS_I2S_MODE(I2S_InitStruct->I2S_Mode));
    347            assert_param(IS_I2S_STANDARD(I2S_InitStruct->I2S_Standard));
    348            assert_param(IS_I2S_DATA_FORMAT(I2S_InitStruct->I2S_DataFormat));
    349            assert_param(IS_I2S_MCLK_OUTPUT(I2S_InitStruct->I2S_MCLKOutput));
    350            assert_param(IS_I2S_AUDIO_FREQ(I2S_InitStruct->I2S_AudioFreq));
    351            assert_param(IS_I2S_CPOL(I2S_InitStruct->I2S_CPOL));  
    352          
    353          /*----------------------- SPIx I2SCFGR & I2SPR Configuration -----------------*/
    354            /* Clear I2SMOD, I2SE, I2SCFG, PCMSYNC, I2SSTD, CKPOL, DATLEN and CHLEN bits */
    355            SPIx->I2SCFGR &= I2SCFGR_CLEAR_Mask; 
    356            SPIx->I2SPR = 0x0002;
    357          
    358            /* Get the I2SCFGR register value */
    359            tmpreg = SPIx->I2SCFGR;
    360          
    361            /* If the default value has to be written, reinitialize i2sdiv and i2sodd*/
    362            if(I2S_InitStruct->I2S_AudioFreq == I2S_AudioFreq_Default)
    363            {
    364              i2sodd = (uint16_t)0;
    365              i2sdiv = (uint16_t)2;   
    366            }
    367            /* If the requested audio frequency is not the default, compute the prescaler */
    368            else
    369            {
    370              /* Check the frame length (For the Prescaler computing) */
    371              if(I2S_InitStruct->I2S_DataFormat == I2S_DataFormat_16b)
    372              {
    373                /* Packet length is 16 bits */
    374                packetlength = 1;
    375              }
    376              else
    377              {
    378                /* Packet length is 32 bits */
    379                packetlength = 2;
    380              }
    381          
    382              /* I2S Clock source is System clock: Get System Clock frequency */
    383              RCC_GetClocksFreq(&RCC_Clocks);      
    384          
    385              /* Get the source clock value: based on System Clock value */
    386              sourceclock = RCC_Clocks.SYSCLK_Frequency;    
    387          
    388              /* Compute the Real divider depending on the MCLK output state with a floating point */
    389              if(I2S_InitStruct->I2S_MCLKOutput == I2S_MCLKOutput_Enable)
    390              {
    391                /* MCLK output is enabled */
    392                tmp = (uint16_t)(((((sourceclock / 256) * 10) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    393              }
    394              else
    395              {
    396                /* MCLK output is disabled */
    397                tmp = (uint16_t)(((((sourceclock / (32 * packetlength)) *10 ) / I2S_InitStruct->I2S_AudioFreq)) + 5);
    398              }
    399              
    400              /* Remove the floating point */
    401              tmp = tmp / 10;
    402          
    403              /* Check the parity of the divider */
    404              i2sodd = (uint16_t)(tmp & (uint16_t)0x0001);
    405          
    406              /* Compute the i2sdiv prescaler */
    407              i2sdiv = (uint16_t)((tmp - i2sodd) / 2);
    408          
    409              /* Get the Mask for the Odd bit (SPI_I2SPR[8]) register */
    410              i2sodd = (uint16_t) (i2sodd << 8);
    411            }
    412          
    413            /* Test if the divider is 1 or 0 or greater than 0xFF */
    414            if ((i2sdiv < 2) || (i2sdiv > 0xFF))
    415            {
    416              /* Set the default values */
    417              i2sdiv = 2;
    418              i2sodd = 0;
    419            }
    420          
    421            /* Write to SPIx I2SPR register the computed value */
    422            SPIx->I2SPR = (uint16_t)(i2sdiv | (uint16_t)(i2sodd | (uint16_t)I2S_InitStruct->I2S_MCLKOutput));
    423          
    424            /* Configure the I2S with the SPI_InitStruct values */
    425            tmpreg |= (uint16_t)(SPI_I2SCFGR_I2SMOD | (uint16_t)(I2S_InitStruct->I2S_Mode | \
    426                            (uint16_t)(I2S_InitStruct->I2S_Standard | (uint16_t)(I2S_InitStruct->I2S_DataFormat | \
    427                            (uint16_t)I2S_InitStruct->I2S_CPOL))));
    428          
    429            /* Write to SPIx I2SCFGR */
    430            SPIx->I2SCFGR = tmpreg;
    431          }
    432          
    433          /**
    434            * @brief  Enables or disables the specified SPI peripheral.
    435            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    436            * @note   SPI2 is not available for STM32F031 devices.
    437            * @param  NewState: new state of the SPIx peripheral. 
    438            *          This parameter can be: ENABLE or DISABLE.
    439            * @retval None
    440            */
    441          void SPI_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    442          {
    443            /* Check the parameters */
    444            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    445            assert_param(IS_FUNCTIONAL_STATE(NewState));
    446          
    447            if (NewState != DISABLE)
    448            {
    449              /* Enable the selected SPI peripheral */
    450              SPIx->CR1 |= SPI_CR1_SPE;
    451            }
    452            else
    453            {
    454              /* Disable the selected SPI peripheral */
    455              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_SPE);
    456            }
    457          }
    458          
    459          /**
    460            * @brief  Enables or disables the TI Mode.
    461            *   
    462            * @note   This function can be called only after the SPI_Init() function has 
    463            *         been called. 
    464            * @note   When TI mode is selected, the control bits SSM, SSI, CPOL and CPHA 
    465            *         are not taken into consideration and are configured by hardware 
    466            *         respectively to the TI mode requirements.
    467            *    
    468            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    469            * @note   SPI2 is not available for STM32F031 devices.
    470            * @param  NewState: new state of the selected SPI TI communication mode.
    471            *          This parameter can be: ENABLE or DISABLE.
    472            * @retval None
    473            */
    474          void SPI_TIModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    475          {
    476            /* Check the parameters */
    477            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    478            assert_param(IS_FUNCTIONAL_STATE(NewState));
    479          
    480            if (NewState != DISABLE)
    481            {
    482              /* Enable the TI mode for the selected SPI peripheral */
    483              SPIx->CR2 |= SPI_CR2_FRF;
    484            }
    485            else
    486            {
    487              /* Disable the TI mode for the selected SPI peripheral */
    488              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRF);
    489            }
    490          }
    491          
    492          /**
    493            * @brief  Enables or disables the specified SPI peripheral (in I2S mode).
    494            * @note   This mode is not supported for STM32F030 devices.    
    495            * @param  SPIx: where x can be 1 to select the SPI peripheral.
    496            * @param  NewState: new state of the SPIx peripheral. 
    497            *          This parameter can be: ENABLE or DISABLE.
    498            * @retval None
    499            */
    500          void I2S_Cmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    501          {
    502            /* Check the parameters */
    503            assert_param(IS_SPI_1_PERIPH(SPIx));
    504            assert_param(IS_FUNCTIONAL_STATE(NewState));
    505            if (NewState != DISABLE)
    506            {
    507              /* Enable the selected SPI peripheral in I2S mode */
    508              SPIx->I2SCFGR |= SPI_I2SCFGR_I2SE;
    509            }
    510            else
    511            {
    512              /* Disable the selected SPI peripheral in I2S mode */
    513              SPIx->I2SCFGR &= (uint16_t)~((uint16_t)SPI_I2SCFGR_I2SE);
    514            }
    515          }
    516          
    517          /**
    518            * @brief  Configures the data size for the selected SPI.
    519            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    520            * @note   SPI2 is not available for STM32F031 devices. 
    521            * @param  SPI_DataSize: specifies the SPI data size.
    522            *         For the SPIx peripheral this parameter can be one of the following values:
    523            *            @arg SPI_DataSize_4b: Set data size to 4 bits
    524            *            @arg SPI_DataSize_5b: Set data size to 5 bits
    525            *            @arg SPI_DataSize_6b: Set data size to 6 bits
    526            *            @arg SPI_DataSize_7b: Set data size to 7 bits
    527            *            @arg SPI_DataSize_8b: Set data size to 8 bits
    528            *            @arg SPI_DataSize_9b: Set data size to 9 bits
    529            *            @arg SPI_DataSize_10b: Set data size to 10 bits
    530            *            @arg SPI_DataSize_11b: Set data size to 11 bits
    531            *            @arg SPI_DataSize_12b: Set data size to 12 bits
    532            *            @arg SPI_DataSize_13b: Set data size to 13 bits
    533            *            @arg SPI_DataSize_14b: Set data size to 14 bits
    534            *            @arg SPI_DataSize_15b: Set data size to 15 bits
    535            *            @arg SPI_DataSize_16b: Set data size to 16 bits
    536            * @retval None
    537            */
    538          void SPI_DataSizeConfig(SPI_TypeDef* SPIx, uint16_t SPI_DataSize)
    539          {
    540            uint16_t tmpreg = 0;
    541            
    542            /* Check the parameters */
    543            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    544            assert_param(IS_SPI_DATA_SIZE(SPI_DataSize));
    545            /* Read the CR2 register */
    546            tmpreg = SPIx->CR2;
    547            /* Clear DS[3:0] bits */
    548            tmpreg &= (uint16_t)~SPI_CR2_DS;
    549            /* Set new DS[3:0] bits value */
    550            tmpreg |= SPI_DataSize;
    551            SPIx->CR2 = tmpreg;
    552          }
    553          
    554          /**
    555            * @brief  Configures the FIFO reception threshold for the selected SPI.
    556            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    557            * @note   SPI2 is not available for STM32F031 devices. 
    558            * @param  SPI_RxFIFOThreshold: specifies the FIFO reception threshold.
    559            *          This parameter can be one of the following values:
    560            *            @arg SPI_RxFIFOThreshold_HF: RXNE event is generated if the FIFO 
    561            *                                         level is greater or equal to 1/2. 
    562            *            @arg SPI_RxFIFOThreshold_QF: RXNE event is generated if the FIFO 
    563            *                                         level is greater or equal to 1/4. 
    564            * @retval None
    565            */
    566          void SPI_RxFIFOThresholdConfig(SPI_TypeDef* SPIx, uint16_t SPI_RxFIFOThreshold)
    567          {
    568            /* Check the parameters */
    569            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    570            assert_param(IS_SPI_RX_FIFO_THRESHOLD(SPI_RxFIFOThreshold));
    571          
    572            /* Clear FRXTH bit */
    573            SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_FRXTH);
    574          
    575            /* Set new FRXTH bit value */
    576            SPIx->CR2 |= SPI_RxFIFOThreshold;
    577          }
    578          
    579          /**
    580            * @brief  Selects the data transfer direction in bidirectional mode for the specified SPI.
    581            * @param  SPIx: where x can be 1 or 2  to select the SPI peripheral.
    582            * @note   SPI2 is not available for STM32F031 devices. 
    583            * @param  SPI_Direction: specifies the data transfer direction in bidirectional mode. 
    584            *          This parameter can be one of the following values:
    585            *            @arg SPI_Direction_Tx: Selects Tx transmission direction
    586            *            @arg SPI_Direction_Rx: Selects Rx receive direction
    587            * @retval None
    588            */
    589          void SPI_BiDirectionalLineConfig(SPI_TypeDef* SPIx, uint16_t SPI_Direction)
    590          {
    591            /* Check the parameters */
    592            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    593            assert_param(IS_SPI_DIRECTION(SPI_Direction));
    594            if (SPI_Direction == SPI_Direction_Tx)
    595            {
    596              /* Set the Tx only mode */
    597              SPIx->CR1 |= SPI_Direction_Tx;
    598            }
    599            else
    600            {
    601              /* Set the Rx only mode */
    602              SPIx->CR1 &= SPI_Direction_Rx;
    603            }
    604          }
    605          
    606          /**
    607            * @brief  Configures internally by software the NSS pin for the selected SPI.
    608            * @note   This function can be called only after the SPI_Init() function has 
    609            *         been called.  
    610            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    611            * @note   SPI2 is not available for STM32F031 devices.  
    612            * @param  SPI_NSSInternalSoft: specifies the SPI NSS internal state.
    613            *          This parameter can be one of the following values:
    614            *            @arg SPI_NSSInternalSoft_Set: Set NSS pin internally
    615            *            @arg SPI_NSSInternalSoft_Reset: Reset NSS pin internally
    616            * @retval None
    617            */
    618          void SPI_NSSInternalSoftwareConfig(SPI_TypeDef* SPIx, uint16_t SPI_NSSInternalSoft)
    619          {
    620            /* Check the parameters */
    621            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    622            assert_param(IS_SPI_NSS_INTERNAL(SPI_NSSInternalSoft));
    623          
    624            if (SPI_NSSInternalSoft != SPI_NSSInternalSoft_Reset)
    625            {
    626              /* Set NSS pin internally by software */
    627              SPIx->CR1 |= SPI_NSSInternalSoft_Set;
    628            }
    629            else
    630            {
    631              /* Reset NSS pin internally by software */
    632              SPIx->CR1 &= SPI_NSSInternalSoft_Reset;
    633            }
    634          }
    635          
    636          /**
    637            * @brief  Enables or disables the SS output for the selected SPI.
    638            * @note   This function can be called only after the SPI_Init() function has 
    639            *         been called and the NSS hardware management mode is selected. 
    640            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    641            * @note   SPI2 is not available for STM32F031 devices.  
    642            * @param  NewState: new state of the SPIx SS output. 
    643            *          This parameter can be: ENABLE or DISABLE.
    644            * @retval None
    645            */
    646          void SPI_SSOutputCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    647          {
    648            /* Check the parameters */
    649            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    650            assert_param(IS_FUNCTIONAL_STATE(NewState));
    651            if (NewState != DISABLE)
    652            {
    653              /* Enable the selected SPI SS output */
    654              SPIx->CR2 |= SPI_CR2_SSOE;
    655            }
    656            else
    657            {
    658              /* Disable the selected SPI SS output */
    659              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_SSOE);
    660            }
    661          }
    662          
    663          /**
    664            * @brief  Enables or disables the NSS pulse management mode.
    665            * @note   This function can be called only after the SPI_Init() function has 
    666            *         been called. 
    667            * @note   When TI mode is selected, the control bits NSSP is not taken into 
    668            *         consideration and are configured by hardware respectively to the 
    669            *         TI mode requirements. 
    670            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    671            * @note   SPI2 is not available for STM32F031 devices.
    672            * @param  NewState: new state of the NSS pulse management mode.
    673            *          This parameter can be: ENABLE or DISABLE.
    674            * @retval None
    675            */
    676          void SPI_NSSPulseModeCmd(SPI_TypeDef* SPIx, FunctionalState NewState)
    677          {
    678            /* Check the parameters */
    679            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    680            assert_param(IS_FUNCTIONAL_STATE(NewState));
    681          
    682            if (NewState != DISABLE)
    683            {
    684              /* Enable the NSS pulse management mode */
    685              SPIx->CR2 |= SPI_CR2_NSSP;
    686            }
    687            else
    688            {
    689              /* Disable the NSS pulse management mode */
    690              SPIx->CR2 &= (uint16_t)~((uint16_t)SPI_CR2_NSSP);    
    691            }
    692          }
    693          
    694          /**
    695            * @}
    696            */
    697          
    698          /** @defgroup SPI_Group2 Data transfers functions
    699           *  @brief   Data transfers functions
    700           *
    701          @verbatim
    702           ===============================================================================
    703                              ##### Data transfers functions #####
    704           ===============================================================================
    705              [..] This section provides a set of functions allowing to manage the SPI or I2S
    706                   data transfers.
    707          
    708              [..] In reception, data are received and then stored into an internal Rx buffer while 
    709                   In transmission, data are first stored into an internal Tx buffer before being 
    710                   transmitted.
    711          
    712              [..] The read access of the SPI_DR register can be done using 
    713                   SPI_ReceiveData8() (when data size is equal or inferior than 8bits) and.
    714                   SPI_I2S_ReceiveData16() (when data size is superior than 8bits)function
    715                   and returns the Rx buffered value. Whereas a write access to the SPI_DR 
    716                   can be done using SPI_SendData8() (when data size is equal or inferior than 8bits)
    717                   and SPI_I2S_SendData16() (when data size is superior than 8bits) function 
    718                   and stores the written data into Tx buffer.
    719          
    720          @endverbatim
    721            * @{
    722            */
    723          
    724          /**
    725            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    726            * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral.
    727            * @note   SPI2 is not available for STM32F031 devices.
    728            * @param  Data: Data to be transmitted.
    729            * @retval None
    730            */
    731          void SPI_SendData8(SPI_TypeDef* SPIx, uint8_t Data)
    732          {
    733            uint32_t spixbase = 0x00;
    734          
    735            /* Check the parameters */
    736            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    737          
    738            spixbase = (uint32_t)SPIx; 
    739            spixbase += 0x0C;
    740            
    741            *(__IO uint8_t *) spixbase = Data;
    742          }
    743          
    744          /**
    745            * @brief  Transmits a Data through the SPIx/I2Sx peripheral.
    746            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
    747            *         the SPI peripheral. 
    748            * @note   SPI2 is not available for STM32F031 devices. 
    749            * @param  Data: Data to be transmitted.
    750            * @retval None
    751            */
    752          void SPI_I2S_SendData16(SPI_TypeDef* SPIx, uint16_t Data)
    753          {
    754            /* Check the parameters */
    755            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    756            
    757            SPIx->DR = (uint16_t)Data;
    758          }
    759          
    760          /**
    761            * @brief  Returns the most recent received data by the SPIx/I2Sx peripheral. 
    762            * @param  SPIx: where x can be 1 or 2 in SPI mode to select the SPI peripheral. 
    763            * @note   SPI2 is not available for STM32F031 devices.
    764            * @retval The value of the received data.
    765            */
    766          uint8_t SPI_ReceiveData8(SPI_TypeDef* SPIx)
    767          {
    768            uint32_t spixbase = 0x00;
    769            
    770            spixbase = (uint32_t)SPIx; 
    771            spixbase += 0x0C;
    772            
    773            return *(__IO uint8_t *) spixbase;
    774          }
    775          
    776          /**
    777            * @brief  Returns the most recent received data by the SPIx peripheral. 
    778            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select
    779            * @note   SPI2 is not available for STM32F031 devices.
    780            *         the SPI peripheral.  
    781            * @retval The value of the received data.
    782            */
    783          uint16_t SPI_I2S_ReceiveData16(SPI_TypeDef* SPIx)
    784          {
    785            return SPIx->DR;
    786          }
    787          /**
    788            * @}
    789            */
    790          
    791          /** @defgroup SPI_Group3 Hardware CRC Calculation functions
    792           *  @brief   Hardware CRC Calculation functions
    793           *
    794          @verbatim   
    795           ===============================================================================
    796                          ##### Hardware CRC Calculation functions #####
    797           ===============================================================================
    798              [..] This section provides a set of functions allowing to manage the SPI CRC hardware 
    799                   calculation.SPI communication using CRC is possible through the following procedure:
    800          
    801                   (#) Program the Data direction, Polarity, Phase, First Data, Baud Rate Prescaler,
    802                       Slave Management, Peripheral Mode and CRC Polynomial values using the SPI_Init()
    803                       function.
    804                   (#) Enable the CRC calculation using the SPI_CalculateCRC() function.
    805                   (#) Enable the SPI using the SPI_Cmd() function
    806                   (#) Before writing the last data to the TX buffer, set the CRCNext bit using the 
    807                       SPI_TransmitCRC() function to indicate that after transmission of the last 
    808                       data, the CRC should be transmitted.
    809                   (#) After transmitting the last data, the SPI transmits the CRC. The SPI_CR1_CRCNEXT
    810                       bit is reset. The CRC is also received and compared against the SPI_RXCRCR 
    811                       value. 
    812                       If the value does not match, the SPI_FLAG_CRCERR flag is set and an interrupt
    813                       can be generated when the SPI_I2S_IT_ERR interrupt is enabled.
    814          
    815              -@-
    816                 (+@) It is advised to don't read the calculate CRC values during the communication.
    817                 (+@) When the SPI is in slave mode, be careful to enable CRC calculation only
    818                 when the clock is stable, that is, when the clock is in the steady state. 
    819                 If not, a wrong CRC calculation may be done. In fact, the CRC is sensitive 
    820                 to the SCK slave input clock as soon as CRCEN is set, and this, whatever 
    821                 the value of the SPE bit.
    822                 (+@) With high bitrate frequencies, be careful when transmitting the CRC.
    823                 As the number of used CPU cycles has to be as low as possible in the CRC 
    824                 transfer phase, it is forbidden to call software functions in the CRC 
    825                 transmission sequence to avoid errors in the last data and CRC reception. 
    826                 In fact, CRCNEXT bit has to be written before the end of the transmission/reception 
    827                 of the last data.
    828                 (+@) For high bit rate frequencies, it is advised to use the DMA mode to avoid the
    829                 degradation of the SPI speed performance due to CPU accesses impacting the 
    830                 SPI bandwidth.
    831                 (+@) When the STM32F0xx are configured as slaves and the NSS hardware mode is 
    832                 used, the NSS pin needs to be kept low between the data phase and the CRC 
    833                 phase.
    834                 (+@) When the SPI is configured in slave mode with the CRC feature enabled, CRC
    835                 calculation takes place even if a high level is applied on the NSS pin. 
    836                 This may happen for example in case of a multislave environment where the 
    837                 communication master addresses slaves alternately.
    838                 (+@) Between a slave deselection (high level on NSS) and a new slave selection
    839                 (low level on NSS), the CRC value should be cleared on both master and slave
    840                 sides in order to resynchronize the master and slave for their respective 
    841                 CRC calculation.
    842          
    843              -@- To clear the CRC, follow the procedure below:
    844                 (#@) Disable SPI using the SPI_Cmd() function
    845                 (#@) Disable the CRC calculation using the SPI_CalculateCRC() function.
    846                 (#@) Enable the CRC calculation using the SPI_CalculateCRC() function.
    847                 (#@) Enable SPI using the SPI_Cmd() function.
    848          
    849          @endverbatim
    850            * @{
    851            */
    852          
    853          /**
    854            * @brief  Configures the CRC calculation length for the selected SPI.
    855            * @note   This function can be called only after the SPI_Init() function has 
    856            *         been called.  
    857            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    858            * @note   SPI2 is not available for STM32F031 devices.  
    859            * @param  SPI_CRCLength: specifies the SPI CRC calculation length.
    860            *          This parameter can be one of the following values:
    861            *            @arg SPI_CRCLength_8b: Set CRC Calculation to 8 bits
    862            *            @arg SPI_CRCLength_16b: Set CRC Calculation to 16 bits
    863            * @retval None
    864            */
    865          void SPI_CRCLengthConfig(SPI_TypeDef* SPIx, uint16_t SPI_CRCLength)
    866          {
    867            /* Check the parameters */
    868            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    869            assert_param(IS_SPI_CRC_LENGTH(SPI_CRCLength));
    870          
    871            /* Clear CRCL bit */
    872            SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCL);
    873          
    874            /* Set new CRCL bit value */
    875            SPIx->CR1 |= SPI_CRCLength;
    876          }
    877          
    878          /**
    879            * @brief  Enables or disables the CRC value calculation of the transferred bytes.
    880            * @note   This function can be called only after the SPI_Init() function has 
    881            *         been called.   
    882            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    883            * @note   SPI2 is not available for STM32F031 devices.
    884            * @param  NewState: new state of the SPIx CRC value calculation.
    885            *          This parameter can be: ENABLE or DISABLE.
    886            * @retval None
    887            */
    888          void SPI_CalculateCRC(SPI_TypeDef* SPIx, FunctionalState NewState)
    889          {
    890            /* Check the parameters */
    891            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    892            assert_param(IS_FUNCTIONAL_STATE(NewState));
    893          
    894            if (NewState != DISABLE)
    895            {
    896              /* Enable the selected SPI CRC calculation */
    897              SPIx->CR1 |= SPI_CR1_CRCEN;
    898            }
    899            else
    900            {
    901              /* Disable the selected SPI CRC calculation */
    902              SPIx->CR1 &= (uint16_t)~((uint16_t)SPI_CR1_CRCEN);
    903            }
    904          }
    905          
    906          /**
    907            * @brief  Transmit the SPIx CRC value.
    908            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    909            * @note   SPI2 is not available for STM32F031 devices. 
    910            * @retval None
    911            */
    912          void SPI_TransmitCRC(SPI_TypeDef* SPIx)
    913          {
    914            /* Check the parameters */
    915            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    916          
    917            /* Enable the selected SPI CRC transmission */
    918            SPIx->CR1 |= SPI_CR1_CRCNEXT;
    919          }
    920          
    921          /**
    922            * @brief  Returns the transmit or the receive CRC register value for the specified SPI.
    923            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    924            * @note   SPI2 is not available for STM32F031 devices. 
    925            * @param  SPI_CRC: specifies the CRC register to be read.
    926            *          This parameter can be one of the following values:
    927            *            @arg SPI_CRC_Tx: Selects Tx CRC register
    928            *            @arg SPI_CRC_Rx: Selects Rx CRC register
    929            * @retval The selected CRC register value..
    930            */
    931          uint16_t SPI_GetCRC(SPI_TypeDef* SPIx, uint8_t SPI_CRC)
    932          {
    933            uint16_t crcreg = 0;
    934            /* Check the parameters */
    935            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    936            assert_param(IS_SPI_CRC(SPI_CRC));
    937          
    938            if (SPI_CRC != SPI_CRC_Rx)
    939            {
    940              /* Get the Tx CRC register */
    941              crcreg = SPIx->TXCRCR;
    942            }
    943            else
    944            {
    945              /* Get the Rx CRC register */
    946              crcreg = SPIx->RXCRCR;
    947            }
    948            /* Return the selected CRC register */
    949            return crcreg;
    950          }
    951          
    952          /**
    953            * @brief  Returns the CRC Polynomial register value for the specified SPI.
    954            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
    955            * @note   SPI2 is not available for STM32F031 devices. 
    956            * @retval The CRC Polynomial register value.
    957            */
    958          uint16_t SPI_GetCRCPolynomial(SPI_TypeDef* SPIx)
    959          {
    960            /* Check the parameters */
    961            assert_param(IS_SPI_ALL_PERIPH(SPIx));
    962          
    963            /* Return the CRC polynomial register */
    964            return SPIx->CRCPR;
    965          }
    966          
    967          /**
    968            * @}
    969            */
    970          
    971          /** @defgroup SPI_Group4 DMA transfers management functions
    972           *  @brief   DMA transfers management functions
    973            *
    974          @verbatim   
    975           ===============================================================================
    976                          ##### DMA transfers management functions #####
    977           ===============================================================================
    978              [..] This section provides two functions that can be used only in DMA mode.
    979          
    980          @endverbatim
    981            * @{
    982            */
    983          
    984          /**
    985            * @brief  Enables or disables the SPIx/I2Sx DMA interface.
    986            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
    987            *         the SPI peripheral.
    988            * @note   SPI2 is not available for STM32F031 devices.
    989            *         I2S mode is not supported for STM32F030 devices.  
    990            * @param  SPI_I2S_DMAReq: specifies the SPI DMA transfer request to be enabled or disabled. 
    991            *          This parameter can be any combination of the following values:
    992            *            @arg SPI_I2S_DMAReq_Tx: Tx buffer DMA transfer request
    993            *            @arg SPI_I2S_DMAReq_Rx: Rx buffer DMA transfer request
    994            * @param  NewState: new state of the selected SPI DMA transfer request.
    995            *          This parameter can be: ENABLE or DISABLE.
    996            * @retval None
    997            */
    998          void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState)
    999          {
   1000            /* Check the parameters */
   1001            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1002            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1003            assert_param(IS_SPI_I2S_DMA_REQ(SPI_I2S_DMAReq));
   1004          
   1005            if (NewState != DISABLE)
   1006            {
   1007              /* Enable the selected SPI DMA requests */
   1008              SPIx->CR2 |= SPI_I2S_DMAReq;
   1009            }
   1010            else
   1011            {
   1012              /* Disable the selected SPI DMA requests */
   1013              SPIx->CR2 &= (uint16_t)~SPI_I2S_DMAReq;
   1014            }
   1015          }
   1016          
   1017          /**
   1018            * @brief  Configures the number of data to transfer type(Even/Odd) for the DMA
   1019            *         last transfers and for the selected SPI.
   1020            * @note   This function have a meaning only if DMA mode is selected and if 
   1021            *         the packing mode is used (data length <= 8 and DMA transfer size halfword)  
   1022            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1023            * @note   SPI2 is not available for STM32F031 devices.
   1024            * @param  SPI_LastDMATransfer: specifies the SPI last DMA transfers state.
   1025            *          This parameter can be one of the following values:
   1026            *            @arg SPI_LastDMATransfer_TxEvenRxEven: Number of data for transmission Even
   1027            *                                                   and number of data for reception Even.
   1028            *            @arg SPI_LastDMATransfer_TxOddRxEven: Number of data for transmission Odd
   1029            *                                                  and number of data for reception Even.
   1030            *            @arg SPI_LastDMATransfer_TxEvenRxOdd: Number of data for transmission Even
   1031            *                                                  and number of data for reception Odd.
   1032            *            @arg SPI_LastDMATransfer_TxOddRxOdd: Number of data for transmission Odd
   1033            *                                                 and number of data for reception Odd.
   1034            * @retval None
   1035            */
   1036          void SPI_LastDMATransferCmd(SPI_TypeDef* SPIx, uint16_t SPI_LastDMATransfer)
   1037          {
   1038            /* Check the parameters */
   1039            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1040            assert_param(IS_SPI_LAST_DMA_TRANSFER(SPI_LastDMATransfer));
   1041          
   1042            /* Clear LDMA_TX and LDMA_RX bits */
   1043            SPIx->CR2 &= CR2_LDMA_MASK;
   1044          
   1045            /* Set new LDMA_TX and LDMA_RX bits value */
   1046            SPIx->CR2 |= SPI_LastDMATransfer; 
   1047          }
   1048          
   1049          /**
   1050            * @}
   1051            */
   1052          
   1053          /** @defgroup SPI_Group5 Interrupts and flags management functions
   1054           *  @brief   Interrupts and flags management functions
   1055            *
   1056          @verbatim   
   1057           ===============================================================================
   1058                       ##### Interrupts and flags management functions #####
   1059           ===============================================================================
   1060              [..] This section provides a set of functions allowing to configure the SPI/I2S Interrupts 
   1061                   sources and check or clear the flags or pending bits status.
   1062                   The user should identify which mode will be used in his application to manage 
   1063                   the communication: Polling mode, Interrupt mode or DMA mode. 
   1064          
   1065            *** Polling Mode ***
   1066            ====================
   1067              [..] In Polling Mode, the SPI/I2S communication can be managed by 9 flags:
   1068                  (#) SPI_I2S_FLAG_TXE : to indicate the status of the transmit buffer register
   1069                  (#) SPI_I2S_FLAG_RXNE : to indicate the status of the receive buffer register
   1070                  (#) SPI_I2S_FLAG_BSY : to indicate the state of the communication layer of the SPI.
   1071                  (#) SPI_FLAG_CRCERR : to indicate if a CRC Calculation error occur              
   1072                  (#) SPI_FLAG_MODF : to indicate if a Mode Fault error occur
   1073                  (#) SPI_I2S_FLAG_OVR : to indicate if an Overrun error occur
   1074                  (#) SPI_I2S_FLAG_FRE: to indicate a Frame Format error occurs.
   1075                  (#) I2S_FLAG_UDR: to indicate an Underrun error occurs.
   1076                  (#) I2S_FLAG_CHSIDE: to indicate Channel Side.
   1077          
   1078              [..]
   1079                  (@)Do not use the BSY flag to handle each data transmission or reception. It is better 
   1080                     to use the TXE and RXNE flags instead.
   1081          
   1082              [..] In this Mode it is advised to use the following functions:
   1083                  (+) FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1084                  (+) void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG);
   1085          
   1086            *** Interrupt Mode ***
   1087            ======================
   1088              [..] In Interrupt Mode, the SPI/I2S communication can be managed by 3 interrupt sources
   1089                   and 5 pending bits: 
   1090              [..] Pending Bits:
   1091                  (#) SPI_I2S_IT_TXE : to indicate the status of the transmit buffer register
   1092                  (#) SPI_I2S_IT_RXNE : to indicate the status of the receive buffer register
   1093                  (#) SPI_I2S_IT_OVR : to indicate if an Overrun error occur
   1094                  (#) I2S_IT_UDR : to indicate an Underrun Error occurs.
   1095                  (#) SPI_I2S_FLAG_FRE : to indicate a Frame Format error occurs.
   1096          
   1097              [..] Interrupt Source:
   1098                  (#) SPI_I2S_IT_TXE: specifies the interrupt source for the Tx buffer empty 
   1099                      interrupt.  
   1100                  (#) SPI_I2S_IT_RXNE : specifies the interrupt source for the Rx buffer not 
   1101                      empty interrupt.
   1102                  (#) SPI_I2S_IT_ERR : specifies the interrupt source for the errors interrupt.
   1103          
   1104              [..] In this Mode it is advised to use the following functions:
   1105                   (+) void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState);
   1106                   (+) ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT);
   1107          
   1108            *** FIFO Status ***
   1109            ===================
   1110              [..] It is possible to monitor the FIFO status when a transfer is ongoing using the
   1111                   following function:
   1112                   (+) uint32_t SPI_GetFIFOStatus(uint8_t SPI_FIFO_Direction); 
   1113          
   1114            *** DMA Mode ***
   1115            ================
   1116              [..] In DMA Mode, the SPI communication can be managed by 2 DMA Channel 
   1117                   requests:
   1118                  (#) SPI_I2S_DMAReq_Tx: specifies the Tx buffer DMA transfer request.
   1119                  (#) SPI_I2S_DMAReq_Rx: specifies the Rx buffer DMA transfer request.
   1120          
   1121              [..] In this Mode it is advised to use the following function:
   1122                  (+) void SPI_I2S_DMACmd(SPI_TypeDef* SPIx, uint16_t SPI_I2S_DMAReq, FunctionalState NewState).
   1123          
   1124          @endverbatim
   1125            * @{
   1126            */
   1127          
   1128          /**
   1129            * @brief  Enables or disables the specified SPI/I2S interrupts.
   1130            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1131            *         the SPI peripheral.  
   1132            * @note   SPI2 is not available for STM32F031 devices.
   1133            *         I2S mode is not supported for STM32F030 devices.  
   1134            * @param  SPI_I2S_IT: specifies the SPI interrupt source to be enabled or disabled. 
   1135            *          This parameter can be one of the following values:
   1136            *            @arg SPI_I2S_IT_TXE: Tx buffer empty interrupt mask
   1137            *            @arg SPI_I2S_IT_RXNE: Rx buffer not empty interrupt mask
   1138            *            @arg SPI_I2S_IT_ERR: Error interrupt mask
   1139            * @param  NewState: new state of the specified SPI interrupt.
   1140            *          This parameter can be: ENABLE or DISABLE.
   1141            * @retval None
   1142            */
   1143          void SPI_I2S_ITConfig(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT, FunctionalState NewState)
   1144          {
   1145            uint16_t itpos = 0, itmask = 0 ;
   1146          
   1147            /* Check the parameters */
   1148            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1149            assert_param(IS_FUNCTIONAL_STATE(NewState));
   1150            assert_param(IS_SPI_I2S_CONFIG_IT(SPI_I2S_IT));
   1151          
   1152            /* Get the SPI IT index */
   1153            itpos = SPI_I2S_IT >> 4;
   1154          
   1155            /* Set the IT mask */
   1156            itmask = (uint16_t)1 << (uint16_t)itpos;
   1157          
   1158            if (NewState != DISABLE)
   1159            {
   1160              /* Enable the selected SPI interrupt */
   1161              SPIx->CR2 |= itmask;
   1162            }
   1163            else
   1164            {
   1165              /* Disable the selected SPI interrupt */
   1166              SPIx->CR2 &= (uint16_t)~itmask;
   1167            }
   1168          }
   1169          
   1170          /**
   1171            * @brief  Returns the current SPIx Transmission FIFO filled level.
   1172            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1173            * @note   SPI2 is not available for STM32F031 devices.
   1174            * @retval The Transmission FIFO filling state.
   1175            *          - SPI_TransmissionFIFOStatus_Empty: when FIFO is empty
   1176            *          - SPI_TransmissionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
   1177            *          - SPI_TransmissionFIFOStatus_HalfFull: if more than 1 half-full.
   1178            *          - SPI_TransmissionFIFOStatus_Full: when FIFO is full.
   1179            */
   1180          uint16_t SPI_GetTransmissionFIFOStatus(SPI_TypeDef* SPIx)
   1181          {
   1182            /* Get the SPIx Transmission FIFO level bits */
   1183            return (uint16_t)((SPIx->SR & SPI_SR_FTLVL));
   1184          }
   1185          
   1186          /**
   1187            * @brief  Returns the current SPIx Reception FIFO filled level.
   1188            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1189            * @note   SPI2 is not available for STM32F031 devices.
   1190            * @retval The Reception FIFO filling state.
   1191            *          - SPI_ReceptionFIFOStatus_Empty: when FIFO is empty
   1192            *          - SPI_ReceptionFIFOStatus_1QuarterFull: if more than 1 quarter-full.
   1193            *          - SPI_ReceptionFIFOStatus_HalfFull: if more than 1 half-full.
   1194            *          - SPI_ReceptionFIFOStatus_Full: when FIFO is full.
   1195            */
   1196          uint16_t SPI_GetReceptionFIFOStatus(SPI_TypeDef* SPIx)
   1197          {
   1198            /* Get the SPIx Reception FIFO level bits */
   1199            return (uint16_t)((SPIx->SR & SPI_SR_FRLVL));
   1200          }
   1201          
   1202          /**
   1203            * @brief  Checks whether the specified SPI flag is set or not.
   1204            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1205            *         the SPI peripheral.    
   1206            * @note   SPI2 is not available for STM32F031 devices.
   1207            *         I2S mode is not supported for STM32F030 devices.  
   1208            * @param  SPI_I2S_FLAG: specifies the SPI flag to check. 
   1209            *          This parameter can be one of the following values:
   1210            *            @arg SPI_I2S_FLAG_TXE: Transmit buffer empty flag.
   1211            *            @arg SPI_I2S_FLAG_RXNE: Receive buffer not empty flag.
   1212            *            @arg SPI_I2S_FLAG_BSY: Busy flag.
   1213            *            @arg SPI_I2S_FLAG_OVR: Overrun flag.
   1214            *            @arg SPI_FLAG_MODF: Mode Fault flag.
   1215            *            @arg SPI_FLAG_CRCERR: CRC Error flag.
   1216            *            @arg SPI_I2S_FLAG_FRE: TI frame format error flag.
   1217            *            @arg I2S_FLAG_UDR: Underrun Error flag.
   1218            *            @arg I2S_FLAG_CHSIDE: Channel Side flag.   
   1219            * @retval The new state of SPI_I2S_FLAG (SET or RESET).
   1220            */
   1221          FlagStatus SPI_I2S_GetFlagStatus(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1222          {
   1223            FlagStatus bitstatus = RESET;
   1224            /* Check the parameters */
   1225            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1226            assert_param(IS_SPI_I2S_GET_FLAG(SPI_I2S_FLAG));
   1227          
   1228            /* Check the status of the specified SPI flag */
   1229            if ((SPIx->SR & SPI_I2S_FLAG) != (uint16_t)RESET)
   1230            {
   1231              /* SPI_I2S_FLAG is set */
   1232              bitstatus = SET;
   1233            }
   1234            else
   1235            {
   1236              /* SPI_I2S_FLAG is reset */
   1237              bitstatus = RESET;
   1238            }
   1239            /* Return the SPI_I2S_FLAG status */
   1240            return  bitstatus;
   1241          }
   1242          
   1243          /**
   1244            * @brief  Clears the SPIx CRC Error (CRCERR) flag.
   1245            * @param  SPIx: where x can be 1 or 2 to select the SPI peripheral.
   1246            * @note   SPI2 is not available for STM32F031 devices.
   1247            *         I2S mode is not supported for STM32F030 devices.  
   1248            * @param  SPI_I2S_FLAG: specifies the SPI flag to clear. 
   1249            *         This function clears only CRCERR flag.
   1250            * @note   OVR (OverRun error) flag is cleared by software sequence: a read 
   1251            *         operation to SPI_DR register (SPI_I2S_ReceiveData()) followed by  
   1252            *         a read operation to SPI_SR register (SPI_I2S_GetFlagStatus()).
   1253            * @note   MODF (Mode Fault) flag is cleared by software sequence: a read/write 
   1254            *         operation to SPI_SR register (SPI_I2S_GetFlagStatus()) followed by
   1255            *         a write operation to SPI_CR1 register (SPI_Cmd() to enable the SPI).
   1256            * @retval None
   1257            */
   1258          void SPI_I2S_ClearFlag(SPI_TypeDef* SPIx, uint16_t SPI_I2S_FLAG)
   1259          {
   1260            /* Check the parameters */
   1261            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1262            assert_param(IS_SPI_CLEAR_FLAG(SPI_I2S_FLAG));
   1263          
   1264            /* Clear the selected SPI CRC Error (CRCERR) flag */
   1265            SPIx->SR = (uint16_t)~SPI_I2S_FLAG;
   1266          }
   1267          
   1268          /**
   1269            * @brief  Checks whether the specified SPI/I2S interrupt has occurred or not.
   1270            * @param  SPIx: where x can be 1 or 2 in SPI mode or 1 in I2S mode to select 
   1271            *         the SPI peripheral.
   1272            * @param  SPI_I2S_IT: specifies the SPI interrupt source to check. 
   1273            *          This parameter can be one of the following values:
   1274            *            @arg SPI_I2S_IT_TXE: Transmit buffer empty interrupt.
   1275            *            @arg SPI_I2S_IT_RXNE: Receive buffer not empty interrupt.
   1276            *            @arg SPI_IT_MODF: Mode Fault interrupt.
   1277            *            @arg SPI_I2S_IT_OVR: Overrun interrupt.
   1278            *            @arg I2S_IT_UDR: Underrun interrupt.  
   1279            *            @arg SPI_I2S_IT_FRE: Format Error interrupt.  
   1280            * @retval The new state of SPI_I2S_IT (SET or RESET).
   1281            */
   1282          ITStatus SPI_I2S_GetITStatus(SPI_TypeDef* SPIx, uint8_t SPI_I2S_IT)
   1283          {
   1284            ITStatus bitstatus = RESET;
   1285            uint16_t itpos = 0, itmask = 0, enablestatus = 0;
   1286          
   1287            /* Check the parameters */
   1288            assert_param(IS_SPI_ALL_PERIPH(SPIx));
   1289            assert_param(IS_SPI_I2S_GET_IT(SPI_I2S_IT));
   1290          
   1291            /* Get the SPI_I2S_IT index */
   1292            itpos = 0x01 << (SPI_I2S_IT & 0x0F);
   1293          
   1294            /* Get the SPI_I2S_IT IT mask */
   1295            itmask = SPI_I2S_IT >> 4;
   1296          
   1297            /* Set the IT mask */
   1298            itmask = 0x01 << itmask;
   1299          
   1300            /* Get the SPI_I2S_IT enable bit status */
   1301            enablestatus = (SPIx->CR2 & itmask) ;
   1302          
   1303            /* Check the status of the specified SPI interrupt */
   1304            if (((SPIx->SR & itpos) != (uint16_t)RESET) && enablestatus)
   1305            {
   1306              /* SPI_I2S_IT is set */
   1307              bitstatus = SET;
   1308            }
   1309            else
   1310            {
   1311              /* SPI_I2S_IT is reset */
   1312              bitstatus = RESET;
   1313            }
   1314            /* Return the SPI_I2S_IT status */
   1315            return bitstatus;
   1316          }
   1317          
   1318          /**
   1319            * @}
   1320            */
   1321          
   1322          /**
   1323            * @}
   1324            */
   1325          
   1326          /**
   1327            * @}
   1328            */ 
   1329          
   1330          /**
   1331            * @}
   1332            */
   1333          
   1334          /************************ (C) COPYRIGHT STMicroelectronics *****END OF FILE****/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   I2S_Cmd
      64   I2S_Init
        64   -> RCC_GetClocksFreq
        64 __aeabi_uidiv
       0   I2S_StructInit
       0   SPI_BiDirectionalLineConfig
       0   SPI_CRCLengthConfig
       0   SPI_CalculateCRC
       0   SPI_Cmd
       0   SPI_DataSizeConfig
       0   SPI_GetCRC
       0   SPI_GetCRCPolynomial
       0   SPI_GetReceptionFIFOStatus
       0   SPI_GetTransmissionFIFOStatus
       0   SPI_I2S_ClearFlag
       0   SPI_I2S_DMACmd
       8   SPI_I2S_DeInit
         8   -> RCC_APB1PeriphResetCmd
         8   -> RCC_APB2PeriphResetCmd
       0   SPI_I2S_GetFlagStatus
      16   SPI_I2S_GetITStatus
       0   SPI_I2S_ITConfig
       0   SPI_I2S_ReceiveData16
       0   SPI_I2S_SendData16
       0   SPI_Init
       0   SPI_LastDMATransferCmd
       0   SPI_NSSInternalSoftwareConfig
       0   SPI_NSSPulseModeCmd
       0   SPI_ReceiveData8
       0   SPI_RxFIFOThresholdConfig
       0   SPI_SSOutputCmd
       0   SPI_SendData8
       0   SPI_StructInit
       0   SPI_TIModeCmd
       0   SPI_TransmitCRC


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable14_1
       4  ??DataTable14_10
       4  ??DataTable14_11
       4  ??DataTable14_12
       4  ??DataTable14_13
       4  ??DataTable14_14
       4  ??DataTable14_2
       4  ??DataTable14_3
       4  ??DataTable14_4
       4  ??DataTable14_5
       4  ??DataTable14_6
       4  ??DataTable14_7
       4  ??DataTable14_8
       4  ??DataTable14_9
      12  ?Subroutine0
      22  I2S_Cmd
     160  I2S_Init
      18  I2S_StructInit
      22  SPI_BiDirectionalLineConfig
      16  SPI_CRCLengthConfig
      22  SPI_CalculateCRC
      20  SPI_Cmd
      12  SPI_DataSizeConfig
      12  SPI_GetCRC
       4  SPI_GetCRCPolynomial
      10  SPI_GetReceptionFIFOStatus
      10  SPI_GetTransmissionFIFOStatus
       6  SPI_I2S_ClearFlag
      14  SPI_I2S_DMACmd
      54  SPI_I2S_DeInit
      14  SPI_I2S_GetFlagStatus
      38  SPI_I2S_GetITStatus
      26  SPI_I2S_ITConfig
       4  SPI_I2S_ReceiveData16
       4  SPI_I2S_SendData16
      72  SPI_Init
       4  SPI_LastDMATransferCmd
      22  SPI_NSSInternalSoftwareConfig
      20  SPI_NSSPulseModeCmd
       6  SPI_ReceiveData8
       6  SPI_RxFIFOThresholdConfig
      20  SPI_SSOutputCmd
       6  SPI_SendData8
      28  SPI_StructInit
      20  SPI_TIModeCmd
      12  SPI_TransmitCRC

 
 776 bytes in section .text
 
 776 bytes of CODE memory

Errors: none
Warnings: none

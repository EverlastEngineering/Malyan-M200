###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Oct/2019  17:33:36
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Marlin_main.cpp
#    Command line =
#        -f C:\Users\yongzong\AppData\Local\Temp\EWA5C5.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Marlin_main.cpp
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --c++ --no_exceptions --no_rtti --no_static_destruction -I
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\Marlin_main.lst
#    Object file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\Marlin_main.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\marlin\Marlin_main.cpp
      1          /**
      2           * Marlin Firmware
      3           *
      4           * Based on Sprinter and grbl.
      5           * Copyright (C) 2011 Camiel Gubbels / Erik van der Zalm
      6           *
      7           * This program is free software: you can redistribute it and/or modify
      8           * it under the terms of the GNU General Public License as published by
      9           * the Free Software Foundation, either version 3 of the License, or
     10           * (at your option) any later version.
     11           *
     12           * This program is distributed in the hope that it will be useful,
     13           * but WITHOUT ANY WARRANTY; without even the implied warranty of
     14           * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     15           * GNU General Public License for more details.
     16           *
     17           * You should have received a copy of the GNU General Public License
     18           * along with this program.  If not, see <http://www.gnu.org/licenses/>.
     19           *
     20           * About Marlin
     21           *
     22           * This firmware is a mashup between Sprinter and grbl.
     23           *  - https://github.com/kliment/Sprinter
     24           *  - https://github.com/simen/grbl/tree
     25           *
     26           * It has preliminary support for Matthew Roberts advance algorithm
     27           *  - http://reprap.org/pipermail/reprap-dev/2011-May/003323.html
     28           */
     29          
     30          #include "Marlin.h"
     31          
     32          #if ENABLED(AUTO_BED_LEVELING_FEATURE)
     33            #include "vector_3.h"
     34            #if ENABLED(AUTO_BED_LEVELING_GRID)
     35              #include "qr_solve.h"
     36            #endif
     37          #endif // AUTO_BED_LEVELING_FEATURE
     38          
     39          #if ENABLED(MESH_BED_LEVELING)
     40            #include "mesh_bed_leveling.h"
     41          #endif
     42          
     43          #include "planner.h"
     44          #include "stepper.h"
     45          #include "temperature.h"
     46          #include "cardreader.h"
     47          #include "configuration_store.h"
     48          #include "language.h"
     49          //#include "pins_arduino.h"
     50          #include "math.h"
     51          //#include "buzzer.h"
     52          
     53          #if ENABLED(USE_WATCHDOG)
     54            #include "watchdog.h"
     55          #endif
     56          
     57          #if ENABLED(BLINKM)
     58            #include "blinkm.h"
     59            #include "Wire.h"
     60          #endif
     61          
     62          #if HAS_SERVOS
     63            #include "servo.h"
     64          #endif
     65          
     66          #if HAS_DIGIPOTSS
     67            #include <SPI.h>
     68          #endif
     69          
     70          /**
     71           * Look here for descriptions of G-codes:
     72           *  - http://linuxcnc.org/handbook/gcode/g-code.html
     73           *  - http://objects.reprap.org/wiki/Mendel_User_Manual:_RepRapGCodes
     74           *
     75           * Help us document these G-codes online:
     76           *  - http://marlinfirmware.org/index.php/G-Code
     77           *  - http://reprap.org/wiki/G-code
     78           *
     79           * -----------------
     80           * Implemented Codes
     81           * -----------------
     82           *
     83           * "G" Codes
     84           *
     85           * G0  -> G1
     86           * G1  - Coordinated Movement X Y Z E
     87           * G2  - CW ARC
     88           * G3  - CCW ARC
     89           * G4  - Dwell S<seconds> or P<milliseconds>
     90           * G10 - retract filament according to settings of M207
     91           * G11 - retract recover filament according to settings of M208
     92           * G28 - Home one or more axes
     93           * G29 - Detailed Z probe, probes the bed at 3 or more points.  Will fail if you haven't homed yet.
     94           * G30 - Single Z probe, probes bed at current XY location.
     95           * G31 - Dock sled (Z_PROBE_SLED only)
     96           * G32 - Undock sled (Z_PROBE_SLED only)
     97           * G90 - Use Absolute Coordinates
     98           * G91 - Use Relative Coordinates
     99           * G92 - Set current position to coordinates given
    100           *
    101           * "M" Codes
    102           *
    103           * M0   - Unconditional stop - Wait for user to press a button on the LCD (Only if ULTRA_LCD is enabled)
    104           * M1   - Same as M0
    105           * M17  - Enable/Power all stepper motors
    106           * M18  - Disable all stepper motors; same as M84
    107           * M20  - List SD card
    108           * M21  - Init SD card
    109           * M22  - Release SD card
    110           * M23  - Select SD file (M23 filename.g)
    111           * M24  - Start/resume SD print
    112           * M25  - Pause SD print
    113           * M26  - Set SD position in bytes (M26 S12345)
    114           * M27  - Report SD print status
    115           * M28  - Start SD write (M28 filename.g)
    116           * M29  - Stop SD write
    117           * M30  - Delete file from SD (M30 filename.g)
    118           * M31  - Output time since last M109 or SD card start to serial
    119           * M32  - Select file and start SD print (Can be used _while_ printing from SD card files):
    120           *        syntax "M32 /path/filename#", or "M32 S<startpos bytes> !filename#"
    121           *        Call gcode file : "M32 P !filename#" and return to caller file after finishing (similar to #include).
    122           *        The '#' is necessary when calling from within sd files, as it stops buffer prereading
    123           * M33  - Get the longname version of a path
    124           * M42  - Change pin status via gcode Use M42 Px Sy to set pin x to value y, when omitting Px the onboard led will be used.
    125           * M48  - Measure Z_Probe repeatability. M48 [P # of points] [X position] [Y position] [V_erboseness #] [E_ngage Probe] [L # of legs of travel]
    126           * M80  - Turn on Power Supply
    127           * M81  - Turn off Power Supply
    128           * M82  - Set E codes absolute (default)
    129           * M83  - Set E codes relative while in Absolute Coordinates (G90) mode
    130           * M84  - Disable steppers until next move,
    131           *        or use S<seconds> to specify an inactivity timeout, after which the steppers will be disabled.  S0 to disable the timeout.
    132           * M85  - Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
    133           * M92  - Set axis_steps_per_unit - same syntax as G92
    134           * M104 - Set extruder target temp
    135           * M105 - Read current temp
    136           * M106 - Fan on
    137           * M107 - Fan off
    138           * M109 - Sxxx Wait for extruder current temp to reach target temp. Waits only when heating
    139           *        Rxxx Wait for extruder current temp to reach target temp. Waits when heating and cooling
    140           *        IF AUTOTEMP is enabled, S<mintemp> B<maxtemp> F<factor>. Exit autotemp by any M109 without F
    141           * M110 - Set the current line number
    142           * M111 - Set debug flags with S<mask>. See flag bits defined in Marlin.h.
    143           * M112 - Emergency stop
    144           * M114 - Output current position to serial port
    145           * M115 - Capabilities string
    146           * M117 - Display a message on the controller screen
    147           * M119 - Output Endstop status to serial port
    148           * M120 - Enable endstop detection
    149           * M121 - Disable endstop detection
    150           * M126 - Solenoid Air Valve Open (BariCUDA support by jmil)
    151           * M127 - Solenoid Air Valve Closed (BariCUDA vent to atmospheric pressure by jmil)
    152           * M128 - EtoP Open (BariCUDA EtoP = electricity to air pressure transducer by jmil)
    153           * M129 - EtoP Closed (BariCUDA EtoP = electricity to air pressure transducer by jmil)
    154           * M140 - Set bed target temp
    155           * M145 - Set the heatup state H<hotend> B<bed> F<fan speed> for S<material> (0=PLA, 1=ABS)
    156           * M150 - Set BlinkM Color Output R: Red<0-255> U(!): Green<0-255> B: Blue<0-255> over i2c, G for green does not work.
    157           * M190 - Sxxx Wait for bed current temp to reach target temp. Waits only when heating
    158           *        Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
    159           * M200 - set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).:D<millimeters>-
    160           * M201 - Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
    161           * M202 - Set max acceleration in units/s^2 for travel moves (M202 X1000 Y1000) Unused in Marlin!!
    162           * M203 - Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
    163           * M204 - Set default acceleration: P for Printing moves, R for Retract only (no X, Y, Z) moves and T for Travel (non printing) moves (ex. M204 P800 T3000 R9000) in mm/sec^2
    164           * M205 -  advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk, E=maximum E jerk
    165           * M206 - Set additional homing offset
    166           * M207 - Set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop], stays in mm regardless of M200 setting
    167           * M208 - Set recover=unretract length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
    168           * M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
    169           * M218 - Set hotend offset (in mm): T<extruder_number> X<offset_on_X> Y<offset_on_Y>
    170           * M220 - Set speed factor override percentage: S<factor in percent>
    171           * M221 - Set extrude factor override percentage: S<factor in percent>
    172           * M226 - Wait until the specified pin reaches the state required: P<pin number> S<pin state>
    173           * M240 - Trigger a camera to take a photograph
    174           * M250 - Set LCD contrast C<contrast value> (value 0..63)
    175           * M280 - Set servo position absolute. P: servo index, S: angle or microseconds
    176           * M300 - Play beep sound S<frequency Hz> P<duration ms>
    177           * M301 - Set PID parameters P I and D
    178           * M302 - Allow cold extrudes, or set the minimum extrude S<temperature>.
    179           * M303 - PID relay autotune S<temperature> sets the target temperature. (default target temperature = 150C)
    180           * M304 - Set bed PID parameters P I and D
    181           * M380 - Activate solenoid on active extruder
    182           * M381 - Disable all solenoids
    183           * M400 - Finish all moves
    184           * M401 - Lower Z probe if present
    185           * M402 - Raise Z probe if present
    186           * M404 - N<dia in mm> Enter the nominal filament width (3mm, 1.75mm ) or will display nominal filament width without parameters
    187           * M405 - Turn on Filament Sensor extrusion control.  Optional D<delay in cm> to set delay in centimeters between sensor and extruder
    188           * M406 - Turn off Filament Sensor extrusion control
    189           * M407 - Display measured filament diameter
    190           * M410 - Quickstop. Abort all the planned moves
    191           * M420 - Enable/Disable Mesh Leveling (with current values) S1=enable S0=disable
    192           * M421 - Set a single Z coordinate in the Mesh Leveling grid. X<mm> Y<mm> Z<mm>
    193           * M428 - Set the home_offset logically based on the current_position
    194           * M500 - Store parameters in EEPROM
    195           * M501 - Read parameters from EEPROM (if you need reset them after you changed them temporarily).
    196           * M502 - Revert to the default "factory settings". You still need to store them in EEPROM afterwards if you want to.
    197           * M503 - Print the current settings (from memory not from EEPROM). Use S0 to leave off headings.
    198           * M540 - Use S[0|1] to enable or disable the stop SD card print on endstop hit (requires ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
    199           * M600 - Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
    200           * M665 - Set delta configurations: L<diagonal rod> R<delta radius> S<segments/s>
    201           * M666 - Set delta endstop adjustment
    202           * M605 - Set dual x-carriage movement mode: S<mode> [ X<duplication x-offset> R<duplication temp offset> ]
    203           * M907 - Set digital trimpot motor current using axis codes.
    204           * M908 - Control digital trimpot directly.
    205           * M350 - Set microstepping mode.
    206           * M351 - Toggle MS1 MS2 pins directly.
    207           *
    208           * ************ SCARA Specific - This can change to suit future G-code regulations
    209           * M360 - SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
    210           * M361 - SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
    211           * M362 - SCARA calibration: Move to cal-position PsiA (0 deg calibration)
    212           * M363 - SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
    213           * M364 - SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
    214           * M365 - SCARA calibration: Scaling factor, X, Y, Z axis
    215           * ************* SCARA End ***************
    216           *
    217           * ************ Custom codes - This can change to suit future G-code regulations
    218           * M100 - Watch Free Memory (For Debugging Only)
    219           * M851 - Set Z probe's Z offset (mm above extruder -- The value will always be negative)
    220          
    221          
    222           * M928 - Start SD logging (M928 filename.g) - ended by M29
    223           * M999 - Restart after being stopped by error
    224           *
    225           * "T" Codes
    226           *
    227           * T0-T3 - Select a tool by index (usually an extruder) [ F<mm/min> ]
    228           *
    229           */
    230          
    231          #if ENABLED(M100_FREE_MEMORY_WATCHER)
    232            void gcode_M100();
    233          #endif
    234          
    235          #if ENABLED(SDSUPPORT)
    236            CardReader card;
    237          #endif
    238          
    239          unsigned int L[10];
    240          int R[10];
    241          
    242          bool Running = true;
    243          bool homing = false;
    244          
    245          uint8_t marlin_debug_flags = DEBUG_INFO | DEBUG_ERRORS;
    246          
    247          float feedrate = 1500.0, saved_feedrate;
    248          float current_position[NUM_AXIS] = { 0.0 };
    249          float destination[NUM_AXIS] = { 0.0 };
    250          bool axis_known_position[3] = { false };
    251          
    252          static long gcode_N, gcode_LastN, Stopped_gcode_LastN = 0;
    253          
    254          static char* current_command, *current_command_args;
    255          static int cmd_queue_index_r = 0;
    256          static int cmd_queue_index_w = 0;
    257          static int commands_in_queue = 0;
    258          static char command_queue[BUFSIZE][MAX_CMD_SIZE];
    259          static unsigned int curpos[BUFSIZE];
    260          unsigned int procpos=0;
    261          unsigned int execpos=0;
    262          
    263          //const float homing_feedrate[] = HOMING_FEEDRATE;
    264          extern float homing_feedrate[];
    265          bool axis_relative_modes[] = AXIS_RELATIVE_MODES;
    266          int feedrate_multiplier = 100; //100->1 200->2
    267          int saved_feedrate_multiplier;
    268          int extruder_multiplier[MAX_EXTRUDERS] = ARRAY_BY_EXTRUDERS1(100);
    269          bool volumetric_enabled = false;
    270          float filament_size[MAX_EXTRUDERS] = ARRAY_BY_EXTRUDERS1(DEFAULT_NOMINAL_FILAMENT_DIA);
    271          float volumetric_multiplier[MAX_EXTRUDERS] = ARRAY_BY_EXTRUDERS1(1.0);
    272          float home_offset[3] = { 0 };
    273          float min_pos[3] = { X_MIN_POS, Y_MIN_POS, Z_MIN_POS };
    274          //float max_pos[3] = { 150, 150, 150 };
    275          extern float max_pos[3];
    276          
    277          uint8_t active_extruder = 0;
    278          int fanSpeed = 0;
    279          bool cancel_heatup = false;
    280          
    281          const char errormagic[] PROGMEM = "Error:";
    282          const char echomagic[] PROGMEM = "echo:";
    283          const char axis_codes[NUM_AXIS] = {'X', 'Y', 'Z', 'E'};
    284          
    285          bool relative_mode = false;  //Determines Absolute or Relative Coordinates
    286          static char serial_char;
    287          static int serial_count = 0;
    288          static bool comment_mode = false;
    289          static char* seen_pointer; ///< A pointer to find chars in the command string (X, Y, Z, E, etc.)
    290          const char* queued_commands_P = NULL; /* pointer to the current line in the active sequence of commands, or NULL when none */
    291          //const int sensitive_pins[] = SENSITIVE_PINS; ///< Sensitive pin list for M42
    292          // Inactivity shutdown
    293          millis_t previous_cmd_ms = 0;
    294          static millis_t max_inactive_time = 0;
    295          static millis_t stepper_inactive_time = DEFAULT_STEPPER_DEACTIVE_TIME * 1000L;
    296          millis_t print_job_start_ms = 0; ///< Print job start time
    297          millis_t print_job_stop_ms = 0;  ///< Print job stop time
    298          static uint8_t target_extruder;
    299          bool no_wait_for_cooling = true;
    300          bool target_direction;
    301          
    302          #if ENABLED(AUTO_BED_LEVELING_FEATURE)
    303            int xy_travel_speed = XY_TRAVEL_SPEED;
    304            //float zprobe_zoffset = Z_PROBE_OFFSET_FROM_EXTRUDER;
    305          #endif
    306            float zprobe_zoffset = 0;
    307          
    308          #if ENABLED(Z_DUAL_ENDSTOPS) && DISABLED(DELTA)
    309            float z_endstop_adj = 0;
    310          #endif
    311          
    312          // Extruder offsets
    313          //#if EXTRUDERS > 1
    314            #ifndef EXTRUDER_OFFSET_X
    315              #define EXTRUDER_OFFSET_X { 0 }
    316            #endif
    317            #ifndef EXTRUDER_OFFSET_Y
    318              #define EXTRUDER_OFFSET_Y { 0 }
    319            #endif
    320            float extruder_offset[][MAX_EXTRUDERS] = {
    321              EXTRUDER_OFFSET_X,
    322              EXTRUDER_OFFSET_Y
    323              #if ENABLED(DUAL_X_CARRIAGE)
    324                , { 0 } // supports offsets in XYZ plane
    325              #endif
    326            };
    327          //#endif
    328          
    329          #if HAS_SERVO_ENDSTOPS
    330            const int servo_endstop_id[] = SERVO_ENDSTOP_IDS;
    331            const int servo_endstop_angle[][2] = SERVO_ENDSTOP_ANGLES;
    332          #endif
    333          
    334          #if ENABLED(BARICUDA)
    335            int ValvePressure = 0;
    336            int EtoPPressure = 0;
    337          #endif
    338          
    339          #if ENABLED(FWRETRACT)
    340          
    341            bool autoretract_enabled = false;
    342            bool retracted[EXTRUDERS] = { false };
    343            bool retracted_swap[EXTRUDERS] = { false };
    344          
    345            float retract_length = RETRACT_LENGTH;
    346            float retract_length_swap = RETRACT_LENGTH_SWAP;
    347            float retract_feedrate = RETRACT_FEEDRATE;
    348            float retract_zlift = RETRACT_ZLIFT;
    349            float retract_recover_length = RETRACT_RECOVER_LENGTH;
    350            float retract_recover_length_swap = RETRACT_RECOVER_LENGTH_SWAP;
    351            float retract_recover_feedrate = RETRACT_RECOVER_FEEDRATE;
    352          
    353          #endif // FWRETRACT
    354          
    355          #if ENABLED(ULTIPANEL) && HAS_POWER_SWITCH
    356            bool powersupply =
    357              #if ENABLED(PS_DEFAULT_OFF)
    358                false
    359              #else
    360                true
    361              #endif
    362            ;
    363          #endif
    364          
    365          #if ENABLED(DELTA)
    366          
    367            #define TOWER_1 X_AXIS
    368            #define TOWER_2 Y_AXIS
    369            #define TOWER_3 Z_AXIS
    370          
    371            float delta[3] = { 0 };
    372            #define SIN_60 0.8660254037844386
    373            #define COS_60 0.5
    374            float endstop_adj[3] = { 0 };
    375            // these are the default values, can be overriden with M665
    376            float delta_radius = DELTA_RADIUS;
    377            float delta_tower1_x = -SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1); // front left tower
    378            float delta_tower1_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_1);
    379            float delta_tower2_x =  SIN_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2); // front right tower
    380            float delta_tower2_y = -COS_60 * (delta_radius + DELTA_RADIUS_TRIM_TOWER_2);
    381            float delta_tower3_x = 0;                                                    // back middle tower
    382            float delta_tower3_y = (delta_radius + DELTA_RADIUS_TRIM_TOWER_3);
    383            float delta_diagonal_rod = DELTA_DIAGONAL_ROD;
    384            float delta_diagonal_rod_trim_tower_1 = DELTA_DIAGONAL_ROD_TRIM_TOWER_1;
    385            float delta_diagonal_rod_trim_tower_2 = DELTA_DIAGONAL_ROD_TRIM_TOWER_2;
    386            float delta_diagonal_rod_trim_tower_3 = DELTA_DIAGONAL_ROD_TRIM_TOWER_3;
    387            float delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);
    388            float delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);
    389            float delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);
    390            //float delta_diagonal_rod_2 = sq(delta_diagonal_rod);
    391            float delta_segments_per_second = DELTA_SEGMENTS_PER_SECOND;
    392            #if ENABLED(AUTO_BED_LEVELING_FEATURE)
    393              int delta_grid_spacing[2] = { 0, 0 };
    394              float bed_level[AUTO_BED_LEVELING_GRID_POINTS][AUTO_BED_LEVELING_GRID_POINTS];
    395              int auto_bed_leveling_grid_points = 2;
    396            #endif
    397            static bool home_all_axis = true;
    398          #else
    399            static bool home_all_axis = true;
    400            //float bed_level[AUTO_BED_LEVELING_GRID_POINTS][AUTO_BED_LEVELING_GRID_POINTS];
    401            //int auto_bed_leveling_grid_points = 2;
    402            //int delta_grid_spacing[2] = { 0, 0 };
    403          #endif
    404          
    405          #if ENABLED(SCARA)
    406            float delta_segments_per_second = SCARA_SEGMENTS_PER_SECOND;
    407            static float delta[3] = { 0 };
    408            float axis_scaling[3] = { 1, 1, 1 };    // Build size scaling, default to 1
    409          #endif
    410          
    411          #if ENABLED(FILAMENT_SENSOR)
    412            //Variables for Filament Sensor input
    413            float filament_width_nominal = DEFAULT_NOMINAL_FILAMENT_DIA;  //Set nominal filament width, can be changed with M404
    414            bool filament_sensor = false;  //M405 turns on filament_sensor control, M406 turns it off
    415            float filament_width_meas = DEFAULT_MEASURED_FILAMENT_DIA; //Stores the measured filament diameter
    416            signed char measurement_delay[MAX_MEASUREMENT_DELAY + 1]; //ring buffer to delay measurement  store extruder factor after subtracting 100
    417            int delay_index1 = 0;  //index into ring buffer
    418            int delay_index2 = -1;  //index into ring buffer - set to -1 on startup to indicate ring buffer needs to be initialized
    419            float delay_dist = 0; //delay distance counter
    420            int meas_delay_cm = MEASUREMENT_DELAY_CM;  //distance delay setting
    421          #endif
    422          
    423          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
    424            static bool filrunoutEnqueued = false;
    425          #endif
    426          
    427          #if ENABLED(SDSUPPORT)
    428            static bool fromsd[BUFSIZE];
    429          #endif
    430          
    431          #if HAS_SERVOS
    432            Servo servo[NUM_SERVOS];
    433          #endif
    434          
    435          #ifdef CHDK
    436            unsigned long chdkHigh = 0;
    437            boolean chdkActive = false;
    438          #endif
    439          
    440          #if ENABLED(PID_ADD_EXTRUSION_RATE)
    441            int lpq_len = 20;
    442          #endif
    443          
    444          //===========================================================================
    445          //================================ Functions ================================
    446          //===========================================================================
    447          
    448          void process_next_command();
    449          
    450          void plan_arc(float target[NUM_AXIS], float* offset, uint8_t clockwise);
    451          
    452          bool setTargetedHotend(int code);
    453          
    454          void serial_echopair_P(const char* s_P, int v)           { serialprintPGM(s_P); SERIAL_ECHO(v); }
    455          void serial_echopair_P(const char* s_P, long v)          { serialprintPGM(s_P); SERIAL_ECHO(v); }
    456          void serial_echopair_P(const char* s_P, float v)         { serialprintPGM(s_P); SERIAL_ECHO(v); }
    457          void serial_echopair_P(const char* s_P, double v)        { serialprintPGM(s_P); SERIAL_ECHO(v); }
    458          void serial_echopair_P(const char* s_P, unsigned long v) { serialprintPGM(s_P); SERIAL_ECHO(v); }
    459          
    460          #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
    461            float extrude_min_temp = EXTRUDE_MINTEMP;
    462          #endif
    463          
    464          #define NO_MALLINFO 0
    465          #include "mallocstats.h"//yongzong
    466          #if 0//ENABLED(SDSUPPORT)
    467            #include "SdFatUtil.h"
    468            int freeMemory() { return SdFatUtil::FreeRam(); }
    469          #else
    470          /*extern "C" {
    471            int freeMemory() {
    472              struct mallinfo m;
    473              m = __iar_dlmallinfo();
    474              return m.fordblks;
    475            }
    476          }*/
    477          #endif //!SDSUPPORT
    478          
    479          extern void wifi_writeString(char message[]);
    480          static bool buffer_status=false;
    481          bool buffered_printing()
    482          {
    483              if (buffer_status)
    484              {
    485                  //if (commands_in_queue==0)
    486                  if (axis_known_position[X_AXIS] == false &&
    487                      axis_known_position[Y_AXIS] == false &&
    488                      axis_known_position[Z_AXIS] == false)
    489                      buffer_status=false;
    490              }
    491              else
    492              {
    493                  if (commands_in_queue>=BUFSIZE-1) buffer_status=true;
    494                  extern void StartBuild();
    495                  StartBuild();
    496              }
    497              return buffer_status;
    498          }
    499          
    500          
    501          /**
    502           * Inject the next command from the command queue, when possible
    503           * Return false only if no command was pending
    504           */
    505          static bool drain_queued_commands_P() {
    506            if (!queued_commands_P) return false;
    507          
    508            // Get the next 30 chars from the sequence of gcodes to run
    509            char cmd[30];
    510            strncpy(cmd, queued_commands_P, sizeof(cmd) - 1);
    511            cmd[sizeof(cmd) - 1] = '\0';
    512          
    513            // Look for the end of line, or the end of sequence
    514            size_t i = 0;
    515            char c;
    516            while ((c = cmd[i]) && c != '\n') i++; // find the end of this gcode command
    517            cmd[i] = '\0';
    518            if (enqueuecommand(cmd)) {      // buffer was not full (else we will retry later)
    519              if (c)
    520                queued_commands_P += i + 1; // move to next command
    521              else
    522                queued_commands_P = NULL;   // will have no more commands in the sequence
    523            }
    524            return true;
    525          }
    526          
    527          /**
    528           * Record one or many commands to run from program memory.
    529           * Aborts the current queue, if any.
    530           * Note: drain_queued_commands_P() must be called repeatedly to drain the commands afterwards
    531           */
    532          void enqueuecommands_P(const char* pgcode) {
    533            queued_commands_P = pgcode;
    534            drain_queued_commands_P(); // first command executed asap (when possible)
    535          }
    536          
    537          /**
    538           * Copy a command directly into the main command buffer, from RAM.
    539           *
    540           * This is done in a non-safe way and needs a rework someday.
    541           * Returns false if it doesn't add any command
    542           */
    543          bool enqueuecommand(const char* cmd) {
    544            if (*cmd == ';' || commands_in_queue >= BUFSIZE) return false;
    545          
    546            // This is dangerous if a mixing of serial and this happens
    547            char* command = command_queue[cmd_queue_index_w];
    548            strcpy(command, cmd);
    549            /*SERIAL_ECHO_START;
    550            SERIAL_ECHOPGM(MSG_Enqueueing);
    551            SERIAL_ECHO(command);
    552            SERIAL_ECHOLNPGM("\"");*/
    553            cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;
    554            commands_in_queue++;
    555            return true;
    556          }
    557          
    558          void setup_killpin() {
    559            #if HAS_KILL
    560              SET_INPUT(KILL_PIN);
    561              WRITE(KILL_PIN, HIGH);
    562            #endif
    563          }
    564          
    565          void setup_filrunoutpin() {
    566            #if HAS_FILRUNOUT
    567              pinMode(FILRUNOUT_PIN, INPUT);
    568              #if ENABLED(ENDSTOPPULLUP_FIL_RUNOUT)
    569                WRITE(FILRUNOUT_PIN, HIGH);
    570              #endif
    571            #endif
    572          }
    573          
    574          // Set home pin
    575          void setup_homepin(void) {
    576            homing=false;
    577            #if HAS_HOME
    578              SET_INPUT(HOME_PIN);
    579              WRITE(HOME_PIN, HIGH);
    580            #endif
    581          }
    582          
    583          
    584          void setup_photpin() {
    585            #if HAS_PHOTOGRAPH
    586              OUT_WRITE(PHOTOGRAPH_PIN, LOW);
    587            #endif
    588          }
    589          
    590          void setup_powerhold() {
    591            #if HAS_SUICIDE
    592              OUT_WRITE(SUICIDE_PIN, HIGH);
    593            #endif
    594            #if HAS_POWER_SWITCH
    595              #if ENABLED(PS_DEFAULT_OFF)
    596                OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
    597              #else
    598                OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE);
    599              #endif
    600            #endif
    601          }
    602          
    603          void suicide() {
    604            #if HAS_SUICIDE
    605              OUT_WRITE(SUICIDE_PIN, LOW);
    606            #endif
    607          }
    608          
    609          void servo_init() {
    610            #if NUM_SERVOS >= 1 && HAS_SERVO_0
    611              servo[0].attach(SERVO0_PIN);
    612              servo[0].detach(); // Just set up the pin. We don't have a position yet. Don't move to a random position.
    613            #endif
    614            #if NUM_SERVOS >= 2 && HAS_SERVO_1
    615              servo[1].attach(SERVO1_PIN);
    616              servo[1].detach();
    617            #endif
    618            #if NUM_SERVOS >= 3 && HAS_SERVO_2
    619              servo[2].attach(SERVO2_PIN);
    620              servo[2].detach();
    621            #endif
    622            #if NUM_SERVOS >= 4 && HAS_SERVO_3
    623              servo[3].attach(SERVO3_PIN);
    624              servo[3].detach();
    625            #endif
    626          
    627            // Set position of Servo Endstops that are defined
    628            #if HAS_SERVO_ENDSTOPS
    629              for (int i = 0; i < 3; i++)
    630                if (servo_endstop_id[i] >= 0)
    631                  servo[servo_endstop_id[i]].move(servo_endstop_angle[i][1]);
    632            #endif
    633          
    634          }
    635          
    636          /**
    637           * Stepper Reset (RigidBoard, et.al.)
    638           */
    639          #if HAS_STEPPER_RESET
    640            void disableStepperDrivers() {
    641              pinMode(STEPPER_RESET_PIN, OUTPUT);
    642              digitalWrite(STEPPER_RESET_PIN, LOW);  // drive it down to hold in reset motor driver chips
    643            }
    644            void enableStepperDrivers() { pinMode(STEPPER_RESET_PIN, INPUT); }  // set to input, which allows it to be pulled high by pullups
    645          #endif
    646          
    647          /**
    648           * Marlin entry-point: Set up before the program loop
    649           *  - Set up the kill pin, filament runout, power hold
    650           *  - Start the serial port
    651           *  - Print startup messages and diagnostics
    652           *  - Get EEPROM or default settings
    653           *  - Initialize managers for:
    654           *    â€?temperature
    655           *    â€?planner
    656           *    â€?watchdog
    657           *    â€?stepper
    658           *    â€?photo pin
    659           *    â€?servos
    660           *    â€?LCD controller
    661           *    â€?Digipot I2C
    662           *    â€?Z probe sled
    663           *    â€?status LEDs
    664           */
    665          void setup() {
    666            setup_killpin();
    667            setup_filrunoutpin();
    668            setup_powerhold();
    669          
    670            #if HAS_STEPPER_RESET
    671              disableStepperDrivers();
    672            #endif
    673          
    674            //MYSERIAL.begin(BAUDRATE);
    675            /*SERIAL_PROTOCOLLNPGM("start");
    676            SERIAL_ECHO_START;
    677          
    678            // Check startup - does nothing if bootloader sets MCUSR to 0
    679            byte mcu = MCUSR;
    680            if (mcu & 1) SERIAL_ECHOLNPGM(MSG_POWERUP);
    681            if (mcu & 2) SERIAL_ECHOLNPGM(MSG_EXTERNAL_RESET);
    682            if (mcu & 4) SERIAL_ECHOLNPGM(MSG_BROWNOUT_RESET);
    683            if (mcu & 8) SERIAL_ECHOLNPGM(MSG_WATCHDOG_RESET);
    684            if (mcu & 32) SERIAL_ECHOLNPGM(MSG_SOFTWARE_RESET);
    685            MCUSR = 0;*/
    686          /*
    687            SERIAL_ECHOPGM(MSG_MARLIN);
    688            SERIAL_ECHOLNPGM(" " SHORT_BUILD_VERSION);
    689          
    690            #ifdef STRING_DISTRIBUTION_DATE
    691              #ifdef STRING_CONFIG_H_AUTHOR
    692                SERIAL_ECHO_START;
    693                SERIAL_ECHOPGM(MSG_CONFIGURATION_VER);
    694                SERIAL_ECHOPGM(STRING_DISTRIBUTION_DATE);
    695                SERIAL_ECHOPGM(MSG_AUTHOR);
    696                SERIAL_ECHOLNPGM(STRING_CONFIG_H_AUTHOR);
    697                SERIAL_ECHOPGM("Compiled: ");
    698                SERIAL_ECHOLNPGM(__DATE__);
    699                SERIAL_ECHOLNPGM(__TIME__);
    700              #endif // STRING_CONFIG_H_AUTHOR
    701            #endif // STRING_DISTRIBUTION_DATE
    702          
    703            SERIAL_ECHO_START;
    704            SERIAL_ECHOPGM(MSG_FREE_MEMORY);
    705            //SERIAL_ECHO(freeMemory());
    706            SERIAL_ECHOPGM(MSG_PLANNER_BUFFER_BYTES);
    707            SERIAL_ECHOLN((int)sizeof(block_t)*BLOCK_BUFFER_SIZE);
    708          */
    709            #if ENABLED(SDSUPPORT)
    710              for (int8_t i = 0; i < BUFSIZE; i++) fromsd[i] = false;
    711            #endif
    712          
    713            // loads data from EEPROM if available else uses defaults (and resets step acceleration rate)
    714            Config_RetrieveSettings(false);
    715          
    716            //lcd_init();
    717          
    718            extern void wifi_init();
    719            wifi_init();
    720          
    721            tp_init();    // Initialize temperature loop
    722            extern void analog_init();
    723            analog_init();
    724            plan_init();  // Initialize planner;
    725          
    726            #if ENABLED(USE_WATCHDOG)
    727              watchdog_init();
    728            #endif
    729          
    730            st_init();    // Initialize stepper, this enables interrupts!
    731            setup_photpin();
    732            servo_init();
    733          
    734            #if HAS_CONTROLLERFAN
    735              SET_OUTPUT(CONTROLLERFAN_PIN); //Set pin used for driver cooling fan
    736            #endif
    737          
    738            #if HAS_STEPPER_RESET
    739              enableStepperDrivers();
    740            #endif
    741          
    742            #if ENABLED(DIGIPOT_I2C)
    743              digipot_i2c_init();
    744            #endif
    745          
    746            #if ENABLED(Z_PROBE_SLED)
    747              pinMode(SLED_PIN, OUTPUT);
    748              digitalWrite(SLED_PIN, LOW); // turn it off
    749            #endif // Z_PROBE_SLED
    750          
    751            setup_homepin();
    752          
    753            #ifdef STAT_LED_RED
    754              pinMode(STAT_LED_RED, OUTPUT);
    755              digitalWrite(STAT_LED_RED, LOW); // turn it off
    756            #endif
    757          
    758            #ifdef STAT_LED_BLUE
    759              pinMode(STAT_LED_BLUE, OUTPUT);
    760              digitalWrite(STAT_LED_BLUE, LOW); // turn it off
    761            #endif
    762          
    763              //card.initsd();
    764          }
    765          
    766          /**
    767           * The main Marlin program loop
    768           *
    769           *  - Save or log commands to SD
    770           *  - Process available commands (if not saving)
    771           *  - Call heater manager
    772           *  - Call inactivity manager
    773           *  - Call endstop manager
    774           *  - Call LCD update
    775           */
    776          volatile bool sdprint_cancel=false;
    777          void loop() {
    778            if (sdprint_cancel)
    779            {
    780                //printf("!!!sdprint_cancel\n");
    781                sdprint_cancel=false;
    782                sdprinting = false;
    783                quickStop();
    784                card.closefile();
    785          
    786                autotempShutdown();
    787                cancel_heatup = true;
    788                
    789                cmd_queue_index_r = 0;
    790                cmd_queue_index_w = 0;
    791                commands_in_queue = 0;
    792                
    793                memset(command_queue, 0, sizeof(command_queue));
    794                memset(block_buffer, 0, sizeof(block_buffer));
    795          
    796                finishAndDisableSteppers();
    797            }
    798            if (commands_in_queue < BUFSIZE - 1) get_command();
    799          
    800            #if ENABLED(SDSUPPORT)
    801              card.checkautostart(false);
    802            #endif
    803          
    804            if (commands_in_queue) {
    805          
    806              #if ENABLED(SDSUPPORT)
    807          
    808                if (card.saving) {
    809                  char* command = command_queue[cmd_queue_index_r];
    810                  if (strstr(command, PSTR("M29"))) {
    811                    // M29 closes the file
    812                    card.closefile();
    813                    SERIAL_PROTOCOLLNPGM(MSG_FILE_SAVED);
    814                  }
    815                  else {
    816                    // Write the string from the read buffer to SD
    817                    card.write_command(command);
    818                    if (card.logging)
    819                      process_next_command(); // The card is saving because it's logging
    820                    else
    821                    {
    822                      SERIAL_PROTOCOLLNPGM(MSG_OK);
    823                    }
    824                  }
    825                }
    826                else
    827                  process_next_command();
    828          
    829              #else
    830          
    831                process_next_command();
    832          
    833              #endif // SDSUPPORT
    834          
    835              commands_in_queue--;
    836              cmd_queue_index_r = (cmd_queue_index_r + 1) % BUFSIZE;
    837            }
    838            checkHitEndstops();
    839            idle();
    840          }
    841          
    842          void gcode_line_error(const char* err, bool doFlush = true) {
    843            SERIAL_ERROR_START;
    844            serialprintPGM(err);
    845            SERIAL_ERRORLN(gcode_LastN);
    846            //Serial.println(gcode_N);
    847            if (doFlush) FlushSerialRequestResend();
    848            serial_count = 0;
    849          }
    850          
    851          /**
    852           * Add to the circular command queue the next command from:
    853           *  - The command-injection queue (queued_commands_P)
    854           *  - The active serial input (usually USB)
    855           *  - The SD card file being actively printed
    856           */
    857          void get_command() {
    858          
    859            if (drain_queued_commands_P()) return; // priority is given to non-serial commands
    860          
    861            #if ENABLED(NO_TIMEOUTS)
    862              static millis_t last_command_time = 0;
    863              millis_t ms = millis();
    864          
    865              if (!MYSERIAL.available() && commands_in_queue == 0 && ms - last_command_time > NO_TIMEOUTS) {
    866                SERIAL_ECHOLNPGM(MSG_WAIT);
    867                last_command_time = ms;
    868              }
    869            #endif
    870          
    871            //
    872            // Loop while serial characters are incoming and the queue is not full
    873            //
    874            while (commands_in_queue < BUFSIZE && MYSERIAL.available() > 0) {
    875          
    876              #if ENABLED(NO_TIMEOUTS)
    877                last_command_time = ms;
    878              #endif
    879          
    880              serial_char = MYSERIAL.read();
    881          
    882              //
    883              // If the character ends the line, or the line is full...
    884              //
    885              if (serial_char == '\n' || serial_char == '\r' || serial_count >= MAX_CMD_SIZE - 1) {
    886          
    887                // end of line == end of comment
    888                comment_mode = false;
    889          
    890                if (!serial_count) return; // empty lines just exit
    891          
    892                char* command = command_queue[cmd_queue_index_w];
    893                command[serial_count] = 0; // terminate string
    894          #ifdef PRINT_INFO
    895                SEGGER_RTT_WriteString(0,command);
    896                SEGGER_RTT_Write(0, "\n", 1);//yongzong
    897          #endif
    898                // this item in the queue is not from sd
    899                #if ENABLED(SDSUPPORT)
    900                  fromsd[cmd_queue_index_w] = false;
    901                #endif
    902          
    903                while (*command == ' ') command++; // skip any leading spaces
    904                char* npos = (*command == 'N') ? command : NULL; // Require the N parameter to start the line
    905                char* apos = strchr(command, '*');
    906          
    907                if (npos) {
    908          
    909                  boolean M110 = strstr(command, PSTR("M110")) != NULL;
    910          
    911                  if (M110) {
    912                    char* n2pos = strchr(command + 4, 'N');
    913                    if (n2pos) npos = n2pos;
    914                  }
    915          
    916                  gcode_N = strtol(npos + 1, NULL, 10);
    917          
    918                  if (gcode_N != gcode_LastN + 1 && !M110) {
    919                    gcode_line_error(PSTR(MSG_ERR_LINE_NO));
    920                    idle();//yongzong
    921                    return;
    922                  }
    923          
    924                  if (apos) {
    925                    byte checksum = 0, count = 0;
    926                    while (command[count] != '*') checksum ^= command[count++];
    927          
    928                    if (strtol(apos + 1, NULL, 10) != checksum) {
    929                      gcode_line_error(PSTR(MSG_ERR_CHECKSUM_MISMATCH));
    930                      return;
    931                    }
    932                    // if no errors, continue parsing
    933                  }
    934                  else if (npos == command) {
    935                    gcode_line_error(PSTR(MSG_ERR_NO_CHECKSUM));
    936                    return;
    937                  }
    938          
    939                  gcode_LastN = gcode_N;
    940                  // if no errors, continue parsing
    941                }
    942                else if (apos) { // No '*' without 'N'
    943                  gcode_line_error(PSTR(MSG_ERR_NO_LINENUMBER_WITH_CHECKSUM), false);
    944                  return;
    945                }
    946          
    947                // Movement commands alert when stopped
    948                if (IsStopped()) {
    949                  char* gpos = strchr(command, 'G');
    950                  if (gpos) {
    951                    int codenum = strtol(gpos + 1, NULL, 10);
    952                    switch (codenum) {
    953                      case 0:
    954                      case 1:
    955                      case 2:
    956                      case 3:
    957                        SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
    958                        //LCD_MESSAGEPGM(MSG_STOPPED);
    959                        break;
    960                    }
    961                  }
    962                }
    963          
    964                // If command was e-stop process now
    965                if (strcmp(command, "M112") == 0) kill(PSTR(MSG_KILLED));
    966          
    967                cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;
    968                commands_in_queue += 1;
    969          
    970                serial_count = 0; //clear buffer
    971              }
    972              else if (serial_char == '\\') {  // Handle escapes
    973                if (MYSERIAL.available() > 0 && commands_in_queue < BUFSIZE) {
    974                  // if we have one more character, copy it over
    975                  serial_char = MYSERIAL.read();
    976                  command_queue[cmd_queue_index_w][serial_count++] = serial_char;
    977                }
    978                // otherwise do nothing
    979              }
    980              else { // its not a newline, carriage return or escape char
    981                if (serial_char == ';') comment_mode = true;
    982                if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;
    983              }
    984            }
    985          
    986            #if ENABLED(SDSUPPORT)
    987          
    988              if (!sdprinting || serial_count) return;
    989          
    990              // '#' stops reading from SD to the buffer prematurely, so procedural macro calls are possible
    991              // if it occurs, stop_buffering is triggered and the buffer is ran dry.
    992              // this character _can_ occur in serial com, due to checksums. however, no checksums are used in SD printing
    993          
    994              static bool stop_buffering = false;
    995              if (commands_in_queue == 0) stop_buffering = false;
    996          
    997              bool macro_enable=false;
    998              while (!card.eof() && commands_in_queue < BUFSIZE && !stop_buffering) {
    999                int16_t n = card.get();
   1000                serial_char = (char)n;
   1001          #ifdef PRINT_INFO
   1002                SEGGER_RTT_Write(0,&serial_char,1);
   1003          #endif
   1004          
   1005                if (serial_char == '\n' || serial_char == '\r' ||
   1006                    ((serial_char == '#' || serial_char == ':') && !comment_mode) ||
   1007                    serial_count >= (MAX_CMD_SIZE - 1) || n == -1
   1008                ) {
   1009                  if (card.eof()) {
   1010                        extern uint8_t started;
   1011                        started=0;
   1012                        SERIAL_PROTOCOLLNPGM(MSG_FILE_PRINTED);
   1013                        print_job_stop_ms = millis();
   1014                        char time[30];
   1015                        millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;
   1016                        int hours = t / 60 / 60, minutes = (t / 60) % 60;
   1017                        sprintf(time, PSTR("%i " MSG_END_HOUR " %i " MSG_END_MINUTE), hours, minutes);
   1018                        SERIAL_ECHO_START;
   1019                        SERIAL_ECHOLN(time);
   1020                        //lcd_setstatus(time, true);
   1021                        card.printingHasFinished();
   1022                        card.checkautostart(true);
   1023                  }
   1024                  if (serial_char == '#')
   1025                  {
   1026                    macro_enable=true;
   1027                    command_queue[cmd_queue_index_w][serial_count++] = '#';
   1028                    continue;
   1029                    //stop_buffering = true;
   1030                  }
   1031          
   1032                  if (!serial_count) {
   1033                    comment_mode = false; //for new command
   1034                    return; //if empty line
   1035                  }
   1036                  command_queue[cmd_queue_index_w][serial_count] = 0; //terminate string
   1037                  // if (!comment_mode) {
   1038                  curpos[cmd_queue_index_w]=card.sdpos;
   1039                  fromsd[cmd_queue_index_w] = true;
   1040                  commands_in_queue += 1;
   1041                  cmd_queue_index_w = (cmd_queue_index_w + 1) % BUFSIZE;
   1042                  // }
   1043                  comment_mode = false; //for new command
   1044                  serial_count = 0; //clear buffer
   1045                  if (macro_enable)
   1046                  {
   1047                      stop_buffering=true;
   1048                      macro_enable=false;
   1049                  }
   1050                }
   1051                else {
   1052                  if (serial_char == ';') comment_mode = true;
   1053                  if (!comment_mode) command_queue[cmd_queue_index_w][serial_count++] = serial_char;
   1054                }
   1055              }
   1056            #endif // SDSUPPORT
   1057          }
   1058          
   1059          bool code_has_value() {
   1060            int i = 1;
   1061            char c = seen_pointer[i];
   1062            if (c == '-' || c == '+') c = seen_pointer[++i];
   1063            if (c == '.') c = seen_pointer[++i];
   1064            return (c >= '0' && c <= '9');
   1065          }
   1066          
   1067          float code_value() {
   1068            float ret;
   1069            char* e = strchr(seen_pointer, 'E');
   1070            if (e) {
   1071              *e = 0;
   1072              ret = strtod(seen_pointer + 1, NULL);
   1073              *e = 'E';
   1074            }
   1075            else
   1076              ret = strtod(seen_pointer + 1, NULL);
   1077            return ret;
   1078          }
   1079          
   1080          long code_value_long() { return strtol(seen_pointer + 1, NULL, 10); }
   1081          
   1082          int16_t code_value_short() { return (int16_t)strtol(seen_pointer + 1, NULL, 10); }
   1083          
   1084          bool code_seen(char code) {
   1085            seen_pointer = strchr(current_command_args, code);
   1086            return (seen_pointer != NULL); // Return TRUE if the code-letter was found
   1087          }
   1088          
   1089          /*
   1090          #define DEFINE_PGM_READ_ANY(type, reader)       \
   1091            static inline type pgm_read_any(const type *p)  \
   1092            { return pgm_read_##reader##_near(p); }
   1093          
   1094          DEFINE_PGM_READ_ANY(float,       float);
   1095          DEFINE_PGM_READ_ANY(signed char, byte);
   1096          */
   1097          extern int16_t base_max_pos[];
   1098          
   1099          #define XYZ_CONSTS_FROM_CONFIG(type, array, CONFIG) \
   1100            static type array##_P[3] =        \
   1101                { X_##CONFIG, Y_##CONFIG, Z_##CONFIG };     \
   1102            static inline type array(int axis)          \
   1103            { return (array##_P[axis]); }
   1104          
   1105          XYZ_CONSTS_FROM_CONFIG(float, base_min_pos,   MIN_POS);
   1106          //XYZ_CONSTS_FROM_CONFIG(float, base_max_pos,   MAX_POS);
   1107          //XYZ_CONSTS_FROM_CONFIG(float, base_home_pos,  HOME_POS);
   1108          //XYZ_CONSTS_FROM_CONFIG(float, max_length,     MAX_LENGTH);
   1109          XYZ_CONSTS_FROM_CONFIG(float, home_bump_mm,   HOME_BUMP_MM);
   1110          //XYZ_CONSTS_FROM_CONFIG(signed char, home_dir, HOME_DIR);
   1111          float base_home_pos(uint8_t axis)
   1112          {
   1113              float r;
   1114          #if ENABLED(MANUAL_HOME_POSITIONS)
   1115              if (axis==X_AXIS) r=MANUAL_X_HOME_POS;
   1116              else if (axis==Y_AXIS) r=MANUAL_Y_HOME_POS;
   1117              else if (axis==Z_AXIS) r=MANUAL_Z_HOME_POS;
   1118              return r;
   1119          #endif
   1120              if (axis==X_AXIS) r=(X_HOME_DIR < 0 ? X_MIN_POS : X_MAX_POS);
   1121              else if (axis==Y_AXIS) r=(Y_HOME_DIR < 0 ? Y_MIN_POS : Y_MAX_POS);
   1122              else if (axis==Z_AXIS) r=(Z_HOME_DIR < 0 ? Z_MIN_POS : Z_MAX_POS);
   1123              return r;
   1124          }
   1125          
   1126          #if ENABLED(DUAL_X_CARRIAGE)
   1127          
   1128            #define DXC_FULL_CONTROL_MODE 0
   1129            #define DXC_AUTO_PARK_MODE    1
   1130            #define DXC_DUPLICATION_MODE  2
   1131          
   1132            static int dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   1133          
   1134            static float x_home_pos(int extruder) {
   1135              if (extruder == 0)
   1136                return base_home_pos(X_AXIS) + home_offset[X_AXIS];
   1137              else
   1138                // In dual carriage mode the extruder offset provides an override of the
   1139                // second X-carriage offset when homed - otherwise X2_HOME_POS is used.
   1140                // This allow soft recalibration of the second extruder offset position without firmware reflash
   1141                // (through the M218 command).
   1142                return (extruder_offset[X_AXIS][1] > 0) ? extruder_offset[X_AXIS][1] : X2_HOME_POS;
   1143            }
   1144          
   1145            static int x_home_dir(int extruder) {
   1146              return (extruder == 0) ? X_HOME_DIR : X2_HOME_DIR;
   1147            }
   1148          
   1149            static float inactive_extruder_x_pos = X2_MAX_POS; // used in mode 0 & 1
   1150            static bool active_extruder_parked = false; // used in mode 1 & 2
   1151            static float raised_parked_position[NUM_AXIS]; // used in mode 1
   1152            static millis_t delayed_move_time = 0; // used in mode 1
   1153            static float duplicate_extruder_x_offset = DEFAULT_DUPLICATION_X_OFFSET; // used in mode 2
   1154            static float duplicate_extruder_temp_offset = 0; // used in mode 2
   1155            bool extruder_duplication_enabled = false; // used in mode 2
   1156          
   1157          #endif //DUAL_X_CARRIAGE
   1158          
   1159          #if ENABLED(DEBUG_LEVELING_FEATURE)
   1160            void print_xyz(const char* prefix, const float x, const float y, const float z) {
   1161              SERIAL_ECHO(prefix);
   1162              SERIAL_ECHOPAIR(": (", x);
   1163              SERIAL_ECHOPAIR(", ", y);
   1164              SERIAL_ECHOPAIR(", ", z);
   1165              SERIAL_ECHOLNPGM(")");
   1166            }
   1167            void print_xyz(const char* prefix, const float xyz[]) {
   1168              print_xyz(prefix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
   1169            }
   1170          #endif
   1171          
   1172          void set_axis_is_at_home(AxisEnum axis) {
   1173          
   1174            #if ENABLED(DUAL_X_CARRIAGE)
   1175              if (axis == X_AXIS) {
   1176                if (active_extruder != 0) {
   1177                  current_position[X_AXIS] = x_home_pos(active_extruder);
   1178                           min_pos[X_AXIS] = X2_MIN_POS;
   1179                           max_pos[X_AXIS] = max(extruder_offset[X_AXIS][1], X2_MAX_POS);
   1180                  return;
   1181                }
   1182                else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   1183                  float xoff = home_offset[X_AXIS];
   1184                  current_position[X_AXIS] = base_home_pos(X_AXIS) + xoff;
   1185                           min_pos[X_AXIS] = base_min_pos(X_AXIS) + xoff;
   1186                           max_pos[X_AXIS] = min(base_max_pos(X_AXIS) + xoff, max(extruder_offset[X_AXIS][1], X2_MAX_POS) - duplicate_extruder_x_offset);
   1187                  return;
   1188                }
   1189              }
   1190            #endif
   1191          
   1192            #if ENABLED(SCARA)
   1193          
   1194              if (axis == X_AXIS || axis == Y_AXIS) {
   1195          
   1196                float homeposition[3];
   1197                for (int i = 0; i < 3; i++) homeposition[i] = base_home_pos(i);
   1198          
   1199                // SERIAL_ECHOPGM("homeposition[x]= "); SERIAL_ECHO(homeposition[0]);
   1200                // SERIAL_ECHOPGM("homeposition[y]= "); SERIAL_ECHOLN(homeposition[1]);
   1201                // Works out real Homeposition angles using inverse kinematics,
   1202                // and calculates homing offset using forward kinematics
   1203                calculate_delta(homeposition);
   1204          
   1205                // SERIAL_ECHOPGM("base Theta= "); SERIAL_ECHO(delta[X_AXIS]);
   1206                // SERIAL_ECHOPGM(" base Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
   1207          
   1208                for (int i = 0; i < 2; i++) delta[i] -= home_offset[i];
   1209          
   1210                // SERIAL_ECHOPGM("addhome X="); SERIAL_ECHO(home_offset[X_AXIS]);
   1211                // SERIAL_ECHOPGM(" addhome Y="); SERIAL_ECHO(home_offset[Y_AXIS]);
   1212                // SERIAL_ECHOPGM(" addhome Theta="); SERIAL_ECHO(delta[X_AXIS]);
   1213                // SERIAL_ECHOPGM(" addhome Psi+Theta="); SERIAL_ECHOLN(delta[Y_AXIS]);
   1214          
   1215                calculate_SCARA_forward_Transform(delta);
   1216          
   1217                // SERIAL_ECHOPGM("Delta X="); SERIAL_ECHO(delta[X_AXIS]);
   1218                // SERIAL_ECHOPGM(" Delta Y="); SERIAL_ECHOLN(delta[Y_AXIS]);
   1219          
   1220                current_position[axis] = delta[axis];
   1221          
   1222                // SCARA home positions are based on configuration since the actual limits are determined by the
   1223                // inverse kinematic transform.
   1224                min_pos[axis] = base_min_pos(axis); // + (delta[axis] - base_home_pos(axis));
   1225                max_pos[axis] = base_max_pos[axis]; // + (delta[axis] - base_home_pos(axis));
   1226              }
   1227              else
   1228            #endif
   1229            {
   1230              current_position[axis] = base_home_pos(axis) + home_offset[axis];
   1231              min_pos[axis] = base_min_pos(axis) + home_offset[axis];
   1232              max_pos[axis] = base_max_pos[axis] + home_offset[axis];
   1233          
   1234              //#if ENABLED(AUTO_BED_LEVELING_FEATURE) && Z_HOME_DIR < 0
   1235                //if (axis == Z_AXIS) current_position[Z_AXIS] -= zprobe_zoffset;
   1236              //#endif
   1237          
   1238              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1239                if (marlin_debug_flags & DEBUG_LEVELING) {
   1240                  SERIAL_ECHOPAIR("set_axis_is_at_home ", (unsigned long)axis);
   1241                  SERIAL_ECHOPAIR(" > (home_offset[axis]==", home_offset[axis]);
   1242                  print_xyz(") > current_position", current_position);
   1243                }
   1244              #endif
   1245            }
   1246          }
   1247          
   1248          /**
   1249           * Some planner shorthand inline functions
   1250           */
   1251          inline void set_homing_bump_feedrate(AxisEnum axis) {
   1252            const int homing_bump_divisor[] = HOMING_BUMP_DIVISOR;
   1253            int hbd = homing_bump_divisor[axis];
   1254            if (hbd < 1) {
   1255              hbd = 10;
   1256              SERIAL_ECHO_START;
   1257              SERIAL_ECHOLNPGM("Warning: Homing Bump Divisor < 1");
   1258            }
   1259            feedrate = homing_feedrate[axis] / hbd;
   1260          }
   1261          inline void line_to_current_position() {
   1262            plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], feedrate / 60, active_extruder);
   1263          }
   1264          inline void line_to_z(float zPosition) {
   1265            plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS], feedrate / 60, active_extruder);
   1266          }
   1267          inline void line_to_destination(float mm_m) {
   1268            plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], mm_m / 60, active_extruder);
   1269          }
   1270          inline void line_to_destination() {
   1271            line_to_destination(feedrate);
   1272          }
   1273          inline void sync_plan_position() {
   1274            plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   1275          }
   1276          #if ENABLED(DELTA) || ENABLED(SCARA)
   1277            inline void sync_plan_position_delta() {
   1278              calculate_delta(current_position);
   1279              plan_set_position(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], current_position[E_AXIS]);
   1280            }
   1281          #endif
   1282          inline void set_current_to_destination() { memcpy(current_position, destination, sizeof(current_position)); }
   1283          inline void set_destination_to_current() { memcpy(destination, current_position, sizeof(destination)); }
   1284          
   1285          static void setup_for_endstop_move() {
   1286            saved_feedrate = feedrate;
   1287            saved_feedrate_multiplier = feedrate_multiplier;
   1288            feedrate_multiplier = 100;
   1289            refresh_cmd_timeout();
   1290            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1291              if (marlin_debug_flags & DEBUG_LEVELING) {
   1292                SERIAL_ECHOLNPGM("setup_for_endstop_move > enable_endstops(true)");
   1293              }
   1294            #endif
   1295            enable_endstops(true);
   1296          }
   1297          static void clean_up_after_endstop_move() {
   1298              #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
   1299                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1300                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1301                    SERIAL_ECHOLNPGM("clean_up_after_endstop_move > ENDSTOPS_ONLY_FOR_HOMING > enable_endstops(false)");
   1302                  }
   1303                #endif
   1304                enable_endstops(false);
   1305              #endif
   1306              feedrate = saved_feedrate;
   1307              feedrate_multiplier = saved_feedrate_multiplier;
   1308              refresh_cmd_timeout();
   1309            }
   1310          
   1311          #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   1312          
   1313            #if ENABLED(DELTA)
   1314              /**
   1315               * Calculate delta, start a line, and set current_position to destination
   1316               */
   1317              void prepare_move_raw() {
   1318                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1319                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1320                    print_xyz("prepare_move_raw > destination", destination);
   1321                  }
   1322                #endif
   1323                refresh_cmd_timeout();
   1324                calculate_delta(destination);
   1325                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], (feedrate / 60) * (feedrate_multiplier / 100.0), active_extruder);
   1326                set_current_to_destination();
   1327              }
   1328            #endif
   1329          
   1330            #if ENABLED(AUTO_BED_LEVELING_GRID)
   1331          
   1332              #if DISABLED(DELTA)
   1333          
   1334                static void set_bed_level_equation_lsq(double* plane_equation_coefficients) {
   1335                  vector_3 planeNormal = vector_3(-plane_equation_coefficients[0], -plane_equation_coefficients[1], 1);
   1336                  planeNormal.debug("planeNormal");
   1337                  plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   1338                  //bedLevel.debug("bedLevel");
   1339          
   1340                  //plan_bed_level_matrix.debug("bed level before");
   1341                  //vector_3 uncorrected_position = plan_get_position_mm();
   1342                  //uncorrected_position.debug("position before");
   1343          
   1344                  vector_3 corrected_position = plan_get_position();
   1345                  //corrected_position.debug("position after");
   1346                  current_position[X_AXIS] = corrected_position.x;
   1347                  current_position[Y_AXIS] = corrected_position.y;
   1348                  current_position[Z_AXIS] = corrected_position.z;
   1349          
   1350                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1351                    if (marlin_debug_flags & DEBUG_LEVELING) {
   1352                      print_xyz("set_bed_level_equation_lsq > current_position", current_position);
   1353                    }
   1354                  #endif
   1355          
   1356                  sync_plan_position();
   1357                }
   1358          
   1359              #endif // !DELTA
   1360          
   1361            #else // !AUTO_BED_LEVELING_GRID
   1362          
   1363              static void set_bed_level_equation_3pts(float z_at_pt_1, float z_at_pt_2, float z_at_pt_3) {
   1364          
   1365                plan_bed_level_matrix.set_to_identity();
   1366          
   1367                vector_3 pt1 = vector_3(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, z_at_pt_1);
   1368                vector_3 pt2 = vector_3(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, z_at_pt_2);
   1369                vector_3 pt3 = vector_3(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, z_at_pt_3);
   1370                vector_3 planeNormal = vector_3::cross(pt1 - pt2, pt3 - pt2).get_normal();
   1371          
   1372                if (planeNormal.z < 0) {
   1373                  planeNormal.x = -planeNormal.x;
   1374                  planeNormal.y = -planeNormal.y;
   1375                  planeNormal.z = -planeNormal.z;
   1376                }
   1377          
   1378                plan_bed_level_matrix = matrix_3x3::create_look_at(planeNormal);
   1379          
   1380                vector_3 corrected_position = plan_get_position();
   1381                current_position[X_AXIS] = corrected_position.x;
   1382                current_position[Y_AXIS] = corrected_position.y;
   1383                current_position[Z_AXIS] = corrected_position.z;
   1384          
   1385                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1386                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1387                    print_xyz("set_bed_level_equation_3pts > current_position", current_position);
   1388                  }
   1389                #endif
   1390          
   1391                sync_plan_position();
   1392              }
   1393          
   1394            #endif // !AUTO_BED_LEVELING_GRID
   1395          
   1396            static void run_z_probe() {
   1397          
   1398              #if ENABLED(DELTA)
   1399          
   1400                float start_z = current_position[Z_AXIS];
   1401                long start_steps = st_get_position(Z_AXIS);
   1402          
   1403                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1404                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1405                    SERIAL_ECHOLNPGM("run_z_probe (DELTA) 1");
   1406                  }
   1407                #endif
   1408          
   1409                // move down slowly until you find the bed
   1410                feedrate = homing_feedrate[Z_AXIS] / G29_SLOWDOWN;
   1411                destination[Z_AXIS] = -10;
   1412                prepare_move_raw(); // this will also set_current_to_destination
   1413                st_synchronize();
   1414                endstops_hit_on_purpose(); // clear endstop hit flags
   1415          
   1416                // we have to let the planner know where we are right now as it is not where we said to go.
   1417                long stop_steps = st_get_position(Z_AXIS);
   1418                float mm = start_z - float(abs(start_steps - stop_steps)) / axis_steps_per_unit[Z_AXIS];
   1419                current_position[Z_AXIS] = mm;
   1420          
   1421                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1422                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1423                    print_xyz("run_z_probe (DELTA) 2 > current_position", current_position);
   1424                  }
   1425                #endif
   1426          
   1427                sync_plan_position_delta();
   1428          
   1429              #else // !DELTA
   1430          
   1431                //plan_bed_level_matrix.set_to_identity();
   1432                feedrate = homing_feedrate[Z_AXIS];
   1433          
   1434                // Move down until the Z probe (or endstop?) is triggered
   1435                float zPosition = -2;//-(Z_MAX_LENGTH + 10);
   1436                line_to_z(zPosition);
   1437                //st_synchronize();
   1438                while (blocks_queued())
   1439                {
   1440                  IWDG_ReloadCounter();
   1441                  delay(10);//.
   1442                }
   1443          
   1444                // Tell the planner where we ended up - Get this from the stepper handler
   1445                zPosition = st_get_position_mm(Z_AXIS);
   1446                plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS]);
   1447          
   1448                // move up the retract distance
   1449                zPosition += home_bump_mm(Z_AXIS);
   1450                line_to_z(zPosition);
   1451                //st_synchronize();
   1452                while (blocks_queued())
   1453                {
   1454                  IWDG_ReloadCounter();
   1455                  delay(10);//.
   1456                }
   1457          
   1458                endstops_hit_on_purpose(); // clear endstop hit flags
   1459          
   1460                // move back down slowly to find bed
   1461                set_homing_bump_feedrate(Z_AXIS);
   1462          
   1463                zPosition -= home_bump_mm(Z_AXIS) * 2;
   1464                line_to_z(zPosition);
   1465                //st_synchronize();
   1466                while (blocks_queued())
   1467                {
   1468                  IWDG_ReloadCounter();
   1469                  delay(10);//.
   1470                }
   1471          
   1472                endstops_hit_on_purpose(); // clear endstop hit flags
   1473          
   1474                // Get the current stepper position after bumping an endstop
   1475                current_position[Z_AXIS] = st_get_position_mm(Z_AXIS);
   1476                current_position[Z_AXIS] -=8;
   1477                sync_plan_position();
   1478          
   1479                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1480                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1481                    print_xyz("run_z_probe > current_position", current_position);
   1482                  }
   1483                #endif
   1484              #endif // !DELTA
   1485            }
   1486          
   1487            /**
   1488             *  Plan a move to (X, Y, Z) and set the current_position
   1489             *  The final current_position may not be the one that was requested
   1490             */
   1491            static void do_blocking_move_to(float x, float y, float z) {
   1492              float oldFeedRate = feedrate;
   1493          
   1494              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1495                if (marlin_debug_flags & DEBUG_LEVELING) {
   1496                  print_xyz("do_blocking_move_to", x, y, z);
   1497                }
   1498              #endif
   1499          
   1500              #if ENABLED(DELTA)
   1501          
   1502                feedrate = XY_TRAVEL_SPEED;
   1503          
   1504                destination[X_AXIS] = x;
   1505                destination[Y_AXIS] = y;
   1506                destination[Z_AXIS] = z;
   1507                prepare_move_raw(); // this will also set_current_to_destination
   1508                st_synchronize();
   1509          
   1510              #else
   1511                feedrate = homing_feedrate[Z_AXIS];
   1512            
   1513                current_position[Z_AXIS] = z;
   1514                line_to_current_position();
   1515          
   1516                //st_synchronize();
   1517                while (blocks_queued())
   1518                {
   1519                  IWDG_ReloadCounter();
   1520                  delay(10);//.
   1521                }
   1522          
   1523                feedrate = xy_travel_speed;
   1524          
   1525                current_position[X_AXIS] = x;
   1526                current_position[Y_AXIS] = y;
   1527                line_to_current_position();
   1528          
   1529                //st_synchronize();
   1530                while (blocks_queued())
   1531                {
   1532                  IWDG_ReloadCounter();
   1533                  delay(10);//.
   1534                }
   1535              #endif
   1536          
   1537              feedrate = oldFeedRate;
   1538            }
   1539          
   1540            inline void do_blocking_move_to_xy(float x, float y) { do_blocking_move_to(x, y, current_position[Z_AXIS]); }
   1541            inline void do_blocking_move_to_x(float x) { do_blocking_move_to(x, current_position[Y_AXIS], current_position[Z_AXIS]); }
   1542            inline void do_blocking_move_to_z(float z) { do_blocking_move_to(current_position[X_AXIS], current_position[Y_AXIS], z); }
   1543            inline void raise_z_after_probing() { do_blocking_move_to_z(current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING); }
   1544          #if ENABLED(MESH_BED_LEVELING)
   1545            static void clean_up_after_endstop_move() {
   1546              #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
   1547                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1548                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1549                    SERIAL_ECHOLNPGM("clean_up_after_endstop_move > ENDSTOPS_ONLY_FOR_HOMING > enable_endstops(false)");
   1550                  }
   1551                #endif
   1552                enable_endstops(false);
   1553              #endif
   1554              feedrate = saved_feedrate;
   1555              feedrate_multiplier = saved_feedrate_multiplier;
   1556              refresh_cmd_timeout();
   1557            }
   1558          #endif
   1559            static void deploy_z_probe() {
   1560              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1561                if (marlin_debug_flags & DEBUG_LEVELING) {
   1562                  print_xyz("deploy_z_probe > current_position", current_position);
   1563                }
   1564              #endif
   1565          
   1566              #if HAS_SERVO_ENDSTOPS
   1567          
   1568                // Engage Z Servo endstop if enabled
   1569                if (servo_endstop_id[Z_AXIS] >= 0) servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][0]);
   1570          
   1571              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   1572                feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE;
   1573          
   1574                // If endstop is already false, the Z probe is deployed
   1575                #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   1576                  bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   1577                  if (z_probe_endstop)
   1578                #else
   1579                  bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   1580                  if (z_min_endstop)
   1581                #endif
   1582                  {
   1583          
   1584                    // Move to the start position to initiate deployment
   1585                    destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_X;
   1586                    destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Y;
   1587                    destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_1_Z;
   1588                    prepare_move_raw(); // this will also set_current_to_destination
   1589          
   1590                    // Move to engage deployment
   1591                    if (Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_1_FEEDRATE)
   1592                      feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE;
   1593                    if (Z_PROBE_ALLEN_KEY_DEPLOY_2_X != Z_PROBE_ALLEN_KEY_DEPLOY_1_X)
   1594                      destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_X;
   1595                    if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Y != Z_PROBE_ALLEN_KEY_DEPLOY_1_Y)
   1596                      destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Y;
   1597                    if (Z_PROBE_ALLEN_KEY_DEPLOY_2_Z != Z_PROBE_ALLEN_KEY_DEPLOY_1_Z)
   1598                      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_2_Z;
   1599                    prepare_move_raw();
   1600          
   1601                    #ifdef Z_PROBE_ALLEN_KEY_DEPLOY_3_X
   1602                      if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE)
   1603                        feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;
   1604          
   1605                    // Move to trigger deployment
   1606                    if (Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE != Z_PROBE_ALLEN_KEY_DEPLOY_2_FEEDRATE)
   1607                      feedrate = Z_PROBE_ALLEN_KEY_DEPLOY_3_FEEDRATE;
   1608                    if (Z_PROBE_ALLEN_KEY_DEPLOY_3_X != Z_PROBE_ALLEN_KEY_DEPLOY_2_X)
   1609                      destination[X_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_X;
   1610                    if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Y != Z_PROBE_ALLEN_KEY_DEPLOY_2_Y)
   1611                      destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Y;
   1612                    if (Z_PROBE_ALLEN_KEY_DEPLOY_3_Z != Z_PROBE_ALLEN_KEY_DEPLOY_2_Z)
   1613                      destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_DEPLOY_3_Z;
   1614          
   1615                    prepare_move_raw();
   1616          
   1617                  #endif
   1618                }
   1619          
   1620                // Partially Home X,Y for safety
   1621                destination[X_AXIS] = destination[X_AXIS] * 0.75;
   1622                destination[Y_AXIS] = destination[Y_AXIS] * 0.75;
   1623                prepare_move_raw(); // this will also set_current_to_destination
   1624          
   1625                //st_synchronize();
   1626                while (blocks_queued())
   1627                {
   1628                  IWDG_ReloadCounter();
   1629                  delay(10);//.
   1630                }
   1631          
   1632                #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   1633                  z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   1634                  if (z_probe_endstop)
   1635                #else
   1636                  z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   1637                  if (z_min_endstop)
   1638                #endif
   1639                  {
   1640                    if (IsRunning()) {
   1641                      SERIAL_ERROR_START;
   1642                      SERIAL_ERRORLNPGM("Z-Probe failed to engage!");
   1643                      LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   1644                    }
   1645                    Stop();
   1646                  }
   1647          
   1648              #endif // Z_PROBE_ALLEN_KEY
   1649            }
   1650          
   1651            static void stow_z_probe(bool doRaise = true) {
   1652              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1653                if (marlin_debug_flags & DEBUG_LEVELING) {
   1654                  print_xyz("stow_z_probe > current_position", current_position);
   1655                }
   1656              #endif
   1657          
   1658              #if HAS_SERVO_ENDSTOPS
   1659          
   1660                // Retract Z Servo endstop if enabled
   1661                if (servo_endstop_id[Z_AXIS] >= 0) {
   1662          
   1663                  #if Z_RAISE_AFTER_PROBING > 0
   1664                    if (doRaise) {
   1665                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   1666                        if (marlin_debug_flags & DEBUG_LEVELING) {
   1667                          SERIAL_ECHOPAIR("Raise Z (after) by ", (float)Z_RAISE_AFTER_PROBING);
   1668                          SERIAL_EOL;
   1669                          SERIAL_ECHO("> SERVO_ENDSTOPS > raise_z_after_probing()");
   1670                          SERIAL_EOL;
   1671                        }
   1672                      #endif
   1673                      raise_z_after_probing(); // this also updates current_position
   1674                      st_synchronize();
   1675                    }
   1676                  #endif
   1677          
   1678                  // Change the Z servo angle
   1679                  servo[servo_endstop_id[Z_AXIS]].move(servo_endstop_angle[Z_AXIS][1]);
   1680                }
   1681          
   1682              #elif ENABLED(Z_PROBE_ALLEN_KEY)
   1683          
   1684                // Move up for safety
   1685                feedrate = Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE;
   1686          
   1687                #if Z_RAISE_AFTER_PROBING > 0
   1688                  destination[Z_AXIS] = current_position[Z_AXIS] + Z_RAISE_AFTER_PROBING;
   1689                  prepare_move_raw(); // this will also set_current_to_destination
   1690                #endif
   1691          
   1692                // Move to the start position to initiate retraction
   1693                destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_X;
   1694                destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Y;
   1695                destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_1_Z;
   1696                prepare_move_raw();
   1697          
   1698                // Move the nozzle down to push the Z probe into retracted position
   1699                if (Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_1_FEEDRATE)
   1700                  feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;
   1701                if (Z_PROBE_ALLEN_KEY_STOW_2_X != Z_PROBE_ALLEN_KEY_STOW_1_X)
   1702                  destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_X;
   1703                if (Z_PROBE_ALLEN_KEY_STOW_2_Y != Z_PROBE_ALLEN_KEY_STOW_1_Y)
   1704                  destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Y;
   1705                destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_2_Z;
   1706                prepare_move_raw();
   1707          
   1708                // Move up for safety
   1709                if (Z_PROBE_ALLEN_KEY_STOW_3_FEEDRATE != Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE)
   1710                  feedrate = Z_PROBE_ALLEN_KEY_STOW_2_FEEDRATE;
   1711                if (Z_PROBE_ALLEN_KEY_STOW_3_X != Z_PROBE_ALLEN_KEY_STOW_2_X)
   1712                  destination[X_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_X;
   1713                if (Z_PROBE_ALLEN_KEY_STOW_3_Y != Z_PROBE_ALLEN_KEY_STOW_2_Y)
   1714                  destination[Y_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Y;
   1715                destination[Z_AXIS] = Z_PROBE_ALLEN_KEY_STOW_3_Z;
   1716                prepare_move_raw();
   1717          
   1718                // Home XY for safety
   1719                feedrate = homing_feedrate[X_AXIS] / 2;
   1720                destination[X_AXIS] = 0;
   1721                destination[Y_AXIS] = 0;
   1722                prepare_move_raw(); // this will also set_current_to_destination
   1723          
   1724                st_synchronize();
   1725          
   1726                #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   1727                  bool z_probe_endstop = (READ(Z_MIN_PROBE_PIN) != Z_MIN_PROBE_ENDSTOP_INVERTING);
   1728                  if (!z_probe_endstop)
   1729                #else
   1730                  bool z_min_endstop = (READ(Z_MIN_PIN) != Z_MIN_ENDSTOP_INVERTING);
   1731                  if (!z_min_endstop)
   1732                #endif
   1733                  {
   1734                    if (IsRunning()) {
   1735                      SERIAL_ERROR_START;
   1736                      SERIAL_ERRORLNPGM("Z-Probe failed to retract!");
   1737                      LCD_ALERTMESSAGEPGM("Err: ZPROBE");
   1738                    }
   1739                    Stop();
   1740                  }
   1741              #endif // Z_PROBE_ALLEN_KEY
   1742            }
   1743          
   1744            enum ProbeAction {
   1745              ProbeStay          = 0,
   1746              ProbeDeploy        = BIT(0),
   1747              ProbeStow          = BIT(1),
   1748              ProbeDeployAndStow = (ProbeDeploy | ProbeStow)
   1749            };
   1750          
   1751            // Probe bed height at position (x,y), returns the measured z value
   1752            float probe_pt(float x, float y, float z_before, ProbeAction probe_action = ProbeDeployAndStow, int verbose_level = 1) {
   1753              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1754                if (marlin_debug_flags & DEBUG_LEVELING) {
   1755                  SERIAL_ECHOLNPGM("probe_pt >>>");
   1756                  SERIAL_ECHOPAIR("> ProbeAction:", (unsigned long)probe_action);
   1757                  SERIAL_EOL;
   1758                  print_xyz("> current_position", current_position);
   1759                }
   1760              #endif
   1761          
   1762              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1763                if (marlin_debug_flags & DEBUG_LEVELING) {
   1764                  SERIAL_ECHOPAIR("Z Raise to z_before ", z_before);
   1765                  SERIAL_EOL;
   1766                  SERIAL_ECHOPAIR("> do_blocking_move_to_z ", z_before);
   1767                  SERIAL_EOL;
   1768                }
   1769              #endif
   1770          
   1771              // Move Z up to the z_before height, then move the Z probe to the given XY
   1772              do_blocking_move_to_z(z_before); // this also updates current_position
   1773              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1774                if (marlin_debug_flags & DEBUG_LEVELING) {
   1775                  SERIAL_ECHOPAIR("> do_blocking_move_to_xy ", x - X_PROBE_OFFSET_FROM_EXTRUDER);
   1776                  SERIAL_ECHOPAIR(", ", y - Y_PROBE_OFFSET_FROM_EXTRUDER);
   1777                  SERIAL_EOL;
   1778                }
   1779              #endif
   1780          
   1781              do_blocking_move_to_xy(x - X_PROBE_OFFSET_FROM_EXTRUDER, y - Y_PROBE_OFFSET_FROM_EXTRUDER); // this also updates current_position
   1782          
   1783              #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
   1784                if (probe_action & ProbeDeploy) {
   1785                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1786                    if (marlin_debug_flags & DEBUG_LEVELING) {
   1787                      SERIAL_ECHOLNPGM("> ProbeDeploy");
   1788                    }
   1789                  #endif
   1790                  deploy_z_probe();
   1791                }
   1792              #endif
   1793          
   1794              run_z_probe();
   1795              float measured_z = current_position[Z_AXIS];
   1796          
   1797              #if DISABLED(Z_PROBE_SLED) && DISABLED(Z_PROBE_ALLEN_KEY)
   1798                if (probe_action & ProbeStow) {
   1799                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   1800                    if (marlin_debug_flags & DEBUG_LEVELING) {
   1801                      SERIAL_ECHOLNPGM("> ProbeStow (stow_z_probe will do Z Raise)");
   1802                    }
   1803                  #endif
   1804                  stow_z_probe();
   1805                }
   1806              #endif
   1807          
   1808              if (verbose_level > 2) {
   1809                SERIAL_PROTOCOLPGM("Bed X: ");
   1810                SERIAL_PROTOCOL_F(x, 3);
   1811                SERIAL_PROTOCOLPGM(" Y: ");
   1812                SERIAL_PROTOCOL_F(y, 3);
   1813                SERIAL_PROTOCOLPGM(" Z: ");
   1814                SERIAL_PROTOCOL_F(measured_z, 3);
   1815                SERIAL_EOL;
   1816              }
   1817          
   1818              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1819                if (marlin_debug_flags & DEBUG_LEVELING) {
   1820                  SERIAL_ECHOLNPGM("<<< probe_pt");
   1821                }
   1822              #endif
   1823          
   1824              return measured_z;
   1825            }
   1826          
   1827            //#if ENABLED(DELTA)
   1828          
   1829              /**
   1830               * All DELTA leveling in the Marlin uses NONLINEAR_BED_LEVELING
   1831               */
   1832          
   1833              static void extrapolate_one_point(int x, int y, int xdir, int ydir) {
   1834                if (bed_level[x][y] != 0.0) {
   1835                  return;  // Don't overwrite good values.
   1836                }
   1837                float a = 2 * bed_level[x + xdir][y] - bed_level[x + xdir * 2][y]; // Left to right.
   1838                float b = 2 * bed_level[x][y + ydir] - bed_level[x][y + ydir * 2]; // Front to back.
   1839                float c = 2 * bed_level[x + xdir][y + ydir] - bed_level[x + xdir * 2][y + ydir * 2]; // Diagonal.
   1840                float median = c;  // Median is robust (ignores outliers).
   1841                if (a < b) {
   1842                  if (b < c) median = b;
   1843                  if (c < a) median = a;
   1844                }
   1845                else {  // b <= a
   1846                  if (c < b) median = b;
   1847                  if (a < c) median = a;
   1848                }
   1849                bed_level[x][y] = median;
   1850              }
   1851          
   1852              // Fill in the unprobed points (corners of circular print surface)
   1853              // using linear extrapolation, away from the center.
   1854              static void extrapolate_unprobed_bed_level() {
   1855                int half = (AUTO_BED_LEVELING_GRID_POINTS - 1) / 2;
   1856                for (int y = 0; y <= half; y++) {
   1857                  for (int x = 0; x <= half; x++) {
   1858                    if (x + y < 3) continue;
   1859                    extrapolate_one_point(half - x, half - y, x > 1 ? +1 : 0, y > 1 ? +1 : 0);
   1860                    extrapolate_one_point(half + x, half - y, x > 1 ? -1 : 0, y > 1 ? +1 : 0);
   1861                    extrapolate_one_point(half - x, half + y, x > 1 ? +1 : 0, y > 1 ? -1 : 0);
   1862                    extrapolate_one_point(half + x, half + y, x > 1 ? -1 : 0, y > 1 ? -1 : 0);
   1863                  }
   1864                }
   1865                
   1866                /*for (int y=1;y<auto_bed_leveling_grid_points;y++)
   1867                    extrapolate_one_point(0,y,*/
   1868              }
   1869          
   1870              // Print calibration results for plotting or manual frame adjustment.
   1871              static void print_bed_level() {
   1872                //yongzong
   1873                /*if (auto_bed_leveling_grid_points<=3)
   1874                {
   1875                    bed_level[0][0]=bed_level[1][0]+bed_level[0][1]-bed_level[1][1];
   1876                    bed_level[0][2]=bed_level[0][1]+bed_level[1][2]-bed_level[1][1];
   1877                    bed_level[2][0]=bed_level[1][0]+bed_level[2][1]-bed_level[1][1];
   1878                    bed_level[2][2]=bed_level[1][2]+bed_level[2][1]-bed_level[1][1];
   1879                }*/
   1880                for (int y = 0; y < auto_bed_leveling_grid_points; y++) {
   1881                  for (int x = 0; x < auto_bed_leveling_grid_points; x++) {
   1882                    SERIAL_PROTOCOL_F(bed_level[x][y], 3);
   1883                    SERIAL_PROTOCOLCHAR(' ');
   1884                  }
   1885                  SERIAL_EOL;
   1886                }
   1887              }
   1888          
   1889              // Reset calibration results to zero.
   1890              void reset_bed_level() {
   1891                #if ENABLED(DEBUG_LEVELING_FEATURE)
   1892                  if (marlin_debug_flags & DEBUG_LEVELING) {
   1893                    SERIAL_ECHOLNPGM("reset_bed_level");
   1894                  }
   1895                #endif
   1896                for (int y = 0; y < AUTO_BED_LEVELING_GRID_POINTS; y++) {
   1897                  for (int x = 0; x < AUTO_BED_LEVELING_GRID_POINTS; x++) {
   1898                    bed_level[x][y] = 0.0;
   1899                  }
   1900                }
   1901              }
   1902          
   1903            //#endif // DELTA
   1904          
   1905            #if HAS_SERVO_ENDSTOPS && DISABLED(Z_PROBE_SLED)
   1906          
   1907              void raise_z_for_servo() {
   1908                float zpos = current_position[Z_AXIS], z_dest = Z_RAISE_BEFORE_PROBING;
   1909                z_dest += axis_known_position[Z_AXIS] ? zprobe_zoffset : zpos;
   1910                if (zpos < z_dest) do_blocking_move_to_z(z_dest); // also updates current_position
   1911              }
   1912          
   1913            #endif
   1914          
   1915          #endif // AUTO_BED_LEVELING_FEATURE
   1916          
   1917          
   1918          #if ENABLED(Z_PROBE_SLED)
   1919          
   1920            #ifndef SLED_DOCKING_OFFSET
   1921              #define SLED_DOCKING_OFFSET 0
   1922            #endif
   1923          
   1924            /**
   1925             * Method to dock/undock a sled designed by Charles Bell.
   1926             *
   1927             * dock[in]     If true, move to MAX_X and engage the electromagnet
   1928             * offset[in]   The additional distance to move to adjust docking location
   1929             */
   1930            static void dock_sled(bool dock, int offset = 0) {
   1931              #if ENABLED(DEBUG_LEVELING_FEATURE)
   1932                if (marlin_debug_flags & DEBUG_LEVELING) {
   1933                  SERIAL_ECHOPAIR("dock_sled", dock);
   1934                  SERIAL_EOL;
   1935                }
   1936              #endif
   1937              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   1938                LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
   1939                SERIAL_ECHO_START;
   1940                SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
   1941                return;
   1942              }
   1943          
   1944              float oldXpos = current_position[X_AXIS]; // save x position
   1945              if (dock) {
   1946                #if Z_RAISE_AFTER_PROBING > 0
   1947                  raise_z_after_probing(); // raise Z
   1948                #endif
   1949                do_blocking_move_to_x(X_MAX_POS + SLED_DOCKING_OFFSET + offset - 1);  // Dock sled a bit closer to ensure proper capturing
   1950                digitalWrite(SLED_PIN, LOW); // turn off magnet
   1951              }
   1952              else {
   1953                float z_loc = current_position[Z_AXIS];
   1954                if (z_loc < Z_RAISE_BEFORE_PROBING + 5) z_loc = Z_RAISE_BEFORE_PROBING;
   1955                do_blocking_move_to(X_MAX_POS + SLED_DOCKING_OFFSET + offset, current_position[Y_AXIS], z_loc); // this also updates current_position
   1956                digitalWrite(SLED_PIN, HIGH); // turn on magnet
   1957              }
   1958              do_blocking_move_to_x(oldXpos); // return to position before docking
   1959            }
   1960          
   1961          #endif // Z_PROBE_SLED
   1962          
   1963          
   1964          
   1965          /**
   1966           * Home an individual axis
   1967           */
   1968          
   1969          #define HOMEAXIS(LETTER) homeaxis(LETTER##_AXIS)
   1970          
   1971          static void homeaxis(AxisEnum axis) {
   1972            #if ENABLED(DEBUG_LEVELING_FEATURE)
   1973              if (marlin_debug_flags & DEBUG_LEVELING) {
   1974                SERIAL_ECHOPAIR(">>> homeaxis(", (unsigned long)axis);
   1975                SERIAL_CHAR(')');
   1976                SERIAL_EOL;
   1977              }
   1978            #endif
   1979            #define HOMEAXIS_DO(LETTER) \
   1980              ((LETTER##_MIN_PIN > -1 && LETTER##_HOME_DIR==-1) || (LETTER##_MAX_PIN > -1 && LETTER##_HOME_DIR==1))
   1981          
   1982              if (axis == X_AXIS ? HOMEAXIS_DO(X) : axis == Y_AXIS ? HOMEAXIS_DO(Y) : axis == Z_AXIS ? HOMEAXIS_DO(Z) : 0)
   1983            //if (axis == X_AXIS ? ((X_MIN_PIN > -1 && X_HOME_DIR==-1) || (X_MAX_PIN > -1 && X_HOME_DIR==1)) : axis == Y_AXIS ? ((Y_MIN_PIN > -1 && Y_HOME_DIR==-1) || (Y_MAX_PIN > -1 && Y_HOME_DIR==1)) : axis == Z_AXIS ? ((Z_MIN_PIN > -1 && Z_HOME_DIR==-1) || (Z_MAX_PIN > -1 && Z_HOME_DIR==1)) : 0) {
   1984              {
   1985                /*
   1986              int axis_home_dir =
   1987                #if ENABLED(DUAL_X_CARRIAGE)
   1988                  (axis == X_AXIS) ? x_home_dir(active_extruder) :
   1989                #endif
   1990                home_dir(axis);*/
   1991              int axis_home_dir;
   1992              if (axis==X_AXIS) axis_home_dir=X_HOME_DIR;
   1993              else if (axis==Y_AXIS) axis_home_dir=Y_HOME_DIR;
   1994              else if (axis==Z_AXIS) axis_home_dir=Z_HOME_DIR;
   1995          
   1996              // Set the axis position as setup for the move
   1997              current_position[axis] = 0;
   1998              sync_plan_position();
   1999          
   2000              #if ENABLED(Z_PROBE_SLED)
   2001                // Get Probe
   2002                if (axis == Z_AXIS) {
   2003                  if (axis_home_dir < 0) dock_sled(false);
   2004                }
   2005              #endif
   2006          
   2007              #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)
   2008          
   2009                // Deploy a Z probe if there is one, and homing towards the bed
   2010                if (axis == Z_AXIS) {
   2011                  if (axis_home_dir < 0) deploy_z_probe();
   2012                }
   2013          
   2014              #endif
   2015          
   2016              #if HAS_SERVO_ENDSTOPS
   2017                // Engage Servo endstop if enabled
   2018                if (axis != Z_AXIS && servo_endstop_id[axis] >= 0)
   2019                  servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][0]);
   2020              #endif
   2021          
   2022              // Set a flag for Z motor locking
   2023              #if ENABLED(Z_DUAL_ENDSTOPS)
   2024                if (axis == Z_AXIS) In_Homing_Process(true);
   2025              #endif
   2026          
   2027              // Move towards the endstop until an endstop is triggered
   2028              for (unsigned char i=0;i<3;i++) destination[i]=current_position[i];
   2029              if (axis==X_AXIS) destination[axis] = 1.5 * X_MAX_LENGTH * axis_home_dir;
   2030              else if (axis==Y_AXIS) destination[axis] = 1.5 * Y_MAX_LENGTH * axis_home_dir;
   2031              else if (axis==Z_AXIS) destination[axis] = 1.5 * Z_MAX_LENGTH * axis_home_dir;
   2032              //destination[axis] = 1.5 * max_length(axis) * axis_home_dir;
   2033              feedrate = homing_feedrate[axis];
   2034              line_to_destination();
   2035              st_synchronize();
   2036          
   2037              // Set the axis position as setup for the move
   2038              current_position[axis] = 0;
   2039              sync_plan_position();
   2040          
   2041              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2042                if (marlin_debug_flags & DEBUG_LEVELING) {
   2043                  SERIAL_ECHOLNPGM("> enable_endstops(false)");
   2044                }
   2045              #endif
   2046              enable_endstops(false); // Disable endstops while moving away
   2047          
   2048              // Move away from the endstop by the axis HOME_BUMP_MM
   2049              destination[axis] = -home_bump_mm(axis) * axis_home_dir;
   2050              line_to_destination();
   2051              st_synchronize();
   2052          
   2053              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2054                if (marlin_debug_flags & DEBUG_LEVELING) {
   2055                  SERIAL_ECHOLNPGM("> enable_endstops(true)");
   2056                }
   2057              #endif
   2058              enable_endstops(true); // Enable endstops for next homing move
   2059          
   2060              // Slow down the feedrate for the next move
   2061              set_homing_bump_feedrate(axis);
   2062          
   2063              // Move slowly towards the endstop until triggered
   2064              destination[axis] = 2 * home_bump_mm(axis) * axis_home_dir;
   2065              line_to_destination();
   2066              st_synchronize();
   2067          
   2068              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2069                if (marlin_debug_flags & DEBUG_LEVELING) {
   2070                  print_xyz("> TRIGGER ENDSTOP > current_position", current_position);
   2071                }
   2072              #endif
   2073          
   2074              #if ENABLED(Z_DUAL_ENDSTOPS)
   2075                if (axis == Z_AXIS) {
   2076                  float adj = fabs(z_endstop_adj);
   2077                  bool lockZ1;
   2078                  if (axis_home_dir > 0) {
   2079                    adj = -adj;
   2080                    lockZ1 = (z_endstop_adj > 0);
   2081                  }
   2082                  else
   2083                    lockZ1 = (z_endstop_adj < 0);
   2084          
   2085                  if (lockZ1) Lock_z_motor(true); else Lock_z2_motor(true);
   2086                  sync_plan_position();
   2087          
   2088                  // Move to the adjusted endstop height
   2089                  feedrate = homing_feedrate[axis];
   2090                  destination[Z_AXIS] = adj;
   2091                  line_to_destination();
   2092                  st_synchronize();
   2093          
   2094                  if (lockZ1) Lock_z_motor(false); else Lock_z2_motor(false);
   2095                  In_Homing_Process(false);
   2096                } // Z_AXIS
   2097              #endif
   2098          
   2099              #if ENABLED(DELTA)
   2100                // retrace by the amount specified in endstop_adj
   2101                if (endstop_adj[axis] * axis_home_dir < 0) {
   2102                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2103                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2104                      SERIAL_ECHOLNPGM("> enable_endstops(false)");
   2105                    }
   2106                  #endif
   2107                  enable_endstops(false); // Disable endstops while moving away
   2108                  sync_plan_position();
   2109                  destination[axis] = endstop_adj[axis];
   2110                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2111                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2112                      SERIAL_ECHOPAIR("> endstop_adj = ", endstop_adj[axis]);
   2113                      print_xyz(" > destination", destination);
   2114                    }
   2115                  #endif
   2116                  line_to_destination();
   2117                  st_synchronize();
   2118                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2119                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2120                      SERIAL_ECHOLNPGM("> enable_endstops(true)");
   2121                    }
   2122                  #endif
   2123                  enable_endstops(true); // Enable endstops for next homing move
   2124                }
   2125                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2126                  else {
   2127                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2128                      SERIAL_ECHOPAIR("> endstop_adj * axis_home_dir = ", endstop_adj[axis] * axis_home_dir);
   2129                      SERIAL_EOL;
   2130                    }
   2131                  }
   2132                #endif
   2133              #endif
   2134          
   2135              // Set the axis position to its home position (plus home offsets)
   2136              set_axis_is_at_home(axis);
   2137              sync_plan_position();
   2138          
   2139              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2140                if (marlin_debug_flags & DEBUG_LEVELING) {
   2141                  print_xyz("> AFTER set_axis_is_at_home > current_position", current_position);
   2142                }
   2143              #endif
   2144          
   2145              destination[axis] = current_position[axis];
   2146              feedrate = 0.0;
   2147              endstops_hit_on_purpose(); // clear endstop hit flags
   2148              axis_known_position[axis] = true;
   2149          
   2150              #if ENABLED(Z_PROBE_SLED)
   2151                // bring Z probe back
   2152                if (axis == Z_AXIS) {
   2153                  if (axis_home_dir < 0) dock_sled(true);
   2154                }
   2155              #endif
   2156          
   2157              #if SERVO_LEVELING && DISABLED(Z_PROBE_SLED)
   2158          
   2159                // Deploy a Z probe if there is one, and homing towards the bed
   2160                if (axis == Z_AXIS) {
   2161                  if (axis_home_dir < 0) {
   2162                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   2163                      if (marlin_debug_flags & DEBUG_LEVELING) {
   2164                        SERIAL_ECHOLNPGM("> SERVO_LEVELING > stow_z_probe");
   2165                      }
   2166                    #endif
   2167                    stow_z_probe();
   2168                  }
   2169                }
   2170                else
   2171          
   2172              #endif
   2173          
   2174              {
   2175                #if HAS_SERVO_ENDSTOPS
   2176                  // Retract Servo endstop if enabled
   2177                  if (servo_endstop_id[axis] >= 0) {
   2178                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   2179                      if (marlin_debug_flags & DEBUG_LEVELING) {
   2180                        SERIAL_ECHOLNPGM("> SERVO_ENDSTOPS > Stow with servo.move()");
   2181                      }
   2182                    #endif
   2183                    servo[servo_endstop_id[axis]].move(servo_endstop_angle[axis][1]);
   2184                  }
   2185                #endif
   2186              }
   2187          
   2188            }
   2189          
   2190            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2191              if (marlin_debug_flags & DEBUG_LEVELING) {
   2192                SERIAL_ECHOPAIR("<<< homeaxis(", (unsigned long)axis);
   2193                SERIAL_CHAR(')');
   2194                SERIAL_EOL;
   2195              }
   2196            #endif
   2197          }
   2198          
   2199          #if ENABLED(FWRETRACT)
   2200          
   2201            void retract(bool retracting, bool swapping = false) {
   2202          
   2203              if (retracting == retracted[active_extruder]) return;
   2204          
   2205              float oldFeedrate = feedrate;
   2206          
   2207              set_destination_to_current();
   2208          
   2209              if (retracting) {
   2210          
   2211                feedrate = retract_feedrate * 60;
   2212                current_position[E_AXIS] += (swapping ? retract_length_swap : retract_length) / volumetric_multiplier[active_extruder];
   2213                plan_set_e_position(current_position[E_AXIS]);
   2214                prepare_move();
   2215          
   2216                if (retract_zlift > 0.01) {
   2217                  current_position[Z_AXIS] -= retract_zlift;
   2218                  #if ENABLED(DELTA)
   2219                    sync_plan_position_delta();
   2220                  #else
   2221                    sync_plan_position();
   2222                  #endif
   2223                  prepare_move();
   2224                }
   2225              }
   2226              else {
   2227          
   2228                if (retract_zlift > 0.01) {
   2229                  current_position[Z_AXIS] += retract_zlift;
   2230                  #if ENABLED(DELTA)
   2231                    sync_plan_position_delta();
   2232                  #else
   2233                    sync_plan_position();
   2234                  #endif
   2235                  //prepare_move();
   2236                }
   2237          
   2238                feedrate = retract_recover_feedrate * 60;
   2239                float move_e = swapping ? retract_length_swap + retract_recover_length_swap : retract_length + retract_recover_length;
   2240                current_position[E_AXIS] -= move_e / volumetric_multiplier[active_extruder];
   2241                plan_set_e_position(current_position[E_AXIS]);
   2242                prepare_move();
   2243              }
   2244          
   2245              feedrate = oldFeedrate;
   2246              retracted[active_extruder] = retracting;
   2247          
   2248            } // retract()
   2249          
   2250          #endif // FWRETRACT
   2251          
   2252          /**
   2253           *
   2254           * G-Code Handler functions
   2255           *
   2256           */
   2257          
   2258          /**
   2259           * Set XYZE destination and feedrate from the current GCode command
   2260           *
   2261           *  - Set destination from included axis codes
   2262           *  - Set to current for missing axis codes
   2263           *  - Set the feedrate, if included
   2264           */
   2265          void gcode_get_destination() {
   2266            for (int i = 0; i < NUM_AXIS; i++) {
   2267              if (code_seen(axis_codes[i]))
   2268                destination[i] = code_value() + (axis_relative_modes[i] || relative_mode ? current_position[i] : 0);
   2269              else
   2270                destination[i] = current_position[i];
   2271            }
   2272            if (code_seen('F')) {
   2273              float next_feedrate = code_value();
   2274              if (next_feedrate > 0.0) feedrate = next_feedrate;
   2275            }
   2276          }
   2277          
   2278          void unknown_command_error() {
   2279            SERIAL_ECHO_START;
   2280            SERIAL_ECHOPGM(MSG_UNKNOWN_COMMAND);
   2281            SERIAL_ECHO(current_command);
   2282            SERIAL_ECHOPGM("\"\n");
   2283          }
   2284          
   2285          /**
   2286           * G0, G1: Coordinated movement of X Y Z E axes
   2287           */
   2288          inline void gcode_G0_G1() {
   2289            if (IsRunning()) {
   2290              gcode_get_destination(); // For X Y Z E F
   2291          
   2292              #if ENABLED(FWRETRACT)
   2293          
   2294                if (autoretract_enabled && !(code_seen('X') || code_seen('Y') || code_seen('Z')) && code_seen('E')) {
   2295                  float echange = destination[E_AXIS] - current_position[E_AXIS];
   2296                  // Is this move an attempt to retract or recover?
   2297                  if ((echange < -MIN_RETRACT && !retracted[active_extruder]) || (echange > MIN_RETRACT && retracted[active_extruder])) {
   2298                    current_position[E_AXIS] = destination[E_AXIS]; // hide the slicer-generated retract/recover from calculations
   2299                    plan_set_e_position(current_position[E_AXIS]);  // AND from the planner
   2300                    retract(!retracted[active_extruder]);
   2301                    return;
   2302                  }
   2303                }
   2304          
   2305              #endif //FWRETRACT
   2306          
   2307              prepare_move();
   2308            }
   2309          }
   2310          
   2311          /**
   2312           * G2: Clockwise Arc
   2313           * G3: Counterclockwise Arc
   2314           */
   2315          inline void gcode_G2_G3(bool clockwise) {
   2316            if (IsRunning()) {
   2317          
   2318              #if ENABLED(SF_ARC_FIX)
   2319                bool relative_mode_backup = relative_mode;
   2320                relative_mode = true;
   2321              #endif
   2322          
   2323              gcode_get_destination();
   2324          
   2325              #if ENABLED(SF_ARC_FIX)
   2326                relative_mode = relative_mode_backup;
   2327              #endif
   2328          
   2329              // Center of arc as offset from current_position
   2330              float arc_offset[2] = {
   2331                code_seen('I') ? code_value() : 0,
   2332                code_seen('J') ? code_value() : 0
   2333              };
   2334          
   2335              // Send an arc to the planner
   2336              plan_arc(destination, arc_offset, clockwise);
   2337          
   2338              refresh_cmd_timeout();
   2339            }
   2340          }
   2341          
   2342          /**
   2343           * G4: Dwell S<seconds> or P<milliseconds>
   2344           */
   2345          inline void gcode_G4() {
   2346            millis_t codenum = 0;
   2347          
   2348            if (code_seen('P')) codenum = code_value_long(); // milliseconds to wait
   2349            if (code_seen('S')) codenum = code_value() * 1000; // seconds to wait
   2350          
   2351            st_synchronize();
   2352            refresh_cmd_timeout();
   2353            codenum += previous_cmd_ms;  // keep track of when we started waiting
   2354          
   2355            //if (!lcd_hasstatus()) LCD_MESSAGEPGM(MSG_DWELL);
   2356          
   2357            while (millis() < codenum) idle();
   2358          }
   2359          
   2360          #if ENABLED(FWRETRACT)
   2361          
   2362            /**
   2363             * G10 - Retract filament according to settings of M207
   2364             * G11 - Recover filament according to settings of M208
   2365             */
   2366            inline void gcode_G10_G11(bool doRetract=false) {
   2367              if (EXTRUDERS>1)
   2368              {
   2369                if (doRetract) {
   2370                  retracted_swap[active_extruder] = (code_seen('S') && code_value_short() == 1); // checks for swap retract argument
   2371                }
   2372                retract(doRetract, retracted_swap[active_extruder]);
   2373              }
   2374              else retract(doRetract);
   2375          
   2376          /*    #if EXTRUDERS > 1
   2377                if (doRetract) {
   2378                  retracted_swap[active_extruder] = (code_seen('S') && code_value_short() == 1); // checks for swap retract argument
   2379                }
   2380              #endif
   2381              retract(doRetract
   2382               #if EXTRUDERS > 1
   2383                , retracted_swap[active_extruder]
   2384               #endif
   2385              );*/
   2386            }
   2387          
   2388          #endif //FWRETRACT
   2389          
   2390          #if 0
   2391          void _home()
   2392          {
   2393              bool  homeX = true,
   2394                  homeY = true,
   2395                  homeZ = true;
   2396          
   2397              home_all_axis = true;
   2398          
   2399              homing=true;
   2400          
   2401            // Wait for planner moves to finish!
   2402            st_synchronize();
   2403          
   2404            // For auto bed leveling, clear the level matrix
   2405            #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   2406              plan_bed_level_matrix.set_to_identity();
   2407              #if 1//ENABLED(DELTA)
   2408                reset_bed_level();
   2409              #endif
   2410            #endif
   2411          
   2412            // For manual bed leveling deactivate the matrix temporarily
   2413            #if ENABLED(MESH_BED_LEVELING)
   2414              uint8_t mbl_was_active = mbl.active;
   2415              mbl.active = 0;
   2416            #endif
   2417          
   2418            setup_for_endstop_move();
   2419          
   2420            set_destination_to_current();
   2421          
   2422            feedrate = 0.0;
   2423          
   2424            #if ENABLED(DELTA)
   2425              // A delta can only safely home all axis at the same time
   2426              // all axis have to home at the same time
   2427          
   2428              // Pretend the current position is 0,0,0
   2429              for (int i = X_AXIS; i <= Z_AXIS; i++) current_position[i] = 0;
   2430              sync_plan_position();
   2431          
   2432              // Move all carriages up together until the first endstop is hit.
   2433              for (int i = X_AXIS; i <= Z_AXIS; i++) destination[i] = 3 * Z_MAX_LENGTH;
   2434              feedrate = G28_FEEDRATE * homing_feedrate[X_AXIS];
   2435              line_to_destination();
   2436              st_synchronize();
   2437              endstops_hit_on_purpose(); // clear endstop hit flags
   2438          
   2439              // Destination reached
   2440              for (int i = X_AXIS; i <= Z_AXIS; i++) current_position[i] = destination[i];
   2441          
   2442              // take care of back off and rehome now we are all at the top
   2443              HOMEAXIS(X);
   2444              HOMEAXIS(Y);
   2445              HOMEAXIS(Z);
   2446          
   2447              sync_plan_position_delta();
   2448          
   2449              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2450                if (marlin_debug_flags & DEBUG_LEVELING) {
   2451                  print_xyz("(DELTA) > current_position", current_position);
   2452                }
   2453              #endif
   2454          
   2455            #else // NOT DELTA
   2456          
   2457              /*bool  homeX = code_seen(axis_codes[X_AXIS]),
   2458                    homeY = code_seen(axis_codes[Y_AXIS]),
   2459                    homeZ = code_seen(axis_codes[Z_AXIS]);
   2460          
   2461              home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);*/
   2462          
   2463              if (home_all_axis || homeZ) {
   2464          
   2465                #if Z_HOME_DIR > 0  // If homing away from BED do Z first
   2466          
   2467                  HOMEAXIS(Z);
   2468                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2469                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2470                      print_xyz("> HOMEAXIS(Z) > current_position", current_position);
   2471                    }
   2472                  #endif
   2473          
   2474                #elif DISABLED(Z_SAFE_HOMING) && defined(Z_RAISE_BEFORE_HOMING) && Z_RAISE_BEFORE_HOMING > 0
   2475          
   2476                  // Raise Z before homing any other axes
   2477                  // (Does this need to be "negative home direction?" Why not just use Z_RAISE_BEFORE_HOMING?)
   2478                  destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * Z_HOME_DIR;
   2479                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2480                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2481                      SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   2482                      SERIAL_EOL;
   2483                      print_xyz("> (home_all_axis || homeZ) > destination", destination);
   2484                    }
   2485                  #endif
   2486                  feedrate = max_feedrate[Z_AXIS] * 60;
   2487                  line_to_destination();
   2488                  st_synchronize();
   2489          
   2490                #endif
   2491          
   2492              } // home_all_axis || homeZ
   2493          
   2494              #if ENABLED(QUICK_HOME)
   2495          
   2496                if (home_all_axis || (homeX && homeY)) {  // First diagonal move
   2497          
   2498                  current_position[X_AXIS] = current_position[Y_AXIS] = 0;
   2499          
   2500                  #if ENABLED(DUAL_X_CARRIAGE)
   2501                    int x_axis_home_dir = x_home_dir(active_extruder);
   2502                    extruder_duplication_enabled = false;
   2503                  #else
   2504                    //int x_axis_home_dir = home_dir(X_AXIS);
   2505                    int x_axis_home_dir = X_HOME_DIR;
   2506                  #endif
   2507          
   2508                  sync_plan_position();
   2509          
   2510                  float mlx = X_MAX_LENGTH, mly = Y_MAX_LENGTH,
   2511                        mlratio = mlx > mly ? mly / mlx : mlx / mly;
   2512          
   2513                  destination[X_AXIS] = 1.5 * mlx * x_axis_home_dir;
   2514                  destination[Y_AXIS] = 1.5 * mly * Y_HOME_DIR;
   2515                  feedrate = min(homing_feedrate[X_AXIS], homing_feedrate[Y_AXIS]) * sqrt(mlratio * mlratio + 1);
   2516                  line_to_destination();
   2517                  st_synchronize();
   2518          
   2519                  set_axis_is_at_home(X_AXIS);
   2520                  set_axis_is_at_home(Y_AXIS);
   2521                  sync_plan_position();
   2522          
   2523                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2524                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2525                      print_xyz("> QUICK_HOME > current_position 1", current_position);
   2526                    }
   2527                  #endif
   2528          
   2529                  destination[X_AXIS] = current_position[X_AXIS];
   2530                  destination[Y_AXIS] = current_position[Y_AXIS];
   2531                  line_to_destination();
   2532                  feedrate = 0.0;
   2533                  st_synchronize();
   2534                  endstops_hit_on_purpose(); // clear endstop hit flags
   2535          
   2536                  current_position[X_AXIS] = destination[X_AXIS];
   2537                  current_position[Y_AXIS] = destination[Y_AXIS];
   2538                  #if DISABLED(SCARA)
   2539                    current_position[Z_AXIS] = destination[Z_AXIS];
   2540                  #endif
   2541          
   2542                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2543                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2544                      print_xyz("> QUICK_HOME > current_position 2", current_position);
   2545                    }
   2546                  #endif
   2547                }
   2548          
   2549              #endif // QUICK_HOME
   2550          
   2551              #if ENABLED(HOME_Y_BEFORE_X)
   2552                // Home Y
   2553                if (home_all_axis || homeY) HOMEAXIS(Y);
   2554              #endif
   2555          
   2556              // Home X
   2557              if (home_all_axis || homeX) {
   2558                #if ENABLED(DUAL_X_CARRIAGE)
   2559                  int tmp_extruder = active_extruder;
   2560                  extruder_duplication_enabled = false;
   2561                  active_extruder = !active_extruder;
   2562                  HOMEAXIS(X);
   2563                  inactive_extruder_x_pos = current_position[X_AXIS];
   2564                  active_extruder = tmp_extruder;
   2565                  HOMEAXIS(X);
   2566                  // reset state used by the different modes
   2567                  memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
   2568                  delayed_move_time = 0;
   2569                  active_extruder_parked = true;
   2570                #else
   2571                  HOMEAXIS(X);
   2572                #endif
   2573                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2574                  if (marlin_debug_flags & DEBUG_LEVELING) {
   2575                    print_xyz("> homeX", current_position);
   2576                  }
   2577                #endif
   2578              }
   2579          
   2580              #if DISABLED(HOME_Y_BEFORE_X)
   2581                // Home Y
   2582                if (home_all_axis || homeY) {
   2583                  HOMEAXIS(Y);
   2584                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2585                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2586                      print_xyz("> homeY", current_position);
   2587                    }
   2588                  #endif
   2589                }
   2590              #endif
   2591          
   2592              // Home Z last if homing towards the bed
   2593              #if Z_HOME_DIR < 0
   2594          
   2595                if (home_all_axis || homeZ) {
   2596          
   2597                  #if ENABLED(Z_SAFE_HOMING)
   2598          
   2599                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   2600                      if (marlin_debug_flags & DEBUG_LEVELING) {
   2601                        SERIAL_ECHOLNPGM("> Z_SAFE_HOMING >>>");
   2602                      }
   2603                    #endif
   2604          
   2605                    if (home_all_axis) {
   2606          
   2607                      current_position[Z_AXIS] = 0;
   2608                      sync_plan_position();
   2609          
   2610                      //
   2611                      // Set the Z probe (or just the nozzle) destination to the safe homing point
   2612                      //
   2613                      // NOTE: If current_position[X_AXIS] or current_position[Y_AXIS] were set above
   2614                      // then this may not work as expected.
   2615                      destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
   2616                      destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
   2617                      destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);    // Set destination away from bed
   2618                      feedrate = XY_TRAVEL_SPEED;
   2619          
   2620                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   2621                        if (marlin_debug_flags & DEBUG_LEVELING) {
   2622                          SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   2623                          SERIAL_EOL;
   2624                          print_xyz("> home_all_axis > current_position", current_position);
   2625                          print_xyz("> home_all_axis > destination", destination);
   2626                        }
   2627                      #endif
   2628          
   2629                      // This could potentially move X, Y, Z all together
   2630                      line_to_destination();
   2631                      st_synchronize();
   2632          
   2633                      // Set current X, Y is the Z_SAFE_HOMING_POINT minus PROBE_OFFSET_FROM_EXTRUDER
   2634                      current_position[X_AXIS] = destination[X_AXIS];
   2635                      current_position[Y_AXIS] = destination[Y_AXIS];
   2636          
   2637                      // Home the Z axis
   2638                      HOMEAXIS(Z);
   2639                    }
   2640          
   2641                    else if (homeZ) { // Don't need to Home Z twice
   2642          
   2643                      // Let's see if X and Y are homed
   2644                      if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) {
   2645          
   2646                        // Make sure the Z probe is within the physical limits
   2647                        // NOTE: This doesn't necessarily ensure the Z probe is also within the bed!
   2648                        float cpx = current_position[X_AXIS], cpy = current_position[Y_AXIS];
   2649                        if (   cpx >= X_MIN_POS - X_PROBE_OFFSET_FROM_EXTRUDER
   2650                            && cpx <= X_MAX_POS - X_PROBE_OFFSET_FROM_EXTRUDER
   2651                            && cpy >= Y_MIN_POS - Y_PROBE_OFFSET_FROM_EXTRUDER
   2652                            && cpy <= Y_MAX_POS - Y_PROBE_OFFSET_FROM_EXTRUDER) {
   2653                          // Set the plan current position to X, Y, 0
   2654                          current_position[Z_AXIS] = 0;
   2655                          plan_set_position(cpx, cpy, 0, current_position[E_AXIS]); // = sync_plan_position
   2656          
   2657                          // Set Z destination away from bed and raise the axis
   2658                          // NOTE: This should always just be Z_RAISE_BEFORE_HOMING unless...???
   2659                          destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);
   2660                          feedrate = max_feedrate[Z_AXIS] * 60;  // feedrate (mm/m) = max_feedrate (mm/s)
   2661          
   2662                          #if ENABLED(DEBUG_LEVELING_FEATURE)
   2663                            if (marlin_debug_flags & DEBUG_LEVELING) {
   2664                              SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   2665                              SERIAL_EOL;
   2666                              print_xyz("> homeZ > current_position", current_position);
   2667                              print_xyz("> homeZ > destination", destination);
   2668                            }
   2669                          #endif
   2670          
   2671                          line_to_destination();
   2672                          st_synchronize();
   2673          
   2674                          // Home the Z axis
   2675                          HOMEAXIS(Z);
   2676                        }
   2677                        else {
   2678                          LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   2679                          SERIAL_ECHO_START;
   2680                          SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   2681                        }
   2682                      }
   2683                      else {
   2684                        LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
   2685                        SERIAL_ECHO_START;
   2686                        SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
   2687                      }
   2688          
   2689                    } // !home_all_axes && homeZ
   2690          
   2691                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   2692                      if (marlin_debug_flags & DEBUG_LEVELING) {
   2693                        SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   2694                      }
   2695                    #endif
   2696          
   2697                  #else // !Z_SAFE_HOMING
   2698          
   2699                    HOMEAXIS(Z);
   2700          
   2701                  #endif // !Z_SAFE_HOMING
   2702          
   2703                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2704                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2705                      print_xyz("> (home_all_axis || homeZ) > final", current_position);
   2706                    }
   2707                  #endif
   2708          
   2709                } // home_all_axis || homeZ
   2710          
   2711              #endif // Z_HOME_DIR < 0
   2712          
   2713              sync_plan_position();
   2714          
   2715            #endif // else DELTA
   2716          
   2717            #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
   2718              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2719                if (marlin_debug_flags & DEBUG_LEVELING) {
   2720                  SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING enable_endstops(false)");
   2721                }
   2722              #endif
   2723              enable_endstops(false);
   2724            #endif
   2725          
   2726          
   2727            feedrate = saved_feedrate;
   2728            feedrate_multiplier = saved_feedrate_multiplier;
   2729            refresh_cmd_timeout();
   2730            endstops_hit_on_purpose(); // clear endstop hit flags
   2731          
   2732            homing=false;
   2733          }
   2734          #endif
   2735          
   2736          /**
   2737           * G28: Home all axes according to settings
   2738           *
   2739           * Parameters
   2740           *
   2741           *  None  Home to all axes with no parameters.
   2742           *        With QUICK_HOME enabled XY will home together, then Z.
   2743           *
   2744           * Cartesian parameters
   2745           *
   2746           *  X   Home to the X endstop
   2747           *  Y   Home to the Y endstop
   2748           *  Z   Home to the Z endstop
   2749           *
   2750           */
   2751          bool  homeX,homeY,homeZ;
   2752          float recal_probe_offset;
   2753          inline void gcode_G28() {
   2754              /*bool  homeX = code_seen(axis_codes[X_AXIS]),
   2755                  homeY = code_seen(axis_codes[Y_AXIS]),
   2756                  homeZ = code_seen(axis_codes[Z_AXIS]);*/
   2757              homeX = code_seen(axis_codes[X_AXIS]);
   2758              homeY = code_seen(axis_codes[Y_AXIS]);
   2759              homeZ = code_seen(axis_codes[Z_AXIS]);
   2760              //if (homeZ) {homeX=true;homeY=true;}
   2761              home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);
   2762          
   2763              homing=true;
   2764              extern void StartBuild();//yongzong
   2765          
   2766              bool enable_recal_probe = false;
   2767              if (code_seen('A'))
   2768              {
   2769                  enable_recal_probe=true;
   2770                  recal_probe_offset = code_value();
   2771              }
   2772              //if ((!GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_4)) && (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_15))) enable_recal_probe=true;
   2773              if (!homeX && !homeY && !homeZ)
   2774              {
   2775                  buffer_status=true;
   2776                  StartBuild();
   2777              }
   2778          
   2779            #if ENABLED(DEBUG_LEVELING_FEATURE)
   2780              if (marlin_debug_flags & DEBUG_LEVELING) {
   2781                SERIAL_ECHOLNPGM("gcode_G28 >>>");
   2782              }
   2783            #endif
   2784          
   2785            // Wait for planner moves to finish!
   2786            st_synchronize();
   2787          
   2788            // For auto bed leveling, clear the level matrix
   2789            #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   2790              plan_bed_level_matrix.set_to_identity();
   2791              #if ENABLED(DELTA)
   2792                reset_bed_level();
   2793              #endif
   2794            #endif
   2795          
   2796            // For manual bed leveling deactivate the matrix temporarily
   2797            #if ENABLED(MESH_BED_LEVELING)
   2798              uint8_t mbl_was_active = mbl.active;
   2799              mbl.active = 0;
   2800            #endif
   2801          
   2802            setup_for_endstop_move();
   2803          
   2804            set_destination_to_current();
   2805          
   2806            feedrate = 0.0;
   2807          
   2808            #if ENABLED(DELTA)
   2809              // A delta can only safely home all axis at the same time
   2810              // all axis have to home at the same time
   2811          
   2812              // Pretend the current position is 0,0,0
   2813              for (int i = X_AXIS; i <= Z_AXIS; i++) current_position[i] = 0;
   2814              sync_plan_position();
   2815          
   2816              // Move all carriages up together until the first endstop is hit.
   2817              for (int i = X_AXIS; i <= Z_AXIS; i++) destination[i] = 3 * Z_MAX_LENGTH;
   2818              feedrate = G28_FEEDRATE * homing_feedrate[X_AXIS];
   2819              line_to_destination();
   2820              st_synchronize();
   2821              endstops_hit_on_purpose(); // clear endstop hit flags
   2822          
   2823              // Destination reached
   2824              for (int i = X_AXIS; i <= Z_AXIS; i++) current_position[i] = destination[i];
   2825          
   2826              // take care of back off and rehome now we are all at the top
   2827              HOMEAXIS(X);
   2828              HOMEAXIS(Y);
   2829              HOMEAXIS(Z);
   2830          
   2831              sync_plan_position_delta();
   2832          
   2833              #if ENABLED(DEBUG_LEVELING_FEATURE)
   2834                if (marlin_debug_flags & DEBUG_LEVELING) {
   2835                  print_xyz("(DELTA) > current_position", current_position);
   2836                }
   2837              #endif
   2838          
   2839            #else // NOT DELTA
   2840          
   2841              /*bool  homeX = code_seen(axis_codes[X_AXIS]),
   2842                    homeY = code_seen(axis_codes[Y_AXIS]),
   2843                    homeZ = code_seen(axis_codes[Z_AXIS]);
   2844          
   2845              home_all_axis = (!homeX && !homeY && !homeZ) || (homeX && homeY && homeZ);*/
   2846          
   2847              if (home_all_axis || homeZ) {
   2848          
   2849                #if Z_HOME_DIR > 0  // If homing away from BED do Z first
   2850          
   2851                  HOMEAXIS(Z);
   2852                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2853                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2854                      print_xyz("> HOMEAXIS(Z) > current_position", current_position);
   2855                    }
   2856                  #endif
   2857          
   2858                #elif DISABLED(Z_SAFE_HOMING) && defined(Z_RAISE_BEFORE_HOMING) && Z_RAISE_BEFORE_HOMING > 0
   2859                  // Raise Z before homing any other axes
   2860                  // (Does this need to be "negative home direction?" Why not just use Z_RAISE_BEFORE_HOMING?)
   2861                  current_position[2] = 0;sync_plan_position();
   2862                  destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * Z_HOME_DIR;
   2863                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2864                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2865                      SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   2866                      SERIAL_EOL;
   2867                      print_xyz("> (home_all_axis || homeZ) > destination", destination);
   2868                    }
   2869                  #endif
   2870                  feedrate = max_feedrate[Z_AXIS] * 60;
   2871                  line_to_destination();
   2872                  st_synchronize();
   2873          
   2874                #endif
   2875          
   2876              } // home_all_axis || homeZ
   2877          
   2878              #if ENABLED(QUICK_HOME)
   2879          
   2880                if (home_all_axis || (homeX && homeY)) {  // First diagonal move
   2881          
   2882                  current_position[X_AXIS] = current_position[Y_AXIS] = 0;
   2883          
   2884                  #if ENABLED(DUAL_X_CARRIAGE)
   2885                    int x_axis_home_dir = x_home_dir(active_extruder);
   2886                    extruder_duplication_enabled = false;
   2887                  #else
   2888                    //int x_axis_home_dir = home_dir(X_AXIS);
   2889                    int x_axis_home_dir = X_HOME_DIR;
   2890                  #endif
   2891          
   2892                  sync_plan_position();
   2893          
   2894                  float mlx = X_MAX_LENGTH, mly = Y_MAX_LENGTH,
   2895                        mlratio = mlx > mly ? mly / mlx : mlx / mly;
   2896          
   2897                  destination[X_AXIS] = 1.5 * mlx * x_axis_home_dir;
   2898                  destination[Y_AXIS] = 1.5 * mly * Y_HOME_DIR;
   2899                  feedrate = min(homing_feedrate[X_AXIS], homing_feedrate[Y_AXIS]) * sqrt(mlratio * mlratio + 1);
   2900                  line_to_destination();
   2901                  st_synchronize();
   2902          
   2903                  set_axis_is_at_home(X_AXIS);
   2904                  set_axis_is_at_home(Y_AXIS);
   2905                  sync_plan_position();
   2906          
   2907                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2908                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2909                      print_xyz("> QUICK_HOME > current_position 1", current_position);
   2910                    }
   2911                  #endif
   2912          
   2913                  destination[X_AXIS] = current_position[X_AXIS];
   2914                  destination[Y_AXIS] = current_position[Y_AXIS];
   2915                  line_to_destination();
   2916                  feedrate = 0.0;
   2917                  st_synchronize();
   2918                  endstops_hit_on_purpose(); // clear endstop hit flags
   2919          
   2920                  current_position[X_AXIS] = destination[X_AXIS];
   2921                  current_position[Y_AXIS] = destination[Y_AXIS];
   2922                  #if DISABLED(SCARA)
   2923                    current_position[Z_AXIS] = destination[Z_AXIS];
   2924                  #endif
   2925          
   2926                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2927                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2928                      print_xyz("> QUICK_HOME > current_position 2", current_position);
   2929                    }
   2930                  #endif
   2931                }
   2932          
   2933              #endif // QUICK_HOME
   2934          
   2935              #if ENABLED(HOME_Y_BEFORE_X)
   2936                // Home Y
   2937                if (home_all_axis || homeY) HOMEAXIS(Y);
   2938              #endif
   2939          
   2940              // Home X
   2941              if (home_all_axis || homeX) {
   2942                #if ENABLED(DUAL_X_CARRIAGE)
   2943                  int tmp_extruder = active_extruder;
   2944                  extruder_duplication_enabled = false;
   2945                  active_extruder = !active_extruder;
   2946                  HOMEAXIS(X);
   2947                  inactive_extruder_x_pos = current_position[X_AXIS];
   2948                  active_extruder = tmp_extruder;
   2949                  HOMEAXIS(X);
   2950                  // reset state used by the different modes
   2951                  memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
   2952                  delayed_move_time = 0;
   2953                  active_extruder_parked = true;
   2954                #else
   2955                  HOMEAXIS(X);
   2956                #endif
   2957                #if ENABLED(DEBUG_LEVELING_FEATURE)
   2958                  if (marlin_debug_flags & DEBUG_LEVELING) {
   2959                    print_xyz("> homeX", current_position);
   2960                  }
   2961                #endif
   2962              }
   2963          
   2964              #if DISABLED(HOME_Y_BEFORE_X)
   2965                // Home Y
   2966                if (home_all_axis || homeY) {
   2967                  HOMEAXIS(Y);
   2968                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   2969                    if (marlin_debug_flags & DEBUG_LEVELING) {
   2970                      print_xyz("> homeY", current_position);
   2971                    }
   2972                  #endif
   2973                }
   2974              #endif
   2975          
   2976              // Home Z last if homing towards the bed
   2977              #if Z_HOME_DIR < 0
   2978          
   2979                if (home_all_axis || homeZ) {
   2980          
   2981                  #if ENABLED(Z_SAFE_HOMING)
   2982          
   2983                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   2984                      if (marlin_debug_flags & DEBUG_LEVELING) {
   2985                        SERIAL_ECHOLNPGM("> Z_SAFE_HOMING >>>");
   2986                      }
   2987                    #endif
   2988          
   2989                    if (home_all_axis) {
   2990          
   2991                      current_position[Z_AXIS] = 0;
   2992                      sync_plan_position();
   2993          
   2994                      //
   2995                      // Set the Z probe (or just the nozzle) destination to the safe homing point
   2996                      //
   2997                      // NOTE: If current_position[X_AXIS] or current_position[Y_AXIS] were set above
   2998                      // then this may not work as expected.
   2999                      destination[X_AXIS] = round(Z_SAFE_HOMING_X_POINT - X_PROBE_OFFSET_FROM_EXTRUDER);
   3000                      destination[Y_AXIS] = round(Z_SAFE_HOMING_Y_POINT - Y_PROBE_OFFSET_FROM_EXTRUDER);
   3001                      destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);    // Set destination away from bed
   3002                      feedrate = XY_TRAVEL_SPEED;
   3003          
   3004                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   3005                        if (marlin_debug_flags & DEBUG_LEVELING) {
   3006                          SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   3007                          SERIAL_EOL;
   3008                          print_xyz("> home_all_axis > current_position", current_position);
   3009                          print_xyz("> home_all_axis > destination", destination);
   3010                        }
   3011                      #endif
   3012          
   3013                      // This could potentially move X, Y, Z all together
   3014                      line_to_destination();
   3015                      st_synchronize();
   3016          
   3017                      // Set current X, Y is the Z_SAFE_HOMING_POINT minus PROBE_OFFSET_FROM_EXTRUDER
   3018                      current_position[X_AXIS] = destination[X_AXIS];
   3019                      current_position[Y_AXIS] = destination[Y_AXIS];
   3020          
   3021                      // Home the Z axis
   3022                      HOMEAXIS(Z);
   3023                    }
   3024          
   3025                    else if (homeZ) { // Don't need to Home Z twice
   3026          
   3027                      // Let's see if X and Y are homed
   3028                      if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS]) {
   3029          
   3030                        // Make sure the Z probe is within the physical limits
   3031                        // NOTE: This doesn't necessarily ensure the Z probe is also within the bed!
   3032                        float cpx = current_position[X_AXIS], cpy = current_position[Y_AXIS];
   3033                        if (   cpx >= X_MIN_POS - X_PROBE_OFFSET_FROM_EXTRUDER
   3034                            && cpx <= X_MAX_POS - X_PROBE_OFFSET_FROM_EXTRUDER
   3035                            && cpy >= Y_MIN_POS - Y_PROBE_OFFSET_FROM_EXTRUDER
   3036                            && cpy <= Y_MAX_POS - Y_PROBE_OFFSET_FROM_EXTRUDER) {
   3037                          // Set the plan current position to X, Y, 0
   3038                          current_position[Z_AXIS] = 0;
   3039                          plan_set_position(cpx, cpy, 0, current_position[E_AXIS]); // = sync_plan_position
   3040          
   3041                          // Set Z destination away from bed and raise the axis
   3042                          // NOTE: This should always just be Z_RAISE_BEFORE_HOMING unless...???
   3043                          destination[Z_AXIS] = -Z_RAISE_BEFORE_HOMING * home_dir(Z_AXIS);
   3044                          feedrate = max_feedrate[Z_AXIS] * 60;  // feedrate (mm/m) = max_feedrate (mm/s)
   3045          
   3046                          #if ENABLED(DEBUG_LEVELING_FEATURE)
   3047                            if (marlin_debug_flags & DEBUG_LEVELING) {
   3048                              SERIAL_ECHOPAIR("Raise Z (before homing) by ", (float)Z_RAISE_BEFORE_HOMING);
   3049                              SERIAL_EOL;
   3050                              print_xyz("> homeZ > current_position", current_position);
   3051                              print_xyz("> homeZ > destination", destination);
   3052                            }
   3053                          #endif
   3054          
   3055                          line_to_destination();
   3056                          st_synchronize();
   3057          
   3058                          // Home the Z axis
   3059                          HOMEAXIS(Z);
   3060                        }
   3061                        else {
   3062                          LCD_MESSAGEPGM(MSG_ZPROBE_OUT);
   3063                          SERIAL_ECHO_START;
   3064                          SERIAL_ECHOLNPGM(MSG_ZPROBE_OUT);
   3065                        }
   3066                      }
   3067                      else {
   3068                        LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
   3069                        SERIAL_ECHO_START;
   3070                        SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
   3071                      }
   3072          
   3073                    } // !home_all_axes && homeZ
   3074          
   3075                    #if ENABLED(DEBUG_LEVELING_FEATURE)
   3076                      if (marlin_debug_flags & DEBUG_LEVELING) {
   3077                        SERIAL_ECHOLNPGM("<<< Z_SAFE_HOMING");
   3078                      }
   3079                    #endif
   3080          
   3081                  #else // !Z_SAFE_HOMING
   3082          
   3083          if (axis_known_position[X_AXIS] && axis_known_position[Y_AXIS] && (home_all_axis||homeZ)) {
   3084            current_position[Z_AXIS] = 0;
   3085            sync_plan_position();
   3086            
   3087            destination[X_AXIS]=10;
   3088            destination[Y_AXIS]=25;
   3089            destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING;
   3090            feedrate = max_feedrate[X_AXIS] * 60;
   3091            line_to_destination();
   3092            st_synchronize();
   3093            current_position[X_AXIS] = destination[X_AXIS];
   3094            current_position[Y_AXIS] = destination[Y_AXIS];
   3095            HOMEAXIS(Z);
   3096          }
   3097          
   3098                  #endif // !Z_SAFE_HOMING
   3099          
   3100                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   3101                    if (marlin_debug_flags & DEBUG_LEVELING) {
   3102                      print_xyz("> (home_all_axis || homeZ) > final", current_position);
   3103                    }
   3104                  #endif
   3105          
   3106                } // home_all_axis || homeZ
   3107          
   3108              #endif // Z_HOME_DIR < 0
   3109          
   3110              sync_plan_position();
   3111          
   3112            #endif // else DELTA
   3113          
   3114            #if ENABLED(SCARA)
   3115              sync_plan_position_delta();
   3116            #endif
   3117          
   3118            #if ENABLED(ENDSTOPS_ONLY_FOR_HOMING)
   3119              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3120                if (marlin_debug_flags & DEBUG_LEVELING) {
   3121                  SERIAL_ECHOLNPGM("ENDSTOPS_ONLY_FOR_HOMING enable_endstops(false)");
   3122                }
   3123              #endif
   3124              enable_endstops(false);
   3125            #endif
   3126          
   3127            if (home_all_axis && enable_recal_probe)
   3128            {
   3129                void recal_probe();
   3130                recal_probe();
   3131            }
   3132            // For manual leveling move back to 0,0
   3133            #if ENABLED(MESH_BED_LEVELING)
   3134              if (mbl_was_active && (homeZ || home_all_axis)) {
   3135                //current_position[X_AXIS] = mbl.get_x(0);
   3136                //current_position[Y_AXIS] = mbl.get_y(0);
   3137                //set_destination_to_current();
   3138                //feedrate = homing_feedrate[X_AXIS];
   3139                //line_to_destination();
   3140                //st_synchronize();
   3141                current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
   3142                destination[X_AXIS]=0;
   3143                destination[Y_AXIS]=0;
   3144                destination[Z_AXIS] = Z_RAISE_BEFORE_HOMING;
   3145                feedrate = max_feedrate[X_AXIS] * 60;
   3146                line_to_destination();
   3147                st_synchronize();
   3148                
   3149                current_position[X_AXIS]=0;
   3150                current_position[Y_AXIS]=0;
   3151                current_position[Z_AXIS]=Z_RAISE_BEFORE_HOMING;
   3152            
   3153                //current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
   3154                sync_plan_position();
   3155                mbl.active = 1;
   3156                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3157                  if (marlin_debug_flags & DEBUG_LEVELING) {
   3158                    print_xyz("mbl_was_active > current_position", current_position);
   3159                  }
   3160                #endif
   3161              }
   3162            #endif
   3163          
   3164            feedrate = saved_feedrate;
   3165            feedrate_multiplier = saved_feedrate_multiplier;
   3166            refresh_cmd_timeout();
   3167            endstops_hit_on_purpose(); // clear endstop hit flags
   3168          
   3169            #if ENABLED(DEBUG_LEVELING_FEATURE)
   3170              if (marlin_debug_flags & DEBUG_LEVELING) {
   3171                SERIAL_ECHOLNPGM("<<< gcode_G28");
   3172              }
   3173            #endif
   3174          
   3175            homing=false;
   3176          }
   3177          
   3178          #if ENABLED(MESH_BED_LEVELING)
   3179          
   3180            //enum MeshLevelingState { MeshReport, MeshStart, MeshNext, MeshSet };
   3181          enum MeshLevelingState { MeshReport, MeshStart, MeshSet };
   3182          
   3183            /**
   3184             * G29: Mesh-based Z probe, probes a grid and produces a
   3185             *      mesh to compensate for variable bed height
   3186             *
   3187             * Parameters With MESH_BED_LEVELING:
   3188             *
   3189             *  S0              Produce a mesh report
   3190             *  S1              Start probing mesh points
   3191             *  S2              Probe the next mesh point
   3192             *  S3 Xn Yn Zn.nn  Manually modify a single point
   3193             *
   3194             * The S0 report the points as below
   3195             *
   3196             *  +----> X-axis
   3197             *  |
   3198             *  |
   3199             *  v Y-axis
   3200             *
   3201             */
   3202            
   3203            float probe_xy(float x, float y)
   3204            {
   3205              float r;
   3206              plan_buffer_line(x, y, 4, current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3207              st_synchronize();
   3208              setup_for_endstop_move();
   3209              plan_buffer_line(x, y, -4, current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3210              st_synchronize();
   3211              //SERIAL_ECHOLN("run_z_probe > current_position2"); SERIAL_ECHOLN(st_get_position_mm(Z_AXIS));
   3212              r=st_get_position_mm(Z_AXIS);
   3213              current_position[X_AXIS]=x;
   3214              current_position[Y_AXIS]=y;
   3215              current_position[Z_AXIS]=st_get_position_mm(Z_AXIS);
   3216              sync_plan_position();
   3217              plan_buffer_line(x, y, 4, current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3218              st_synchronize();
   3219              clean_up_after_endstop_move();
   3220              endstops_hit_on_purpose();
   3221              return r;
   3222            }
   3223            inline void gcode_G29() {
   3224          
   3225              static int probe_point = -1;
   3226              
   3227              MeshLevelingState state = code_seen('S') ? (MeshLevelingState)code_value_short() : MeshReport;
   3228              if (state < 0 || state > 2) {
   3229                SERIAL_PROTOCOLLNPGM("S out of range (0-2).");
   3230                return;
   3231              }
   3232          
   3233              int ix, iy;
   3234              float z;
   3235          
   3236              switch (state) {
   3237                case MeshReport:
   3238                  if (mbl.active) {
   3239                    SERIAL_PROTOCOLPGM("Num X,Y: ");
   3240                    SERIAL_PROTOCOL(MESH_NUM_X_POINTS);
   3241                    SERIAL_PROTOCOLCHAR(',');
   3242                    SERIAL_PROTOCOL(MESH_NUM_Y_POINTS);
   3243                    SERIAL_PROTOCOLPGM("\nZ search height: ");
   3244                    SERIAL_PROTOCOL(MESH_HOME_SEARCH_Z);
   3245                    SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   3246                    for (int y = 0; y < MESH_NUM_Y_POINTS; y++) {
   3247                      for (int x = 0; x < MESH_NUM_X_POINTS; x++) {
   3248                        SERIAL_PROTOCOLPGM("  ");
   3249                        SERIAL_PROTOCOL_F(mbl.z_values[y][x], 5);
   3250                      }
   3251                      SERIAL_EOL;
   3252                    }
   3253                  }
   3254                  else
   3255                    SERIAL_PROTOCOLLNPGM("Mesh bed leveling not active.");
   3256                  
   3257                  SERIAL_PROTOCOLLNPGM("Start probing using \"G29 S1\".");
   3258                  break;
   3259                case MeshStart:
   3260                  //////////////////////////////
   3261                  float p1,p2,p3,p4;
   3262                  st_synchronize();
   3263                  
   3264                  mbl.reset();
   3265                  
   3266                  gcode_G28();
   3267                  //current_position[X_AXIS]=5;
   3268                  //current_position[Y_AXIS]=20;
   3269                  destination[Z_AXIS]=4;
   3270                  feedrate = homing_feedrate[X_AXIS] / 60;
   3271                  line_to_destination();
   3272                  //plan_buffer_line(5, 20, 4, current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3273                  st_synchronize();
   3274                  p1=0;//probe_xy(0,0);
   3275                  /*p2=probe_xy(120,0)+1.5;
   3276                  p3=probe_xy(120,130)+1.5;
   3277                  p4=probe_xy(0,130);*/
   3278                  
   3279                  p2=probe_xy(120,25);//+1.5;
   3280                  p3=probe_xy(120,120);//+1.5;
   3281                  p4=probe_xy(10,120);
   3282                  
   3283                  plan_buffer_line(0, 0, 4, current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3284                  st_synchronize();
   3285                  current_position[X_AXIS]=0;
   3286                  current_position[Y_AXIS]=0;
   3287                  current_position[Z_AXIS]=st_get_position_mm(Z_AXIS);
   3288                  sync_plan_position();
   3289                  
   3290                  // p4 p3
   3291                  // p1 p2
   3292                  /*SERIAL_PROTOCOLLN("DONE");
   3293                  SERIAL_PROTOCOLPGM("A=");
   3294                  SERIAL_PROTOCOL_F(p4, 8);
   3295                  SERIAL_PROTOCOLPGM(" B=");
   3296                  SERIAL_PROTOCOL_F(p3, 8);
   3297                  
   3298                  SERIAL_PROTOCOLLN("");
   3299                  SERIAL_PROTOCOLPGM("C=");
   3300                  SERIAL_PROTOCOL_F(p1, 8);
   3301                  SERIAL_PROTOCOLPGM(" D=");
   3302                  SERIAL_PROTOCOL_F(p2, 8);
   3303                  SERIAL_PROTOCOLLN("");*/
   3304                  
   3305                  p1+=zprobe_zoffset;
   3306                  p2+=zprobe_zoffset;
   3307                  p3+=zprobe_zoffset;
   3308                  p4+=zprobe_zoffset;
   3309          
   3310                  mbl.set_z(0, 0, p1);
   3311                  mbl.set_z(1, 0, p2);
   3312                  mbl.set_z(1, 1, p3);
   3313                  mbl.set_z(0, 1, p4);
   3314                  mbl.active = 1;
   3315                          
   3316                  SERIAL_PROTOCOLPGM("Num X,Y: ");
   3317                  SERIAL_PROTOCOL(MESH_NUM_X_POINTS);
   3318                  SERIAL_PROTOCOLCHAR(',');
   3319                  SERIAL_PROTOCOL(MESH_NUM_Y_POINTS);
   3320                  SERIAL_PROTOCOLPGM("\nZ search height: ");
   3321                  SERIAL_PROTOCOL(MESH_HOME_SEARCH_Z);
   3322                  SERIAL_PROTOCOLLNPGM("\nMeasured points:");
   3323                  for (int y = 0; y < MESH_NUM_Y_POINTS; y++) {
   3324                    for (int x = 0; x < MESH_NUM_X_POINTS; x++) {
   3325                      SERIAL_PROTOCOLPGM("  ");
   3326                      SERIAL_PROTOCOL_F(mbl.z_values[y][x], 5);
   3327                    }
   3328                    SERIAL_EOL;
   3329                  }
   3330                  return;
   3331                  //////////////////////////////
   3332          /*
   3333                case MeshStart:
   3334                  mbl.reset();
   3335                  probe_point = 0;
   3336                  enqueuecommands_P(PSTR("G28\nG29 S2"));
   3337                  break;
   3338          
   3339                case MeshNext:
   3340                  if (probe_point < 0) {
   3341                    SERIAL_PROTOCOLLNPGM("Start mesh probing with \"G29 S1\" first.");
   3342                    return;
   3343                  }
   3344                  if (probe_point == 0) {
   3345                    // Set Z to a positive value before recording the first Z.
   3346                    current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
   3347                    sync_plan_position();
   3348                  }
   3349                  else {
   3350                    // For others, save the Z of the previous point, then raise Z again.
   3351                    ix = (probe_point - 1) % MESH_NUM_X_POINTS;
   3352                    iy = (probe_point - 1) / MESH_NUM_X_POINTS;
   3353                    if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
   3354                    mbl.set_z(ix, iy, current_position[Z_AXIS]);
   3355                    current_position[Z_AXIS] = MESH_HOME_SEARCH_Z;
   3356                    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3357                    st_synchronize();
   3358                  }
   3359                  // Is there another point to sample? Move there.
   3360                  if (probe_point < MESH_NUM_X_POINTS * MESH_NUM_Y_POINTS) {
   3361                    ix = probe_point % MESH_NUM_X_POINTS;
   3362                    iy = probe_point / MESH_NUM_X_POINTS;
   3363                    if (iy & 1) ix = (MESH_NUM_X_POINTS - 1) - ix; // zig-zag
   3364                    current_position[X_AXIS] = mbl.get_x(ix);
   3365                    current_position[Y_AXIS] = mbl.get_y(iy);
   3366                    plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], homing_feedrate[X_AXIS] / 60, active_extruder);
   3367                    st_synchronize();
   3368                    probe_point++;
   3369                  }
   3370                  else {
   3371                    // After recording the last point, activate the mbl and home
   3372                    SERIAL_PROTOCOLLNPGM("Mesh probing done.");
   3373                    probe_point = -1;
   3374                    mbl.active = 1;
   3375                    enqueuecommands_P(PSTR("G28"));
   3376                  }
   3377                  break;
   3378          */
   3379                case MeshSet:
   3380                  if (code_seen('X')) {
   3381                    ix = code_value_long() - 1;
   3382                    if (ix < 0 || ix >= MESH_NUM_X_POINTS) {
   3383                      SERIAL_PROTOCOLPGM("X out of range (1-" STRINGIFY(MESH_NUM_X_POINTS) ").\n");
   3384                      return;
   3385                    }
   3386                  }
   3387                  else {
   3388                    SERIAL_PROTOCOLPGM("X not entered.\n");
   3389                    return;
   3390                  }
   3391                  if (code_seen('Y')) {
   3392                    iy = code_value_long() - 1;
   3393                    if (iy < 0 || iy >= MESH_NUM_Y_POINTS) {
   3394                      SERIAL_PROTOCOLPGM("Y out of range (1-" STRINGIFY(MESH_NUM_Y_POINTS) ").\n");
   3395                      return;
   3396                    }
   3397                  }
   3398                  else {
   3399                    SERIAL_PROTOCOLPGM("Y not entered.\n");
   3400                    return;
   3401                  }
   3402                  if (code_seen('Z')) {
   3403                    z = code_value();
   3404                  }
   3405                  else {
   3406                    SERIAL_PROTOCOLPGM("Z not entered.\n");
   3407                    return;
   3408                  }
   3409                  mbl.z_values[iy][ix] = z;
   3410          
   3411              } // switch(state)
   3412            }
   3413          
   3414          #elif ENABLED(AUTO_BED_LEVELING_FEATURE)
   3415          
   3416            void out_of_range_error(const char* p_edge) {
   3417              SERIAL_PROTOCOLPGM("?Probe ");
   3418              serialprintPGM(p_edge);
   3419              SERIAL_PROTOCOLLNPGM(" position out of range.");
   3420            }
   3421          
   3422            /**
   3423             * G29: Detailed Z probe, probes the bed at 3 or more points.
   3424             *      Will fail if the printer has not been homed with G28.
   3425             *
   3426             * Enhanced G29 Auto Bed Leveling Probe Routine
   3427             *
   3428             * Parameters With AUTO_BED_LEVELING_GRID:
   3429             *
   3430             *  P  Set the size of the grid that will be probed (P x P points).
   3431             *     Not supported by non-linear delta printer bed leveling.
   3432             *     Example: "G29 P4"
   3433             *
   3434             *  S  Set the XY travel speed between probe points (in mm/min)
   3435             *
   3436             *  D  Dry-Run mode. Just evaluate the bed Topology - Don't apply
   3437             *     or clean the rotation Matrix. Useful to check the topology
   3438             *     after a first run of G29.
   3439             *
   3440             *  V  Set the verbose level (0-4). Example: "G29 V3"
   3441             *
   3442             *  T  Generate a Bed Topology Report. Example: "G29 P5 T" for a detailed report.
   3443             *     This is useful for manual bed leveling and finding flaws in the bed (to
   3444             *     assist with part placement).
   3445             *     Not supported by non-linear delta printer bed leveling.
   3446             *
   3447             *  F  Set the Front limit of the probing grid
   3448             *  B  Set the Back limit of the probing grid
   3449             *  L  Set the Left limit of the probing grid
   3450             *  R  Set the Right limit of the probing grid
   3451             *
   3452             * Global Parameters:
   3453             *
   3454             * E/e By default G29 will engage the Z probe, test the bed, then disengage.
   3455             *     Include "E" to engage/disengage the Z probe for each sample.
   3456             *     There's no extra effect if you have a fixed Z probe.
   3457             *     Usage: "G29 E" or "G29 e"
   3458             *
   3459             */
   3460            inline void gcode_G29() {
   3461              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3462                if (marlin_debug_flags & DEBUG_LEVELING) {
   3463                  SERIAL_ECHOLNPGM("gcode_G29 >>>");
   3464                }
   3465              #endif
   3466          
   3467              // Don't allow auto-leveling without homing first
   3468              if (!axis_known_position[X_AXIS] || !axis_known_position[Y_AXIS]) {
   3469                //LCD_MESSAGEPGM(MSG_POSITION_UNKNOWN);
   3470                //SERIAL_ECHO_START;
   3471                //SERIAL_ECHOLNPGM(MSG_POSITION_UNKNOWN);
   3472                return;
   3473              }
   3474          
   3475              int verbose_level = code_seen('V') ? code_value_short() : 1;
   3476              if (verbose_level < 0 || verbose_level > 4) {
   3477                SERIAL_ECHOLNPGM("?(V)erbose Level is implausible (0-4).");
   3478                return;
   3479              }
   3480          
   3481              bool dryrun = code_seen('D'),
   3482                   deploy_probe_for_each_reading = code_seen('E');
   3483          
   3484              #if ENABLED(AUTO_BED_LEVELING_GRID)
   3485          
   3486                #if DISABLED(DELTA)
   3487                  bool do_topography_map = verbose_level > 2 || code_seen('T');
   3488                #endif
   3489          
   3490                if (verbose_level > 0) {
   3491                  SERIAL_PROTOCOLPGM("G29 Auto Bed Leveling\n");
   3492                  if (dryrun) SERIAL_ECHOLNPGM("Running in DRY-RUN mode");
   3493                }
   3494          
   3495                int auto_bed_leveling_grid_points = AUTO_BED_LEVELING_GRID_POINTS;
   3496          
   3497                #if DISABLED(DELTA)
   3498                  if (code_seen('P')) auto_bed_leveling_grid_points = code_value_short();
   3499                  if (auto_bed_leveling_grid_points < 2) {
   3500                    SERIAL_PROTOCOLPGM("?Number of probed (P)oints is implausible (2 minimum).\n");
   3501                    return;
   3502                  }
   3503                #endif
   3504          
   3505                xy_travel_speed = code_seen('S') ? code_value_short() : XY_TRAVEL_SPEED;
   3506          
   3507                int left_probe_bed_position = code_seen('L') ? code_value_short() : LEFT_PROBE_BED_POSITION,
   3508                    right_probe_bed_position = code_seen('R') ? code_value_short() : RIGHT_PROBE_BED_POSITION,
   3509                    front_probe_bed_position = code_seen('F') ? code_value_short() : FRONT_PROBE_BED_POSITION,
   3510                    back_probe_bed_position = code_seen('B') ? code_value_short() : BACK_PROBE_BED_POSITION;
   3511          
   3512                bool left_out_l = left_probe_bed_position < MIN_PROBE_X,
   3513                     left_out = left_out_l || left_probe_bed_position > right_probe_bed_position - MIN_PROBE_EDGE,
   3514                     right_out_r = right_probe_bed_position > MAX_PROBE_X,
   3515                     right_out = right_out_r || right_probe_bed_position < left_probe_bed_position + MIN_PROBE_EDGE,
   3516                     front_out_f = front_probe_bed_position < MIN_PROBE_Y,
   3517                     front_out = front_out_f || front_probe_bed_position > back_probe_bed_position - MIN_PROBE_EDGE,
   3518                     back_out_b = back_probe_bed_position > MAX_PROBE_Y,
   3519                     back_out = back_out_b || back_probe_bed_position < front_probe_bed_position + MIN_PROBE_EDGE;
   3520          
   3521                if (left_out || right_out || front_out || back_out) {
   3522                  if (left_out) {
   3523                    out_of_range_error(PSTR("(L)eft"));
   3524                    left_probe_bed_position = left_out_l ? MIN_PROBE_X : right_probe_bed_position - MIN_PROBE_EDGE;
   3525                  }
   3526                  if (right_out) {
   3527                    out_of_range_error(PSTR("(R)ight"));
   3528                    right_probe_bed_position = right_out_r ? MAX_PROBE_X : left_probe_bed_position + MIN_PROBE_EDGE;
   3529                  }
   3530                  if (front_out) {
   3531                    out_of_range_error(PSTR("(F)ront"));
   3532                    front_probe_bed_position = front_out_f ? MIN_PROBE_Y : back_probe_bed_position - MIN_PROBE_EDGE;
   3533                  }
   3534                  if (back_out) {
   3535                    out_of_range_error(PSTR("(B)ack"));
   3536                    back_probe_bed_position = back_out_b ? MAX_PROBE_Y : front_probe_bed_position + MIN_PROBE_EDGE;
   3537                  }
   3538                  return;
   3539                }
   3540          
   3541              #endif // AUTO_BED_LEVELING_GRID
   3542          
   3543              #if ENABLED(Z_PROBE_SLED)
   3544                dock_sled(false); // engage (un-dock) the Z probe
   3545              #elif ENABLED(Z_PROBE_ALLEN_KEY) //|| SERVO_LEVELING
   3546                deploy_z_probe();
   3547              #endif
   3548          
   3549              st_synchronize();
   3550              if (!dryrun) {
   3551                // make sure the bed_level_rotation_matrix is identity or the planner will get it wrong
   3552                plan_bed_level_matrix.set_to_identity();
   3553          
   3554                #if ENABLED(DELTA)
   3555                  reset_bed_level();
   3556                #else //!DELTA
   3557                  //vector_3 corrected_position = plan_get_position_mm();
   3558                  //corrected_position.debug("position before G29");
   3559                  vector_3 uncorrected_position = plan_get_position();
   3560                  //uncorrected_position.debug("position during G29");
   3561                  current_position[X_AXIS] = uncorrected_position.x;
   3562                  current_position[Y_AXIS] = uncorrected_position.y;
   3563                  current_position[Z_AXIS] = uncorrected_position.z;
   3564                  sync_plan_position();
   3565                #endif // !DELTA
   3566              }
   3567              setup_for_endstop_move();
   3568          
   3569              //feedrate = homing_feedrate[Z_AXIS];
   3570              feedrate = Z_AXIS_HOMING_FEEDRATE;
   3571          
   3572              #if ENABLED(AUTO_BED_LEVELING_GRID)
   3573          
   3574                // probe at the points of a lattice grid
   3575                const int xGridSpacing = (right_probe_bed_position - left_probe_bed_position) / (auto_bed_leveling_grid_points - 1),
   3576                          yGridSpacing = (back_probe_bed_position - front_probe_bed_position) / (auto_bed_leveling_grid_points - 1);
   3577                #if 1//ENABLED(DELTA)
   3578                  delta_grid_spacing[0] = xGridSpacing;
   3579                  delta_grid_spacing[1] = yGridSpacing;
   3580                  float z_offset = zprobe_zoffset;
   3581                  if (code_seen(axis_codes[Z_AXIS])) z_offset += code_value();
   3582                #else // !DELTA
   3583                  // solve the plane equation ax + by + d = z
   3584                  // A is the matrix with rows [x y 1] for all the probed points
   3585                  // B is the vector of the Z positions
   3586                  // the normal vector to the plane is formed by the coefficients of the plane equation in the standard form, which is Vx*x+Vy*y+Vz*z+d = 0
   3587                  // so Vx = -a Vy = -b Vz = 1 (we want the vector facing towards positive Z
   3588          
   3589                  int abl2 = auto_bed_leveling_grid_points * auto_bed_leveling_grid_points;
   3590          
   3591                  double eqnAMatrix[abl2 * 3], // "A" matrix of the linear system of equations
   3592                         eqnBVector[abl2],     // "B" vector of Z points*/
   3593                         mean = 0.0;
   3594                  int8_t indexIntoAB[auto_bed_leveling_grid_points][auto_bed_leveling_grid_points];
   3595                  int8_t indexIntoAB[6][6];
   3596                #endif // !DELTA
   3597                int probePointCounter = 0;
   3598                bool zig = (auto_bed_leveling_grid_points & 1) ? true : false; //always end at [RIGHT_PROBE_BED_POSITION, BACK_PROBE_BED_POSITION]
   3599          
   3600                for (int yCount = 0; yCount < auto_bed_leveling_grid_points; yCount++) {
   3601                  double yProbe = front_probe_bed_position + yGridSpacing * yCount;
   3602                  int xStart, xStop, xInc;
   3603          
   3604                  if (zig) {
   3605                    xStart = 0;
   3606                    xStop = auto_bed_leveling_grid_points;
   3607                    xInc = 1;
   3608                  }
   3609                  else {
   3610                    xStart = auto_bed_leveling_grid_points - 1;
   3611                    xStop = -1;
   3612                    xInc = -1;
   3613                  }
   3614          
   3615                  zig = !zig;
   3616                  for (int xCount = xStart; xCount != xStop; xCount += xInc) {
   3617                    double xProbe = left_probe_bed_position + xGridSpacing * xCount;
   3618          
   3619                    // raise extruder
   3620                    float measured_z,
   3621                    z_before = probePointCounter ? Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS] : Z_RAISE_BEFORE_PROBING;
   3622                    if (probePointCounter) {
   3623                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   3624                        if (marlin_debug_flags & DEBUG_LEVELING) {
   3625                          SERIAL_ECHOPAIR("z_before = (between) ", (float)(Z_RAISE_BETWEEN_PROBINGS + current_position[Z_AXIS]));
   3626                          SERIAL_EOL;
   3627                        }
   3628                      #endif
   3629                    }
   3630                    else {
   3631                      #if ENABLED(DEBUG_LEVELING_FEATURE)
   3632                        if (marlin_debug_flags & DEBUG_LEVELING) {
   3633                          SERIAL_ECHOPAIR("z_before = (before) ", (float)Z_RAISE_BEFORE_PROBING);
   3634                          SERIAL_EOL;
   3635                        }
   3636                      #endif
   3637                    }
   3638                    #if ENABLED(DELTA)
   3639                      // Avoid probing the corners (outside the round or hexagon print surface) on a delta printer.
   3640                      float distance_from_center = sqrt(xProbe * xProbe + yProbe * yProbe);
   3641                      if (distance_from_center > DELTA_PROBABLE_RADIUS) continue;
   3642                    #endif //DELTA
   3643          
   3644                    ProbeAction act;
   3645                    if (deploy_probe_for_each_reading) // G29 E - Stow between probes
   3646                      act = ProbeDeployAndStow;
   3647                    else if (yCount == 0 && xCount == xStart)
   3648                      act = ProbeDeploy;
   3649                    else if (yCount == auto_bed_leveling_grid_points - 1 && xCount == xStop - xInc)
   3650                      act = ProbeStow;
   3651                    else
   3652                      act = ProbeStay;
   3653                    measured_z = probe_pt(xProbe, yProbe, z_before, act, verbose_level);
   3654                    #if 0//DISABLED(DELTA)
   3655                      mean += measured_z;
   3656          
   3657                      eqnBVector[probePointCounter] = measured_z;
   3658                      eqnAMatrix[probePointCounter + 0 * abl2] = xProbe;
   3659                      eqnAMatrix[probePointCounter + 1 * abl2] = yProbe;
   3660                      eqnAMatrix[probePointCounter + 2 * abl2] = 1;
   3661                      indexIntoAB[xCount][yCount] = probePointCounter;
   3662                    #else
   3663                      bed_level[xCount][yCount] = measured_z + z_offset;
   3664                    #endif
   3665          
   3666                    probePointCounter++;
   3667                    IWDG_ReloadCounter();
   3668                  } //xProbe
   3669                } //yProbe
   3670                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3671                  if (marlin_debug_flags & DEBUG_LEVELING) {
   3672                    print_xyz("> probing complete > current_position", current_position);
   3673                  }
   3674                #endif
   3675          
   3676                clean_up_after_endstop_move();
   3677                //#if ENABLED(DELTA)
   3678                      
   3679                  //if (!dryrun) extrapolate_unprobed_bed_level();
   3680                  print_bed_level();
   3681          
   3682                //#else // !DELTA
   3683          /*
   3684                  // solve lsq problem
   3685                  double plane_equation_coefficients[3];
   3686                  qr_solve(plane_equation_coefficients, abl2, 3, eqnAMatrix, eqnBVector);
   3687                  mean /= abl2;
   3688          
   3689                  if (verbose_level) {
   3690                    SERIAL_PROTOCOLPGM("Eqn coefficients: a: ");
   3691                    SERIAL_PROTOCOL_F(plane_equation_coefficients[0], 8);
   3692                    SERIAL_PROTOCOLPGM(" b: ");
   3693                    SERIAL_PROTOCOL_F(plane_equation_coefficients[1], 8);
   3694                    SERIAL_PROTOCOLPGM(" d: ");
   3695                    SERIAL_PROTOCOL_F(plane_equation_coefficients[2], 8);
   3696                    SERIAL_EOL;
   3697                    if (verbose_level > 2) {
   3698                      SERIAL_PROTOCOLPGM("Mean of sampled points: ");
   3699                      SERIAL_PROTOCOL_F(mean, 8);
   3700                      SERIAL_EOL;
   3701                    }
   3702                  }
   3703                  if (!dryrun) set_bed_level_equation_lsq(plane_equation_coefficients);
   3704          
   3705                  // Show the Topography map if enabled
   3706                  if (do_topography_map) {
   3707          
   3708                    SERIAL_PROTOCOLPGM(" \nBed Height Topography: \n");
   3709                    SERIAL_PROTOCOLPGM("+-----------+\n");
   3710                    SERIAL_PROTOCOLPGM("|...Back....|\n");
   3711                    SERIAL_PROTOCOLPGM("|Left..Right|\n");
   3712                    SERIAL_PROTOCOLPGM("|...Front...|\n");
   3713                    SERIAL_PROTOCOLPGM("+-----------+\n");
   3714          
   3715                    float min_diff = 999;
   3716          
   3717                    for (int yy = auto_bed_leveling_grid_points - 1; yy >= 0; yy--) {
   3718                      for (int xx = 0; xx < auto_bed_leveling_grid_points; xx++) {
   3719                        int ind = indexIntoAB[xx][yy];
   3720                        float diff = eqnBVector[ind] - mean;
   3721          
   3722                        float x_tmp = eqnAMatrix[ind + 0 * abl2],
   3723                              y_tmp = eqnAMatrix[ind + 1 * abl2],
   3724                              z_tmp = 0;
   3725          
   3726                        apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);
   3727          
   3728                        if (eqnBVector[ind] - z_tmp < min_diff)
   3729                          min_diff = eqnBVector[ind] - z_tmp;
   3730          
   3731                        if (diff >= 0.0)
   3732                          SERIAL_PROTOCOLPGM(" +");   // Include + for column alignment
   3733                        else
   3734                          SERIAL_PROTOCOLCHAR(' ');
   3735                        SERIAL_PROTOCOL_F(diff, 5);
   3736                      } // xx
   3737                      SERIAL_EOL;
   3738                    } // yy
   3739                    SERIAL_EOL;
   3740                    if (verbose_level > 3) {
   3741                      SERIAL_PROTOCOLPGM(" \nCorrected Bed Height vs. Bed Topology: \n");
   3742          
   3743                      for (int yy = auto_bed_leveling_grid_points - 1; yy >= 0; yy--) {
   3744                        for (int xx = 0; xx < auto_bed_leveling_grid_points; xx++) {
   3745                          int ind = indexIntoAB[xx][yy];
   3746                          float x_tmp = eqnAMatrix[ind + 0 * abl2],
   3747                                y_tmp = eqnAMatrix[ind + 1 * abl2],
   3748                                z_tmp = 0;
   3749          
   3750                          apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp);
   3751          
   3752                          float diff = eqnBVector[ind] - z_tmp - min_diff;
   3753                          if (diff >= 0.0)
   3754                            SERIAL_PROTOCOLPGM(" +");
   3755                          // Include + for column alignment
   3756                          else
   3757                            SERIAL_PROTOCOLCHAR(' ');
   3758                          SERIAL_PROTOCOL_F(diff, 5);
   3759                        } // xx
   3760                        SERIAL_EOL;
   3761                      } // yy
   3762                      SERIAL_EOL;
   3763                    }
   3764                  } //do_topography_map
   3765                #endif //!DELTA
   3766          */
   3767              #else // !AUTO_BED_LEVELING_GRID
   3768          
   3769                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3770                  if (marlin_debug_flags & DEBUG_LEVELING) {
   3771                    SERIAL_ECHOLNPGM("> 3-point Leveling");
   3772                  }
   3773                #endif
   3774          
   3775                // Actions for each probe
   3776                ProbeAction p1, p2, p3;
   3777                if (deploy_probe_for_each_reading)
   3778                  p1 = p2 = p3 = ProbeDeployAndStow;
   3779                else
   3780                  p1 = ProbeStay, p2 = ProbeStay, p3 = ProbeStay;
   3781          
   3782                // Probe at 3 arbitrary points
   3783                float z_at_pt_1 = probe_pt(ABL_PROBE_PT_1_X, ABL_PROBE_PT_1_Y, Z_RAISE_BEFORE_PROBING, p1, verbose_level),
   3784                      z_at_pt_2 = probe_pt(ABL_PROBE_PT_2_X, ABL_PROBE_PT_2_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p2, verbose_level),
   3785                      z_at_pt_3 = probe_pt(ABL_PROBE_PT_3_X, ABL_PROBE_PT_3_Y, current_position[Z_AXIS] + Z_RAISE_BETWEEN_PROBINGS, p3, verbose_level);
   3786                clean_up_after_endstop_move();
   3787                if (!dryrun) set_bed_level_equation_3pts(z_at_pt_1, z_at_pt_2, z_at_pt_3);
   3788          
   3789              #endif // !AUTO_BED_LEVELING_GRID
   3790          
   3791              #if 1//ENABLED(DELTA)
   3792                // Allen Key Probe for Delta
   3793                #if ENABLED(Z_PROBE_ALLEN_KEY)
   3794                  stow_z_probe();
   3795                #elif Z_RAISE_AFTER_PROBING > 0
   3796                  raise_z_after_probing();
   3797                #endif
   3798              #else // !DELTA
   3799                if (verbose_level > 0)
   3800                  plan_bed_level_matrix.debug(" \n\nBed Level Correction Matrix:");
   3801          
   3802                if (!dryrun) {
   3803                  // Correct the Z height difference from Z probe position and nozzle tip position.
   3804                  // The Z height on homing is measured by Z probe, but the Z probe is quite far from the nozzle.
   3805                  // When the bed is uneven, this height must be corrected.
   3806                  float x_tmp = current_position[X_AXIS] + X_PROBE_OFFSET_FROM_EXTRUDER,
   3807                        y_tmp = current_position[Y_AXIS] + Y_PROBE_OFFSET_FROM_EXTRUDER,
   3808                        z_tmp = current_position[Z_AXIS],
   3809                        real_z = st_get_position_mm(Z_AXIS);  //get the real Z (since plan_get_position is now correcting the plane)
   3810          
   3811                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   3812                    if (marlin_debug_flags & DEBUG_LEVELING) {
   3813                      SERIAL_ECHOPAIR("> BEFORE apply_rotation_xyz > z_tmp  = ", z_tmp);
   3814                      SERIAL_EOL;
   3815                      SERIAL_ECHOPAIR("> BEFORE apply_rotation_xyz > real_z = ", real_z);
   3816                      SERIAL_EOL;
   3817                    }
   3818                  #endif
   3819          
   3820                  apply_rotation_xyz(plan_bed_level_matrix, x_tmp, y_tmp, z_tmp); // Apply the correction sending the Z probe offset
   3821          
   3822                  // Get the current Z position and send it to the planner.
   3823                  //
   3824                  // >> (z_tmp - real_z) : The rotated current Z minus the uncorrected Z (most recent plan_set_position/sync_plan_position)
   3825                  //
   3826                  // >> zprobe_zoffset : Z distance from nozzle to Z probe (set by default, M851, EEPROM, or Menu)
   3827                  //
   3828                  // >> Z_RAISE_AFTER_PROBING : The distance the Z probe will have lifted after the last probe
   3829                  //
   3830                  // >> Should home_offset[Z_AXIS] be included?
   3831                  //
   3832                  //      Discussion: home_offset[Z_AXIS] was applied in G28 to set the starting Z.
   3833                  //      If Z is not tweaked in G29 -and- the Z probe in G29 is not actually "homing" Z...
   3834                  //      then perhaps it should not be included here. The purpose of home_offset[] is to
   3835                  //      adjust for inaccurate endstops, not for reasonably accurate probes. If it were
   3836                  //      added here, it could be seen as a compensating factor for the Z probe.
   3837                  //
   3838                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   3839                    if (marlin_debug_flags & DEBUG_LEVELING) {
   3840                      SERIAL_ECHOPAIR("> AFTER apply_rotation_xyz > z_tmp  = ", z_tmp);
   3841                      SERIAL_EOL;
   3842                    }
   3843                  #endif
   3844          
   3845                  current_position[Z_AXIS] = -zprobe_zoffset + (z_tmp - real_z)
   3846                    #if HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY) || ENABLED(Z_PROBE_SLED)
   3847                       + Z_RAISE_AFTER_PROBING
   3848                    #endif
   3849                    ;
   3850                  // current_position[Z_AXIS] += home_offset[Z_AXIS]; // The Z probe determines Z=0, not "Z home"
   3851                  sync_plan_position();
   3852          
   3853                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   3854                    if (marlin_debug_flags & DEBUG_LEVELING) {
   3855                      print_xyz("> corrected Z in G29", current_position);
   3856                    }
   3857                  #endif
   3858                }
   3859          
   3860                // Sled assembly for Cartesian bots
   3861                #if ENABLED(Z_PROBE_SLED)
   3862                  dock_sled(true); // dock the sled
   3863                #endif
   3864          
   3865              #endif // !DELTA
   3866          
   3867              #ifdef Z_PROBE_END_SCRIPT
   3868                #if ENABLED(DEBUG_LEVELING_FEATURE)
   3869                  if (marlin_debug_flags & DEBUG_LEVELING) {
   3870                    SERIAL_ECHO("Z Probe End Script: ");
   3871                    SERIAL_ECHOLNPGM(Z_PROBE_END_SCRIPT);
   3872                  }
   3873                #endif
   3874                enqueuecommands_P(PSTR(Z_PROBE_END_SCRIPT));
   3875                st_synchronize();
   3876              #endif
   3877          
   3878              #if ENABLED(DEBUG_LEVELING_FEATURE)
   3879                if (marlin_debug_flags & DEBUG_LEVELING) {
   3880                  SERIAL_ECHOLNPGM("<<< gcode_G29");
   3881                }
   3882              #endif
   3883          
   3884            }
   3885          
   3886            #if DISABLED(Z_PROBE_SLED)
   3887          
   3888              /**
   3889               * G30: Do a single Z probe at the current XY
   3890               */
   3891              void gcode_G30() {
   3892                #if HAS_SERVO_ENDSTOPS
   3893                  raise_z_for_servo();
   3894                #endif
   3895                deploy_z_probe(); // Engage Z Servo endstop if available
   3896          
   3897                st_synchronize();
   3898                // TODO: clear the leveling matrix or the planner will be set incorrectly
   3899                setup_for_endstop_move();
   3900          
   3901                feedrate = homing_feedrate[Z_AXIS];
   3902          
   3903                run_z_probe();
   3904                SERIAL_PROTOCOLPGM("Bed X: ");
   3905                SERIAL_PROTOCOL(current_position[X_AXIS] + 0.0001);
   3906                SERIAL_PROTOCOLPGM(" Y: ");
   3907                SERIAL_PROTOCOL(current_position[Y_AXIS] + 0.0001);
   3908                SERIAL_PROTOCOLPGM(" Z: ");
   3909                SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);
   3910                SERIAL_EOL;
   3911          
   3912                clean_up_after_endstop_move();
   3913          
   3914                #if HAS_SERVO_ENDSTOPS
   3915                  raise_z_for_servo();
   3916                #endif
   3917                stow_z_probe(false); // Retract Z Servo endstop if available
   3918              }
   3919          
   3920            #endif //!Z_PROBE_SLED
   3921          
   3922          #endif //AUTO_BED_LEVELING_FEATURE
   3923          /*void print_xyz(const char* prefix, const float x, const float y, const float z) {
   3924              SERIAL_ECHO(prefix);
   3925              SERIAL_ECHOPAIR(": (", x);
   3926              SERIAL_ECHOPAIR(", ", y);
   3927              SERIAL_ECHOPAIR(", ", z);
   3928              SERIAL_ECHOLNPGM(")");
   3929            }
   3930            void print_xyz(const char* prefix, const float xyz[]) {
   3931              print_xyz(prefix, xyz[X_AXIS], xyz[Y_AXIS], xyz[Z_AXIS]);
   3932            }*/
   3933          #if ENABLED(MESH_BED_LEVELING)
   3934          static void run_z_probe() {
   3935          
   3936                feedrate = homing_feedrate[Z_AXIS];
   3937          SERIAL_ECHOLN("run_z_probe > current_position1"); SERIAL_ECHOLN(st_get_position_mm(Z_AXIS));
   3938                // Move down until the Z probe (or endstop?) is triggered
   3939                float zPosition = -(Z_MAX_LENGTH + 10);
   3940                line_to_z(zPosition);
   3941                //st_synchronize();
   3942                while (blocks_queued())
   3943                {
   3944                  IWDG_ReloadCounter();
   3945                  delay(10);//.
   3946                }
   3947                // Tell the planner where we ended up - Get this from the stepper handler
   3948                zPosition = st_get_position_mm(Z_AXIS);
   3949                plan_set_position(current_position[X_AXIS], current_position[Y_AXIS], zPosition, current_position[E_AXIS]);
   3950          
   3951                // move up the retract distance
   3952                zPosition += home_bump_mm(Z_AXIS);
   3953                line_to_z(zPosition);
   3954                //st_synchronize();
   3955                while (blocks_queued())
   3956                {
   3957                  IWDG_ReloadCounter();
   3958                  delay(10);//.
   3959                }
   3960          
   3961                endstops_hit_on_purpose(); // clear endstop hit flags
   3962                // move back down slowly to find bed
   3963                set_homing_bump_feedrate(Z_AXIS);
   3964          
   3965                zPosition -= home_bump_mm(Z_AXIS) * 2;
   3966                line_to_z(zPosition);
   3967                //st_synchronize();
   3968                while (blocks_queued())
   3969                {
   3970                  IWDG_ReloadCounter();
   3971                  delay(10);//.
   3972                }
   3973                endstops_hit_on_purpose(); // clear endstop hit flags
   3974          
   3975                // Get the current stepper position after bumping an endstop
   3976                current_position[Z_AXIS] = st_get_position_mm(Z_AXIS);
   3977                sync_plan_position();
   3978          
   3979                  //if (marlin_debug_flags & DEBUG_LEVELING) 
   3980                  {
   3981                    print_xyz("run_z_probe > current_position", current_position);
   3982                  }
   3983            }
   3984          
   3985          /**
   3986               * G30: Do a single Z probe at the current XY
   3987               */
   3988              void gcode_G30() {
   3989                //deploy_z_probe(); // Engage Z Servo endstop if available
   3990          
   3991                st_synchronize();
   3992                // TODO: clear the leveling matrix or the planner will be set incorrectly
   3993                setup_for_endstop_move();
   3994          
   3995                feedrate = homing_feedrate[Z_AXIS];
   3996          
   3997                run_z_probe();
   3998                SERIAL_PROTOCOLPGM("Bed X: ");
   3999                SERIAL_PROTOCOL(current_position[X_AXIS] + 0.0001);
   4000                SERIAL_PROTOCOLPGM(" Y: ");
   4001                SERIAL_PROTOCOL(current_position[Y_AXIS] + 0.0001);
   4002                SERIAL_PROTOCOLPGM(" Z: ");
   4003                SERIAL_PROTOCOL(current_position[Z_AXIS] + 0.0001);
   4004                SERIAL_EOL;
   4005          
   4006                //clean_up_after_endstop_move();
   4007                //stow_z_probe(false); // Retract Z Servo endstop if available
   4008              }
   4009          #endif
   4010          /**
   4011           * G92: Set current position to given X Y Z E
   4012           */
   4013          inline void gcode_G92() {
   4014            if (!code_seen(axis_codes[E_AXIS]))
   4015              st_synchronize();
   4016          
   4017            bool didXYZ = false;
   4018            for (int i = 0; i < NUM_AXIS; i++) {
   4019              if (code_seen(axis_codes[i])) {
   4020                float v = current_position[i] = code_value();
   4021                if (i == E_AXIS)
   4022                  plan_set_e_position(v);
   4023                else
   4024                  didXYZ = true;
   4025              }
   4026            }
   4027            if (didXYZ) {
   4028              #if ENABLED(DELTA) || ENABLED(SCARA)
   4029                sync_plan_position_delta();
   4030              #else
   4031                sync_plan_position();
   4032              #endif
   4033            }
   4034          }
   4035          
   4036          #if ENABLED(ULTIPANEL)
   4037          
   4038            /**
   4039             * M0: // M0 - Unconditional stop - Wait for user button press on LCD
   4040             * M1: // M1 - Conditional stop - Wait for user button press on LCD
   4041             */
   4042            inline void gcode_M0_M1() {
   4043              char* args = current_command_args;
   4044          
   4045              millis_t codenum = 0;
   4046              bool hasP = false, hasS = false;
   4047              if (code_seen('P')) {
   4048                codenum = code_value_short(); // milliseconds to wait
   4049                hasP = codenum > 0;
   4050              }
   4051              if (code_seen('S')) {
   4052                codenum = code_value() * 1000; // seconds to wait
   4053                hasS = codenum > 0;
   4054              }
   4055          
   4056              if (!hasP && !hasS && *args != '\0')
   4057                lcd_setstatus(args, true);
   4058              else {
   4059                LCD_MESSAGEPGM(MSG_USERWAIT);
   4060                #if ENABLED(LCD_PROGRESS_BAR) && PROGRESS_MSG_EXPIRE > 0
   4061                  dontExpireStatus();
   4062                #endif
   4063              }
   4064          
   4065              lcd_ignore_click();
   4066              st_synchronize();
   4067              refresh_cmd_timeout();
   4068              if (codenum > 0) {
   4069                codenum += previous_cmd_ms;  // wait until this time for a click
   4070                while (millis() < codenum && !lcd_clicked()) idle();
   4071                lcd_ignore_click(false);
   4072              }
   4073              else {
   4074                if (!lcd_detected()) return;
   4075                while (!lcd_clicked()) idle();
   4076              }
   4077              if (IS_SD_PRINTING)
   4078                LCD_MESSAGEPGM(MSG_RESUMING);
   4079              else
   4080                LCD_MESSAGEPGM(WELCOME_MSG);
   4081            }
   4082          
   4083          #endif // ULTIPANEL
   4084          
   4085          /**
   4086           * M17: Enable power on all stepper motors
   4087           */
   4088          inline void gcode_M17() {
   4089            //LCD_MESSAGEPGM(MSG_NO_MOVE);
   4090            enable_all_steppers();
   4091          }
   4092          
   4093          #if ENABLED(SDSUPPORT)
   4094          
   4095            /**
   4096             * M20: List SD card to serial output
   4097             */
   4098            inline void gcode_M20() {
   4099              SERIAL_PROTOCOLLNPGM(MSG_BEGIN_FILE_LIST);
   4100              card.ls();
   4101              SERIAL_PROTOCOLLNPGM(MSG_END_FILE_LIST);
   4102            }
   4103          
   4104            /**
   4105             * M21: Init SD Card
   4106             */
   4107            inline void gcode_M21() {
   4108              card.initsd();
   4109              if (card.cardOK!=true) card.initsd();
   4110            }
   4111          
   4112            /**
   4113             * M22: Release SD Card
   4114             */
   4115            inline void gcode_M22() {
   4116              card.release();
   4117            }
   4118          
   4119            /**
   4120             * M23: Select a file
   4121             */
   4122            inline void gcode_M23() {
   4123              card.openFile(current_command_args, true);
   4124            }
   4125          
   4126            /**
   4127             * M24: Start SD Print
   4128             */
   4129            inline void gcode_M24() {
   4130          
   4131              card.startFileprint();
   4132              print_job_start_ms = millis();
   4133            }
   4134          
   4135            /**
   4136             * M25: Pause SD Print
   4137             */
   4138            inline void gcode_M25() {
   4139              card.pauseSDPrint();
   4140            }
   4141          
   4142            /**
   4143             * M26: Set SD Card file index
   4144             */
   4145            inline void gcode_M26() {
   4146              if (card.cardOK && code_seen('S'))
   4147                card.setIndex(code_value_short());
   4148            }
   4149          
   4150            /**
   4151             * M27: Get SD Card status
   4152             */
   4153            inline void gcode_M27() {
   4154              card.getStatus();
   4155            }
   4156          
   4157            /**
   4158             * M28: Start SD Write
   4159             */
   4160            inline void gcode_M28() {
   4161              card.openFile(current_command_args, false);
   4162            }
   4163          
   4164            /**
   4165             * M29: Stop SD Write
   4166             * Processed in write to file routine above
   4167             */
   4168            inline void gcode_M29() {
   4169              // card.saving = false;
   4170            }
   4171          
   4172            /**
   4173             * M30 <filename>: Delete SD Card file
   4174             */
   4175            inline void gcode_M30() {
   4176              if (card.cardOK) {
   4177                //card.closefile();
   4178                card.removeFile(current_command_args);
   4179              }
   4180            }
   4181          
   4182          #endif //SDSUPPORT
   4183          
   4184          /**
   4185           * M31: Get the time since the start of SD Print (or last M109)
   4186           */
   4187          inline void gcode_M31() {
   4188            print_job_stop_ms = millis();
   4189            millis_t t = (print_job_stop_ms - print_job_start_ms) / 1000;
   4190            int min = t / 60, sec = t % 60;
   4191            char time[30];
   4192            sprintf(time, PSTR("%i min, %i sec"), min, sec);
   4193            SERIAL_ECHO_START;
   4194            SERIAL_ECHOLN(time);
   4195            //lcd_setstatus(time);
   4196            autotempShutdown();
   4197          }
   4198          
   4199          #if ENABLED(SDSUPPORT)
   4200          
   4201            /**
   4202             * M32: Select file and start SD Print
   4203             */
   4204            inline void gcode_M32() {
   4205              if (sdprinting)
   4206                st_synchronize();
   4207          
   4208              char* namestartpos = strchr(current_command_args, '!');  // Find ! to indicate filename string start.
   4209              if (!namestartpos)
   4210                namestartpos = current_command_args; // Default name position, 4 letters after the M
   4211              else
   4212                namestartpos++; //to skip the '!'
   4213          
   4214              bool call_procedure = code_seen('P') && (seen_pointer < namestartpos);
   4215          
   4216              if (card.cardOK) {
   4217                card.openFile(namestartpos, true, !call_procedure);
   4218          
   4219                if (code_seen('S') && seen_pointer < namestartpos) // "S" (must occur _before_ the filename!)
   4220                  card.setIndex(code_value_short());
   4221          
   4222                card.startFileprint();
   4223                if (!call_procedure)
   4224                  print_job_start_ms = millis(); //procedure calls count as normal print time.
   4225              }
   4226            }
   4227          
   4228            #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   4229          
   4230              /**
   4231               * M33: Get the long full path of a file or folder
   4232               *
   4233               * Parameters:
   4234               *   <dospath> Case-insensitive DOS-style path to a file or folder
   4235               *
   4236               * Example:
   4237               *   M33 miscel~1/armchair/armcha~1.gco
   4238               *
   4239               * Output:
   4240               *   /Miscellaneous/Armchair/Armchair.gcode
   4241               */
   4242              inline void gcode_M33() {
   4243                card.printLongPath(current_command_args);
   4244              }
   4245          
   4246            #endif
   4247          
   4248            /**
   4249             * M928: Start SD Write
   4250             */
   4251            inline void gcode_M928() {
   4252              card.openLogFile(current_command_args);
   4253            }
   4254          
   4255          #endif // SDSUPPORT
   4256          
   4257          /**
   4258           * M42: Change pin status via GCode
   4259           */
   4260          inline void gcode_M42() {
   4261          /* //yongzong remove support for M42
   4262            if (code_seen('S')) {
   4263              int pin_status = code_value_short(),
   4264                  pin_number = LED_PIN;
   4265          
   4266              if (code_seen('P') && pin_status >= 0 && pin_status <= 255)
   4267                pin_number = code_value_short();
   4268          
   4269              for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
   4270                if (sensitive_pins[i] == pin_number) {
   4271                  pin_number = -1;
   4272                  break;
   4273                }
   4274              }
   4275          
   4276              #if HAS_FAN
   4277                if (pin_number == FAN_PIN) fanSpeed = pin_status;
   4278              #endif
   4279          
   4280              if (pin_number > -1) {
   4281                pinMode(pin_number, OUTPUT);
   4282                digitalWrite(pin_number, pin_status);
   4283                analogWrite(pin_number, pin_status);
   4284              }
   4285            } // code_seen('S')
   4286          */
   4287          }
   4288          
   4289          #if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   4290          
   4291            // This is redundant since the SanityCheck.h already checks for a valid Z_MIN_PROBE_PIN, but here for clarity.
   4292            #if ENABLED(Z_MIN_PROBE_ENDSTOP)
   4293              #if !HAS_Z_PROBE
   4294                #error You must define Z_MIN_PROBE_PIN to enable Z probe repeatability calculation.
   4295              #endif
   4296            #elif !HAS_Z_MIN
   4297              #error You must define Z_MIN_PIN to enable Z probe repeatability calculation.
   4298            #endif
   4299          
   4300            /**
   4301             * M48: Z probe repeatability measurement function.
   4302             *
   4303             * Usage:
   4304             *   M48 <P#> <X#> <Y#> <V#> <E> <L#>
   4305             *     P = Number of sampled points (4-50, default 10)
   4306             *     X = Sample X position
   4307             *     Y = Sample Y position
   4308             *     V = Verbose level (0-4, default=1)
   4309             *     E = Engage Z probe for each reading
   4310             *     L = Number of legs of movement before probe
   4311             *
   4312             * This function assumes the bed has been homed.  Specifically, that a G28 command
   4313             * as been issued prior to invoking the M48 Z probe repeatability measurement function.
   4314             * Any information generated by a prior G29 Bed leveling command will be lost and need to be
   4315             * regenerated.
   4316             */
   4317            inline void gcode_M48() {
   4318          
   4319              double sum = 0.0, mean = 0.0, sigma = 0.0, sample_set[50];
   4320              uint8_t verbose_level = 1, n_samples = 10, n_legs = 0;
   4321          
   4322              if (code_seen('V')) {
   4323                verbose_level = code_value_short();
   4324                if (verbose_level < 0 || verbose_level > 4) {
   4325                  SERIAL_PROTOCOLPGM("?Verbose Level not plausible (0-4).\n");
   4326                  return;
   4327                }
   4328              }
   4329          
   4330              if (verbose_level > 0)
   4331                SERIAL_PROTOCOLPGM("M48 Z-Probe Repeatability test\n");
   4332          
   4333              if (code_seen('P')) {
   4334                n_samples = code_value_short();
   4335                if (n_samples < 4 || n_samples > 50) {
   4336                  SERIAL_PROTOCOLPGM("?Sample size not plausible (4-50).\n");
   4337                  return;
   4338                }
   4339              }
   4340          
   4341              double X_current = st_get_position_mm(X_AXIS),
   4342                     Y_current = st_get_position_mm(Y_AXIS),
   4343                     Z_current = st_get_position_mm(Z_AXIS),
   4344                     E_current = st_get_position_mm(E_AXIS),
   4345                     X_probe_location = X_current, Y_probe_location = Y_current,
   4346                     Z_start_location = Z_current + Z_RAISE_BEFORE_PROBING;
   4347          
   4348              bool deploy_probe_for_each_reading = code_seen('E');
   4349          
   4350              if (code_seen('X')) {
   4351                X_probe_location = code_value() - X_PROBE_OFFSET_FROM_EXTRUDER;
   4352                if (X_probe_location < X_MIN_POS || X_probe_location > X_MAX_POS) {
   4353                  out_of_range_error(PSTR("X"));
   4354                  return;
   4355                }
   4356              }
   4357          
   4358              if (code_seen('Y')) {
   4359                Y_probe_location = code_value() -  Y_PROBE_OFFSET_FROM_EXTRUDER;
   4360                if (Y_probe_location < Y_MIN_POS || Y_probe_location > Y_MAX_POS) {
   4361                  out_of_range_error(PSTR("Y"));
   4362                  return;
   4363                }
   4364              }
   4365          
   4366              if (code_seen('L')) {
   4367                n_legs = code_value_short();
   4368                if (n_legs == 1) n_legs = 2;
   4369                if (n_legs < 0 || n_legs > 15) {
   4370                  SERIAL_PROTOCOLPGM("?Number of legs in movement not plausible (0-15).\n");
   4371                  return;
   4372                }
   4373              }
   4374          
   4375              //
   4376              // Do all the preliminary setup work.   First raise the Z probe.
   4377              //
   4378          
   4379              st_synchronize();
   4380              plan_bed_level_matrix.set_to_identity();
   4381              plan_buffer_line(X_current, Y_current, Z_start_location, E_current, homing_feedrate[Z_AXIS] / 60, active_extruder);
   4382              st_synchronize();
   4383          
   4384              //
   4385              // Now get everything to the specified probe point So we can safely do a probe to
   4386              // get us close to the bed.  If the Z-Axis is far from the bed, we don't want to
   4387              // use that as a starting point for each probe.
   4388              //
   4389              if (verbose_level > 2)
   4390                SERIAL_PROTOCOLPGM("Positioning the probe...\n");
   4391          
   4392              plan_buffer_line(X_probe_location, Y_probe_location, Z_start_location,
   4393                               E_current,
   4394                               homing_feedrate[X_AXIS] / 60,
   4395                               active_extruder);
   4396              st_synchronize();
   4397          
   4398              current_position[X_AXIS] = X_current = st_get_position_mm(X_AXIS);
   4399              current_position[Y_AXIS] = Y_current = st_get_position_mm(Y_AXIS);
   4400              current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
   4401              current_position[E_AXIS] = E_current = st_get_position_mm(E_AXIS);
   4402          
   4403              //
   4404              // OK, do the initial probe to get us close to the bed.
   4405              // Then retrace the right amount and use that in subsequent probes
   4406              //
   4407          
   4408              deploy_z_probe();
   4409          
   4410              setup_for_endstop_move();
   4411              run_z_probe();
   4412          
   4413              current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
   4414              Z_start_location = st_get_position_mm(Z_AXIS) + Z_RAISE_BEFORE_PROBING;
   4415          
   4416              plan_buffer_line(X_probe_location, Y_probe_location, Z_start_location,
   4417                               E_current,
   4418                               homing_feedrate[X_AXIS] / 60,
   4419                               active_extruder);
   4420              st_synchronize();
   4421              current_position[Z_AXIS] = Z_current = st_get_position_mm(Z_AXIS);
   4422          
   4423              if (deploy_probe_for_each_reading) stow_z_probe();
   4424          
   4425              for (uint8_t n = 0; n < n_samples; n++) {
   4426                // Make sure we are at the probe location
   4427                do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position
   4428          
   4429                if (n_legs) {
   4430                  millis_t ms = millis();
   4431                  double radius = ms % (X_MAX_LENGTH / 4),       // limit how far out to go
   4432                         theta = RADIANS(ms % 360L);
   4433                  float dir = (ms & 0x0001) ? 1 : -1;            // clockwise or counter clockwise
   4434          
   4435                  //SERIAL_ECHOPAIR("starting radius: ",radius);
   4436                  //SERIAL_ECHOPAIR("   theta: ",theta);
   4437                  //SERIAL_ECHOPAIR("   direction: ",dir);
   4438                  //SERIAL_EOL;
   4439          
   4440                  for (uint8_t l = 0; l < n_legs - 1; l++) {
   4441                    ms = millis();
   4442                    theta += RADIANS(dir * (ms % 20L));
   4443                    radius += (ms % 10L) - 5L;
   4444                    if (radius < 0.0) radius = -radius;
   4445          
   4446                    X_current = X_probe_location + cos(theta) * radius;
   4447                    X_current = constrain(X_current, X_MIN_POS, X_MAX_POS);
   4448                    Y_current = Y_probe_location + sin(theta) * radius;
   4449                    Y_current = constrain(Y_current, Y_MIN_POS, Y_MAX_POS);
   4450          
   4451                    if (verbose_level > 3) {
   4452                      SERIAL_ECHOPAIR("x: ", X_current);
   4453                      SERIAL_ECHOPAIR("y: ", Y_current);
   4454                      SERIAL_EOL;
   4455                    }
   4456          
   4457                    do_blocking_move_to(X_current, Y_current, Z_current); // this also updates current_position
   4458          
   4459                  } // n_legs loop
   4460          
   4461                  // Go back to the probe location
   4462                  do_blocking_move_to(X_probe_location, Y_probe_location, Z_start_location); // this also updates current_position
   4463          
   4464                } // n_legs
   4465          
   4466                if (deploy_probe_for_each_reading)  {
   4467                  deploy_z_probe();
   4468                  delay(1000);
   4469                }
   4470          
   4471                setup_for_endstop_move();
   4472                run_z_probe();
   4473          
   4474                sample_set[n] = current_position[Z_AXIS];
   4475          
   4476                //
   4477                // Get the current mean for the data points we have so far
   4478                //
   4479                sum = 0.0;
   4480                for (uint8_t j = 0; j <= n; j++) sum += sample_set[j];
   4481                mean = sum / (n + 1);
   4482          
   4483                //
   4484                // Now, use that mean to calculate the standard deviation for the
   4485                // data points we have so far
   4486                //
   4487                sum = 0.0;
   4488                for (uint8_t j = 0; j <= n; j++) {
   4489                  float ss = sample_set[j] - mean;
   4490                  sum += ss * ss;
   4491                }
   4492                sigma = sqrt(sum / (n + 1));
   4493          
   4494                if (verbose_level > 1) {
   4495                  SERIAL_PROTOCOL(n + 1);
   4496                  SERIAL_PROTOCOLPGM(" of ");
   4497                  SERIAL_PROTOCOL((int)n_samples);
   4498                  SERIAL_PROTOCOLPGM("   z: ");
   4499                  SERIAL_PROTOCOL_F(current_position[Z_AXIS], 6);
   4500                  if (verbose_level > 2) {
   4501                    SERIAL_PROTOCOLPGM(" mean: ");
   4502                    SERIAL_PROTOCOL_F(mean, 6);
   4503                    SERIAL_PROTOCOLPGM("   sigma: ");
   4504                    SERIAL_PROTOCOL_F(sigma, 6);
   4505                  }
   4506                }
   4507          
   4508                if (verbose_level > 0) SERIAL_EOL;
   4509          
   4510                plan_buffer_line(X_probe_location, Y_probe_location, Z_start_location, current_position[E_AXIS], homing_feedrate[Z_AXIS] / 60, active_extruder);
   4511                st_synchronize();
   4512          
   4513                // Stow between
   4514                if (deploy_probe_for_each_reading) {
   4515                  stow_z_probe();
   4516                  delay(1000);
   4517                }
   4518              }
   4519          
   4520              // Stow after
   4521              if (!deploy_probe_for_each_reading) {
   4522                stow_z_probe();
   4523                delay(1000);
   4524              }
   4525          
   4526              clean_up_after_endstop_move();
   4527          
   4528              if (verbose_level > 0) {
   4529                SERIAL_PROTOCOLPGM("Mean: ");
   4530                SERIAL_PROTOCOL_F(mean, 6);
   4531                SERIAL_EOL;
   4532              }
   4533          
   4534              SERIAL_PROTOCOLPGM("Standard Deviation: ");
   4535              SERIAL_PROTOCOL_F(sigma, 6);
   4536              SERIAL_EOL; SERIAL_EOL;
   4537            }
   4538          
   4539          #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST
   4540          
   4541          /**
   4542           * M104: Set hot end temperature
   4543           */
   4544          inline void gcode_M104() {
   4545            if (setTargetedHotend(104)) return;
   4546            if (marlin_debug_flags & DEBUG_DRYRUN) return;
   4547          
   4548            if (code_seen('S')) {
   4549              float temp = code_value();
   4550              setTargetHotend(temp, target_extruder);
   4551              #if ENABLED(DUAL_X_CARRIAGE)
   4552                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   4553                  setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);
   4554              #endif
   4555            }
   4556          }
   4557          
   4558          /**
   4559           * M105: Read hot end and bed temperature
   4560           */
   4561          inline void gcode_M105() {
   4562            if (setTargetedHotend(105)) return;
   4563          
   4564            #if HAS_TEMP_0 || HAS_TEMP_BED || ENABLED(HEATER_0_USES_MAX6675)
   4565              //delay(10);
   4566              SERIAL_PROTOCOLPGM(MSG_OK);
   4567          
   4568              #if ENABLED(ADVANCED_OK)
   4569              SERIAL_PROTOCOLPGM(" N"); SERIAL_PROTOCOL(gcode_LastN);
   4570              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - movesplanned() - 1));
   4571              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
   4572              #endif
   4573          
   4574              #if HAS_TEMP_0 || ENABLED(HEATER_0_USES_MAX6675)
   4575                SERIAL_PROTOCOLPGM(" T:");
   4576                SERIAL_PROTOCOL_F(degHotend(target_extruder), 1);
   4577                SERIAL_PROTOCOLPGM(" /");
   4578                SERIAL_PROTOCOL_F(degTargetHotend(target_extruder), 1);
   4579              #endif
   4580              #if HAS_TEMP_BED
   4581                SERIAL_PROTOCOLPGM(" B:");
   4582                SERIAL_PROTOCOL_F(degBed(), 1);
   4583                SERIAL_PROTOCOLPGM(" /");
   4584                SERIAL_PROTOCOL_F(degTargetBed(), 1);
   4585              #endif
   4586              for (int8_t e = 0; e < EXTRUDERS; ++e) {
   4587                SERIAL_PROTOCOLPGM(" T");
   4588                SERIAL_PROTOCOL(e);
   4589                SERIAL_PROTOCOLCHAR(':');
   4590                SERIAL_PROTOCOL_F(degHotend(e), 1);
   4591                SERIAL_PROTOCOLPGM(" /");
   4592                SERIAL_PROTOCOL_F(degTargetHotend(e), 1);
   4593              }
   4594            #else // !HAS_TEMP_0 && !HAS_TEMP_BED
   4595              SERIAL_ERROR_START;
   4596              SERIAL_ERRORLNPGM(MSG_ERR_NO_THERMISTORS);
   4597            #endif
   4598          
   4599            SERIAL_PROTOCOLPGM(" @:");
   4600            #ifdef EXTRUDER_WATTS
   4601              SERIAL_PROTOCOL((EXTRUDER_WATTS * getHeaterPower(target_extruder)) / 127);
   4602              SERIAL_PROTOCOLCHAR('W');
   4603            #else
   4604              SERIAL_PROTOCOL(getHeaterPower(target_extruder));
   4605            #endif
   4606          
   4607            SERIAL_PROTOCOLPGM(" B@:");
   4608            #ifdef BED_WATTS
   4609              SERIAL_PROTOCOL((BED_WATTS * getHeaterPower(-1)) / 127);
   4610              SERIAL_PROTOCOLCHAR('W');
   4611            #else
   4612              SERIAL_PROTOCOL(getHeaterPower(-1));
   4613            #endif
   4614          
   4615            #if ENABLED(SHOW_TEMP_ADC_VALUES)
   4616              #if HAS_TEMP_BED
   4617                SERIAL_PROTOCOLPGM("    ADC B:");
   4618                SERIAL_PROTOCOL_F(degBed(), 1);
   4619                SERIAL_PROTOCOLPGM("C->");
   4620                SERIAL_PROTOCOL_F(rawBedTemp() / OVERSAMPLENR, 0);
   4621              #endif
   4622              for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder) {
   4623                SERIAL_PROTOCOLPGM("  T");
   4624                SERIAL_PROTOCOL(cur_extruder);
   4625                SERIAL_PROTOCOLCHAR(':');
   4626                SERIAL_PROTOCOL_F(degHotend(cur_extruder), 1);
   4627                SERIAL_PROTOCOLPGM("C->");
   4628                SERIAL_PROTOCOL_F(rawHotendTemp(cur_extruder) / OVERSAMPLENR, 0);
   4629              }
   4630            #endif
   4631          
   4632            SERIAL_EOL;
   4633          }
   4634          
   4635          #if HAS_FAN
   4636          
   4637            /**
   4638             * M106: Set Fan Speed
   4639             */
   4640            inline void gcode_M106() { fanSpeed = code_seen('S') ? constrain(code_value_short(), 0, 255) : 255; }
   4641          
   4642            /**
   4643             * M107: Fan Off
   4644             */
   4645            inline void gcode_M107() { fanSpeed = 0; }
   4646          
   4647          #endif // HAS_FAN
   4648          
   4649          /**
   4650           * M109: Wait for extruder(s) to reach temperature
   4651           */
   4652          inline void gcode_M109() {
   4653            if (setTargetedHotend(109)) return;
   4654            if (marlin_debug_flags & DEBUG_DRYRUN) return;
   4655          
   4656            extern void StartBuild();
   4657            buffer_status=true;
   4658            StartBuild();
   4659          
   4660            //LCD_MESSAGEPGM(MSG_HEATING);
   4661          
   4662            no_wait_for_cooling = code_seen('S');
   4663            if (no_wait_for_cooling || code_seen('R')) {
   4664              float temp = code_value();
   4665              setTargetHotend(temp, target_extruder);
   4666              #if ENABLED(DUAL_X_CARRIAGE)
   4667                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && target_extruder == 0)
   4668                  setTargetHotend1(temp == 0.0 ? 0.0 : temp + duplicate_extruder_temp_offset);
   4669              #endif
   4670            }
   4671          
   4672            #if ENABLED(AUTOTEMP)
   4673              autotemp_enabled = code_seen('F');
   4674              if (autotemp_enabled) autotemp_factor = code_value();
   4675              if (code_seen('S')) autotemp_min = code_value();
   4676              if (code_seen('B')) autotemp_max = code_value();
   4677            #endif
   4678          
   4679            millis_t temp_ms = millis();
   4680          
   4681            /* See if we are heating up or cooling down */
   4682            target_direction = isHeatingHotend(target_extruder); // true if heating, false if cooling
   4683          
   4684            uint16_t timeout=0;
   4685            cancel_heatup = false;
   4686          
   4687            #ifdef TEMP_RESIDENCY_TIME
   4688              long residency_start_ms = -1;
   4689              /* continue to loop until we have reached the target temp
   4690                _and_ until TEMP_RESIDENCY_TIME hasn't passed since we reached it */
   4691              while ((!cancel_heatup) && ((residency_start_ms == -1) ||
   4692                                          (residency_start_ms >= 0 && (((unsigned int)(millis() - residency_start_ms)) < (TEMP_RESIDENCY_TIME * 1000UL)))))
   4693            #else
   4694              while ((!cancel_heatup) && (target_direction ? (isHeatingHotend(target_extruder)) : (isCoolingHotend(target_extruder) && (no_wait_for_cooling == false))))
   4695            #endif //TEMP_RESIDENCY_TIME
   4696          
   4697            { // while loop
   4698              if (millis() > temp_ms + 1000UL) { //Print temp & remaining time every 1s while waiting
   4699                if (degTargetHotend(target_extruder)==0) cancel_heatup=true;
   4700                SERIAL_PROTOCOLPGM("T:");
   4701                SERIAL_PROTOCOL_F(degHotend(target_extruder), 1);
   4702                SERIAL_PROTOCOLPGM(" E:");
   4703                SERIAL_PROTOCOL((int)target_extruder);
   4704          
   4705                #ifdef TEMP_RESIDENCY_TIME
   4706                  SERIAL_PROTOCOLPGM(" W:");
   4707                  if (residency_start_ms > -1) {
   4708                    temp_ms = ((TEMP_RESIDENCY_TIME * 1000UL) - (millis() - residency_start_ms)) / 1000UL;
   4709                    SERIAL_PROTOCOLLN(temp_ms);
   4710                  }
   4711                  else {
   4712                    SERIAL_PROTOCOLLNPGM("?");
   4713                  }
   4714                #else
   4715                  SERIAL_EOL;
   4716                #endif
   4717                temp_ms = millis();
   4718                if (timeout++>600) cancel_heatup=true;
   4719              }
   4720          
   4721              idle();
   4722              if (sdprint_cancel==true) break;
   4723          
   4724              #ifdef TEMP_RESIDENCY_TIME
   4725                // start/restart the TEMP_RESIDENCY_TIME timer whenever we reach target temp for the first time
   4726                // or when current temp falls outside the hysteresis after target temp was reached
   4727                if ((residency_start_ms == -1 &&  target_direction && (degHotend(target_extruder) >= (degTargetHotend(target_extruder) - TEMP_WINDOW))) ||
   4728                    (residency_start_ms == -1 && !target_direction && (degHotend(target_extruder) <= (degTargetHotend(target_extruder) + TEMP_WINDOW))) ||
   4729                    (residency_start_ms > -1 && labs(degHotend(target_extruder) - degTargetHotend(target_extruder)) > TEMP_HYSTERESIS) )
   4730                {
   4731                  residency_start_ms = millis();
   4732                }
   4733              #endif //TEMP_RESIDENCY_TIME
   4734            }
   4735          
   4736            //LCD_MESSAGEPGM(MSG_HEATING_COMPLETE);
   4737            refresh_cmd_timeout();
   4738            print_job_start_ms = previous_cmd_ms;
   4739          }
   4740          
   4741          #if HAS_TEMP_BED
   4742          
   4743            /**
   4744             * M190: Sxxx Wait for bed current temp to reach target temp. Waits only when heating
   4745             *       Rxxx Wait for bed current temp to reach target temp. Waits when heating and cooling
   4746             */
   4747            inline void gcode_M190() {
   4748              if (marlin_debug_flags & DEBUG_DRYRUN) return;
   4749          
   4750              //LCD_MESSAGEPGM(MSG_BED_HEATING);
   4751              no_wait_for_cooling = code_seen('S');
   4752              if (no_wait_for_cooling || code_seen('R'))
   4753                setTargetBed(code_value());
   4754          
   4755              millis_t temp_ms = millis();
   4756          
   4757              cancel_heatup = false;
   4758              target_direction = isHeatingBed(); // true if heating, false if cooling
   4759          
   4760              uint16_t timeout=0;
   4761              while ((target_direction && !cancel_heatup) ? isHeatingBed() : isCoolingBed() && !no_wait_for_cooling) {
   4762                millis_t ms = millis();
   4763                if (ms > temp_ms + 1000UL) { //Print Temp Reading every 1 second while heating up.
   4764                  temp_ms = ms;
   4765                  float tt = degHotend(active_extruder);
   4766                  SERIAL_PROTOCOLPGM("T:");
   4767                  SERIAL_PROTOCOL(tt);
   4768                  SERIAL_PROTOCOLPGM(" E:");
   4769                  SERIAL_PROTOCOL((int)active_extruder);
   4770                  SERIAL_PROTOCOLPGM(" B:");
   4771                  SERIAL_PROTOCOL_F(degBed(), 1);
   4772                  SERIAL_EOL;
   4773          
   4774                  if (degTargetBed()==0) cancel_heatup=true;
   4775                  if (timeout++>600) cancel_heatup=true;
   4776                }
   4777                idle();
   4778              }
   4779              //LCD_MESSAGEPGM(MSG_BED_DONE);
   4780              refresh_cmd_timeout();
   4781            }
   4782          
   4783          #endif // HAS_TEMP_BED
   4784          
   4785          /**
   4786           * M111: Set the debug level
   4787           */
   4788          inline void gcode_M111() {
   4789            marlin_debug_flags = code_seen('S') ? code_value_short() : DEBUG_INFO | DEBUG_COMMUNICATION;
   4790          
   4791            if (marlin_debug_flags & DEBUG_ECHO) {
   4792              SERIAL_ECHO_START;
   4793              SERIAL_ECHOLNPGM(MSG_DEBUG_ECHO);
   4794            }
   4795            // FOR MOMENT NOT ACTIVE
   4796            //if (marlin_debug_flags & DEBUG_INFO) SERIAL_ECHOLNPGM(MSG_DEBUG_INFO);
   4797            //if (marlin_debug_flags & DEBUG_ERRORS) SERIAL_ECHOLNPGM(MSG_DEBUG_ERRORS);
   4798            if (marlin_debug_flags & DEBUG_DRYRUN) {
   4799              SERIAL_ECHO_START;
   4800              SERIAL_ECHOLNPGM(MSG_DEBUG_DRYRUN);
   4801              disable_all_heaters();
   4802            }
   4803          
   4804            #if ENABLED(DEBUG_LEVELING_FEATURE)
   4805              if (marlin_debug_flags & DEBUG_LEVELING) {
   4806                SERIAL_ECHO_START;
   4807                SERIAL_ECHOLNPGM(MSG_DEBUG_LEVELING);
   4808              }
   4809            #endif
   4810          }
   4811          
   4812          /**
   4813           * M112: Emergency Stop
   4814           */
   4815          inline void gcode_M112() { kill(PSTR(MSG_KILLED)); }
   4816          
   4817          #if ENABLED(BARICUDA)
   4818          
   4819            #if HAS_HEATER_1
   4820              /**
   4821               * M126: Heater 1 valve open
   4822               */
   4823              inline void gcode_M126() { ValvePressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }
   4824              /**
   4825               * M127: Heater 1 valve close
   4826               */
   4827              inline void gcode_M127() { ValvePressure = 0; }
   4828            #endif
   4829          
   4830            #if HAS_HEATER_2
   4831              /**
   4832               * M128: Heater 2 valve open
   4833               */
   4834              inline void gcode_M128() { EtoPPressure = code_seen('S') ? constrain(code_value(), 0, 255) : 255; }
   4835              /**
   4836               * M129: Heater 2 valve close
   4837               */
   4838              inline void gcode_M129() { EtoPPressure = 0; }
   4839            #endif
   4840          
   4841          #endif //BARICUDA
   4842          
   4843          /**
   4844           * M140: Set bed temperature
   4845           */
   4846          inline void gcode_M140() {
   4847            if (marlin_debug_flags & DEBUG_DRYRUN) return;
   4848            if (code_seen('S')) setTargetBed(code_value());
   4849          }
   4850          
   4851          #if ENABLED(ULTIPANEL)
   4852          
   4853            /**
   4854             * M145: Set the heatup state for a material in the LCD menu
   4855             *   S<material> (0=PLA, 1=ABS)
   4856             *   H<hotend temp>
   4857             *   B<bed temp>
   4858             *   F<fan speed>
   4859             */
   4860            inline void gcode_M145() {
   4861              uint8_t material = code_seen('S') ? code_value_short() : 0;
   4862              if (material < 0 || material > 1) {
   4863                SERIAL_ERROR_START;
   4864                SERIAL_ERRORLNPGM(MSG_ERR_MATERIAL_INDEX);
   4865              }
   4866              else {
   4867                int v;
   4868                switch (material) {
   4869                  case 0:
   4870                    if (code_seen('H')) {
   4871                      v = code_value_short();
   4872                      plaPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
   4873                    }
   4874                    if (code_seen('F')) {
   4875                      v = code_value_short();
   4876                      plaPreheatFanSpeed = constrain(v, 0, 255);
   4877                    }
   4878                    #if TEMP_SENSOR_BED != 0
   4879                      if (code_seen('B')) {
   4880                        v = code_value_short();
   4881                        plaPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   4882                      }
   4883                    #endif
   4884                    break;
   4885                  case 1:
   4886                    if (code_seen('H')) {
   4887                      v = code_value_short();
   4888                      absPreheatHotendTemp = constrain(v, EXTRUDE_MINTEMP, HEATER_0_MAXTEMP - 15);
   4889                    }
   4890                    if (code_seen('F')) {
   4891                      v = code_value_short();
   4892                      absPreheatFanSpeed = constrain(v, 0, 255);
   4893                    }
   4894                    #if TEMP_SENSOR_BED != 0
   4895                      if (code_seen('B')) {
   4896                        v = code_value_short();
   4897                        absPreheatHPBTemp = constrain(v, BED_MINTEMP, BED_MAXTEMP - 15);
   4898                      }
   4899                    #endif
   4900                    break;
   4901                }
   4902              }
   4903            }
   4904          
   4905          #endif
   4906          
   4907          #if HAS_POWER_SWITCH
   4908          
   4909            /**
   4910             * M80: Turn on Power Supply
   4911             */
   4912            inline void gcode_M80() {
   4913              OUT_WRITE(PS_ON_PIN, PS_ON_AWAKE); //GND
   4914          
   4915              // If you have a switch on suicide pin, this is useful
   4916              // if you want to start another print with suicide feature after
   4917              // a print without suicide...
   4918              #if HAS_SUICIDE
   4919                OUT_WRITE(SUICIDE_PIN, HIGH);
   4920              #endif
   4921          
   4922              #if ENABLED(ULTIPANEL)
   4923                powersupply = true;
   4924                LCD_MESSAGEPGM(WELCOME_MSG);
   4925                wifi_update();
   4926              #endif
   4927            }
   4928          
   4929          #endif // HAS_POWER_SWITCH
   4930          
   4931          /**
   4932           * M81: Turn off Power, including Power Supply, if there is one.
   4933           *
   4934           *      This code should ALWAYS be available for EMERGENCY SHUTDOWN!
   4935           */
   4936          inline void gcode_M81() {
   4937            disable_all_heaters();
   4938            finishAndDisableSteppers();
   4939            fanSpeed = 0;
   4940            delay(1000); // Wait 1 second before switching off
   4941            #if HAS_SUICIDE
   4942              st_synchronize();
   4943              suicide();
   4944            #elif HAS_POWER_SWITCH
   4945              OUT_WRITE(PS_ON_PIN, PS_ON_ASLEEP);
   4946            #endif
   4947            #if ENABLED(ULTIPANEL)
   4948              #if HAS_POWER_SWITCH
   4949                powersupply = false;
   4950              #endif
   4951              LCD_MESSAGEPGM(MACHINE_NAME " " MSG_OFF ".");
   4952              wifi_update();
   4953            #endif
   4954          }
   4955          
   4956          
   4957          /**
   4958           * M82: Set E codes absolute (default)
   4959           */
   4960          inline void gcode_M82() { axis_relative_modes[E_AXIS] = false; }
   4961          
   4962          /**
   4963           * M83: Set E codes relative while in Absolute Coordinates (G90) mode
   4964           */
   4965          inline void gcode_M83() { axis_relative_modes[E_AXIS] = true; }
   4966          
   4967          /**
   4968           * M18, M84: Disable all stepper motors
   4969           */
   4970          inline void gcode_M18_M84() {
   4971            if (code_seen('S')) {
   4972              stepper_inactive_time = code_value() * 1000;
   4973            }
   4974            else {
   4975              bool all_axis = !((code_seen(axis_codes[X_AXIS])) || (code_seen(axis_codes[Y_AXIS])) || (code_seen(axis_codes[Z_AXIS])) || (code_seen(axis_codes[E_AXIS])));
   4976              if (all_axis) {
   4977                finishAndDisableSteppers();
   4978          
   4979              }
   4980              else {
   4981                st_synchronize();
   4982                if (code_seen('X')) disable_x();
   4983                if (code_seen('Y')) disable_y();
   4984                if (code_seen('Z')) disable_z();
   4985                #if ((E0_ENABLE_PIN != X_ENABLE_PIN) && (E1_ENABLE_PIN != Y_ENABLE_PIN)) // Only enable on boards that have seperate ENABLE_PINS
   4986                  if (code_seen('E')) {
   4987                    disable_e0();
   4988                    disable_e1();
   4989                    disable_e2();
   4990                    disable_e3();
   4991                  }
   4992                #endif
   4993              }
   4994            }
   4995          }
   4996          
   4997          /**
   4998           * M85: Set inactivity shutdown timer with parameter S<seconds>. To disable set zero (default)
   4999           */
   5000          inline void gcode_M85() {
   5001            if (code_seen('S')) max_inactive_time = code_value() * 1000;
   5002          }
   5003          
   5004          /**
   5005           * M92: Set axis steps-per-unit for one or more axes, X, Y, Z, and E.
   5006           *      (Follows the same syntax as G92)
   5007           */
   5008          inline void gcode_M92() {
   5009            for (int8_t i = 0; i < NUM_AXIS; i++) {
   5010              if (code_seen(axis_codes[i])) {
   5011                if (i == E_AXIS) {
   5012                  float value = code_value();
   5013                  if (value < 20.0) {
   5014                    float factor = axis_steps_per_unit[i] / value; // increase e constants if M92 E14 is given for netfab.
   5015                    max_e_jerk *= factor;
   5016                    max_feedrate[i] *= factor;
   5017                    axis_steps_per_sqr_second[i] *= factor;
   5018                  }
   5019                  axis_steps_per_unit[i] = value;
   5020                }
   5021                else {
   5022                  axis_steps_per_unit[i] = code_value();
   5023                }
   5024              }
   5025            }
   5026          }
   5027          
   5028          /**
   5029           * M114: Output current position to serial port
   5030           */
   5031          void gcode_M114() {
   5032            SERIAL_PROTOCOLPGM("X:");
   5033            SERIAL_PROTOCOL(current_position[X_AXIS]);
   5034            SERIAL_PROTOCOLPGM(" Y:");
   5035            SERIAL_PROTOCOL(current_position[Y_AXIS]);
   5036            SERIAL_PROTOCOLPGM(" Z:");
   5037            SERIAL_PROTOCOL(current_position[Z_AXIS]);
   5038            SERIAL_PROTOCOLPGM(" E:");
   5039            SERIAL_PROTOCOL(current_position[E_AXIS]);
   5040          
   5041            SERIAL_PROTOCOLPGM(MSG_COUNT_X);
   5042            SERIAL_PROTOCOL(st_get_position_mm(X_AXIS));
   5043            SERIAL_PROTOCOLPGM(" Y:");
   5044            SERIAL_PROTOCOL(st_get_position_mm(Y_AXIS));
   5045            SERIAL_PROTOCOLPGM(" Z:");
   5046            SERIAL_PROTOCOL(st_get_position_mm(Z_AXIS));
   5047          
   5048            SERIAL_EOL;
   5049          
   5050            #if ENABLED(SCARA)
   5051              SERIAL_PROTOCOLPGM("SCARA Theta:");
   5052              SERIAL_PROTOCOL(delta[X_AXIS]);
   5053              SERIAL_PROTOCOLPGM("   Psi+Theta:");
   5054              SERIAL_PROTOCOL(delta[Y_AXIS]);
   5055              SERIAL_EOL;
   5056          
   5057              SERIAL_PROTOCOLPGM("SCARA Cal - Theta:");
   5058              SERIAL_PROTOCOL(delta[X_AXIS] + home_offset[X_AXIS]);
   5059              SERIAL_PROTOCOLPGM("   Psi+Theta (90):");
   5060              SERIAL_PROTOCOL(delta[Y_AXIS] - delta[X_AXIS] - 90 + home_offset[Y_AXIS]);
   5061              SERIAL_EOL;
   5062          
   5063              SERIAL_PROTOCOLPGM("SCARA step Cal - Theta:");
   5064              SERIAL_PROTOCOL(delta[X_AXIS] / 90 * axis_steps_per_unit[X_AXIS]);
   5065              SERIAL_PROTOCOLPGM("   Psi+Theta:");
   5066              SERIAL_PROTOCOL((delta[Y_AXIS] - delta[X_AXIS]) / 90 * axis_steps_per_unit[Y_AXIS]);
   5067              SERIAL_EOL; SERIAL_EOL;
   5068            #endif
   5069          }
   5070          
   5071          /**
   5072           * M115: Capabilities string
   5073           */
   5074          inline void gcode_M115() {
   5075            if (code_seen('S'))
   5076            {
   5077                model=code_value_short();
   5078                port_init();
   5079            }
   5080            
   5081            SERIAL_PROTOCOLPGM(MSG_M115_REPORT);
   5082            
   5083            extern uint8_t xtal_failed;
   5084            if (xtal_failed==1) SERIAL_PROTOCOLPGM("CLK:INT ");
   5085            else SERIAL_PROTOCOLPGM("CLK:EXT ");
   5086            SERIAL_PROTOCOLPGM("BUILD: ");
   5087            SERIAL_PROTOCOLPGM(__DATE__);
   5088            SERIAL_PROTOCOLPGM(" ");
   5089            SERIAL_PROTOCOLPGM(__TIME__);
   5090            SERIAL_PROTOCOLPGM("\n");
   5091            
   5092            if (code_seen('P'))
   5093            {
   5094              __disable_irq();
   5095              SYSCFG_MemoryRemapConfig(SYSCFG_MemoryRemap_SystemMemory);
   5096              __set_MSP(0x20002250);// 0x1fffC800 is "System Memory" start address for STM32 F0xx
   5097              void (*SysMemBootJump)(void);
   5098              SysMemBootJump = (void (*)(void)) (*((uint32_t *) 0x1fffC804)); // Point the PC to the System Memory reset vector (+4)
   5099              SysMemBootJump();
   5100              while (1);
   5101            }
   5102          }
   5103          
   5104          /**
   5105           * M117: Set LCD Status Message
   5106           */
   5107          inline void gcode_M117() {
   5108            //lcd_setstatus(current_command_args);
   5109            extern void StartBuild();
   5110            if (current_command_args[0]=='P' && current_command_args[1]=='r') StartBuild();
   5111          }
   5112          
   5113          /**
   5114           * M119: Output endstop states to serial output
   5115           */
   5116          inline void gcode_M119() {
   5117            SERIAL_PROTOCOLLN(MSG_M119_REPORT);
   5118            
   5119          #ifdef DELTA
   5120            SERIAL_PROTOCOLPGM("x_stop: ");
   5121            SERIAL_PROTOCOLLN(((READ(X_STOP_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5122            SERIAL_PROTOCOLPGM("y_stop: ");
   5123            SERIAL_PROTOCOLLN(((READ(Y_STOP_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5124            SERIAL_PROTOCOLPGM("z_stop: ");
   5125            SERIAL_PROTOCOLLN(((READ(Z_STOP_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5126            
   5127            SERIAL_PROTOCOLPGM(MSG_Z_MIN);
   5128            SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5129          #else
   5130            SERIAL_PROTOCOLPGM("x_stop: ");
   5131            SERIAL_PROTOCOLLN(((READ(X_STOP_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5132            SERIAL_PROTOCOLPGM("y_stop: ");
   5133            SERIAL_PROTOCOLLN(((READ(Y_STOP_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5134            SERIAL_PROTOCOLPGM("z_stop: ");
   5135            SERIAL_PROTOCOLLN(((READ(Z_STOP_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5136          #endif
   5137            
   5138            /*if (X_MIN_PIN==-1) SERIAL_PROTOCOLLN("X_MIN_PIN==-1");
   5139            if (X_MAX_PIN==-1) SERIAL_PROTOCOLLN("X_MAX_PIN==-1");
   5140            if (Y_MIN_PIN==-1) SERIAL_PROTOCOLLN("Y_MIN_PIN==-1");
   5141            if (Y_MAX_PIN==-1) SERIAL_PROTOCOLLN("Y_MAX_PIN==-1");*/
   5142            /*#if HAS_X_MAX
   5143              SERIAL_PROTOCOLPGM(MSG_X_MAX);
   5144              SERIAL_PROTOCOLLN(((READ(X_MAX_PIN)^X_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5145            #endif
   5146            #if HAS_Y_MAX
   5147              SERIAL_PROTOCOLPGM(MSG_Y_MAX);
   5148              SERIAL_PROTOCOLLN(((READ(Y_MAX_PIN)^Y_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5149            #endif
   5150            #if HAS_Z_MAX
   5151              SERIAL_PROTOCOLPGM(MSG_Z_MAX);
   5152              SERIAL_PROTOCOLLN(((READ(Z_MAX_PIN)^Z_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5153            #endif
   5154            #if HAS_X_MIN
   5155              SERIAL_PROTOCOLPGM(MSG_X_MIN);
   5156              SERIAL_PROTOCOLLN(((READ(X_MIN_PIN)^X_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5157            #endif
   5158            #if HAS_Y_MIN
   5159              SERIAL_PROTOCOLPGM(MSG_Y_MIN);
   5160              SERIAL_PROTOCOLLN(((READ(Y_MIN_PIN)^Y_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5161            #endif
   5162            #if HAS_Z_MIN
   5163              SERIAL_PROTOCOLPGM(MSG_Z_MIN);
   5164              SERIAL_PROTOCOLLN(((READ(Z_MIN_PIN)^Z_MIN_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5165            #endif*/
   5166          
   5167            #if HAS_Z2_MAX
   5168              SERIAL_PROTOCOLPGM(MSG_Z2_MAX);
   5169              SERIAL_PROTOCOLLN(((READ(Z2_MAX_PIN)^Z2_MAX_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5170            #endif
   5171            #if HAS_Z_PROBE
   5172              SERIAL_PROTOCOLPGM(MSG_Z_PROBE);
   5173              SERIAL_PROTOCOLLN(((READ(Z_MIN_PROBE_PIN)^Z_MIN_PROBE_ENDSTOP_INVERTING) ? MSG_ENDSTOP_HIT : MSG_ENDSTOP_OPEN));
   5174            #endif
   5175          }
   5176          
   5177          /**
   5178           * M120: Enable endstops
   5179           */
   5180          inline void gcode_M120() { enable_endstops(true); }
   5181          
   5182          /**
   5183           * M121: Disable endstops
   5184           */
   5185          inline void gcode_M121() { enable_endstops(false); }
   5186          
   5187          #if ENABLED(BLINKM)
   5188          
   5189            /**
   5190             * M150: Set Status LED Color - Use R-U-B for R-G-B
   5191             */
   5192            inline void gcode_M150() {
   5193              SendColors(
   5194                code_seen('R') ? (byte)code_value_short() : 0,
   5195                code_seen('U') ? (byte)code_value_short() : 0,
   5196                code_seen('B') ? (byte)code_value_short() : 0
   5197              );
   5198            }
   5199          
   5200          #endif // BLINKM
   5201          
   5202          /**
   5203           * M200: Set filament diameter and set E axis units to cubic millimeters
   5204           *
   5205           *    T<extruder> - Optional extruder number. Current extruder if omitted.
   5206           *    D<mm> - Diameter of the filament. Use "D0" to set units back to millimeters.
   5207           */
   5208          inline void gcode_M200() {
   5209          
   5210            if (setTargetedHotend(200)) return;
   5211          
   5212            if (code_seen('D')) {
   5213              float diameter = code_value();
   5214              // setting any extruder filament size disables volumetric on the assumption that
   5215              // slicers either generate in extruder values as cubic mm or as as filament feeds
   5216              // for all extruders
   5217              volumetric_enabled = (diameter != 0.0);
   5218              if (volumetric_enabled) {
   5219                filament_size[target_extruder] = diameter;
   5220                // make sure all extruders have some sane value for the filament size
   5221                for (int i = 0; i < EXTRUDERS; i++)
   5222                  if (! filament_size[i]) filament_size[i] = DEFAULT_NOMINAL_FILAMENT_DIA;
   5223              }
   5224            }
   5225            else {
   5226              //reserved for setting filament diameter via UFID or filament measuring device
   5227              return;
   5228            }
   5229            calculate_volumetric_multipliers();
   5230          }
   5231          
   5232          /**
   5233           * M201: Set max acceleration in units/s^2 for print moves (M201 X1000 Y1000)
   5234           */
   5235          inline void gcode_M201() {
   5236            for (int8_t i = 0; i < NUM_AXIS; i++) {
   5237              if (code_seen(axis_codes[i])) {
   5238                max_acceleration_units_per_sq_second[i] = code_value();
   5239              }
   5240            }
   5241            // steps per sq second need to be updated to agree with the units per sq second (as they are what is used in the planner)
   5242            reset_acceleration_rates();
   5243          }
   5244          
   5245          #if 0 // Not used for Sprinter/grbl gen6
   5246            inline void gcode_M202() {
   5247              for (int8_t i = 0; i < NUM_AXIS; i++) {
   5248                if (code_seen(axis_codes[i])) axis_travel_steps_per_sqr_second[i] = code_value() * axis_steps_per_unit[i];
   5249              }
   5250            }
   5251          #endif
   5252          
   5253          
   5254          /**
   5255           * M203: Set maximum feedrate that your machine can sustain (M203 X200 Y200 Z300 E10000) in mm/sec
   5256           */
   5257          inline void gcode_M203() {
   5258            for (int8_t i = 0; i < NUM_AXIS; i++) {
   5259              if (code_seen(axis_codes[i])) {
   5260                max_feedrate[i] = code_value();
   5261              }
   5262            }
   5263          }
   5264          
   5265          /**
   5266           * M204: Set Accelerations in mm/sec^2 (M204 P1200 R3000 T3000)
   5267           *
   5268           *    P = Printing moves
   5269           *    R = Retract only (no X, Y, Z) moves
   5270           *    T = Travel (non printing) moves
   5271           *
   5272           *  Also sets minimum segment time in ms (B20000) to prevent buffer under-runs and M20 minimum feedrate
   5273           */
   5274          inline void gcode_M204() {
   5275            if (code_seen('S')) {  // Kept for legacy compatibility. Should NOT BE USED for new developments.
   5276              travel_acceleration = acceleration = code_value();
   5277              SERIAL_ECHOPAIR("Setting Print and Travel Acceleration: ", acceleration);
   5278              SERIAL_EOL;
   5279            }
   5280            if (code_seen('P')) {
   5281              acceleration = code_value();
   5282              SERIAL_ECHOPAIR("Setting Print Acceleration: ", acceleration);
   5283              SERIAL_EOL;
   5284            }
   5285            if (code_seen('R')) {
   5286              retract_acceleration = code_value();
   5287              SERIAL_ECHOPAIR("Setting Retract Acceleration: ", retract_acceleration);
   5288              SERIAL_EOL;
   5289            }
   5290            if (code_seen('T')) {
   5291              travel_acceleration = code_value();
   5292              SERIAL_ECHOPAIR("Setting Travel Acceleration: ", travel_acceleration);
   5293              SERIAL_EOL;
   5294            }
   5295          }
   5296          
   5297          /**
   5298           * M205: Set Advanced Settings
   5299           *
   5300           *    S = Min Feed Rate (mm/s)
   5301           *    T = Min Travel Feed Rate (mm/s)
   5302           *    B = Min Segment Time (Âµs)
   5303           *    X = Max XY Jerk (mm/s/s)
   5304           *    Z = Max Z Jerk (mm/s/s)
   5305           *    E = Max E Jerk (mm/s/s)
   5306           */
   5307          inline void gcode_M205() {
   5308            if (code_seen('S')) minimumfeedrate = code_value();
   5309            if (code_seen('T')) mintravelfeedrate = code_value();
   5310            if (code_seen('B')) minsegmenttime = code_value();
   5311            if (code_seen('X')) max_xy_jerk = code_value();
   5312            if (code_seen('Z')) max_z_jerk = code_value();
   5313            if (code_seen('E')) max_e_jerk = code_value();
   5314          }
   5315          
   5316          /**
   5317           * M206: Set Additional Homing Offset (X Y Z). SCARA aliases T=X, P=Y
   5318           */
   5319          inline void gcode_M206() {
   5320            for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
   5321              if (code_seen(axis_codes[i])) {
   5322                home_offset[i] = code_value();
   5323              }
   5324            }
   5325            #if ENABLED(SCARA)
   5326              if (code_seen('T')) home_offset[X_AXIS] = code_value(); // Theta
   5327              if (code_seen('P')) home_offset[Y_AXIS] = code_value(); // Psi
   5328            #endif
   5329          }
   5330          
   5331          #if ENABLED(DELTA)
   5332            /**
   5333             * M665: Set delta configurations
   5334             *
   5335             *    L = diagonal rod
   5336             *    R = delta radius
   5337             *    S = segments per second
   5338             *    A = Alpha (Tower 1) diagonal rod trim
   5339             *    B = Beta (Tower 2) diagonal rod trim
   5340             *    C = Gamma (Tower 3) diagonal rod trim
   5341             */
   5342            inline void gcode_M665() {
   5343              if (code_seen('L')) delta_diagonal_rod = code_value();
   5344              if (code_seen('R')) delta_radius = code_value();
   5345              if (code_seen('S')) delta_segments_per_second = code_value();
   5346              if (code_seen('A')) delta_diagonal_rod_trim_tower_1 = code_value();
   5347              if (code_seen('B')) delta_diagonal_rod_trim_tower_2 = code_value();
   5348              if (code_seen('C')) delta_diagonal_rod_trim_tower_3 = code_value();
   5349              recalc_delta_settings(delta_radius, delta_diagonal_rod);
   5350            }
   5351            /**
   5352             * M666: Set delta endstop adjustment
   5353             */
   5354            inline void gcode_M666() {
   5355              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5356                if (marlin_debug_flags & DEBUG_LEVELING) {
   5357                  SERIAL_ECHOLNPGM(">>> gcode_M666");
   5358                }
   5359              #endif
   5360              for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
   5361                if (code_seen(axis_codes[i])) {
   5362                  endstop_adj[i] = code_value();
   5363                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   5364                    if (marlin_debug_flags & DEBUG_LEVELING) {
   5365                      SERIAL_ECHOPGM("endstop_adj[");
   5366                      SERIAL_ECHO(axis_codes[i]);
   5367                      SERIAL_ECHOPAIR("] = ", endstop_adj[i]);
   5368                      SERIAL_EOL;
   5369                    }
   5370                  #endif
   5371                }
   5372              }
   5373              #if ENABLED(DEBUG_LEVELING_FEATURE)
   5374                if (marlin_debug_flags & DEBUG_LEVELING) {
   5375                  SERIAL_ECHOLNPGM("<<< gcode_M666");
   5376                }
   5377              #endif
   5378            }
   5379          
   5380          #elif ENABLED(Z_DUAL_ENDSTOPS) // !DELTA && ENABLED(Z_DUAL_ENDSTOPS)
   5381          
   5382            /**
   5383             * M666: For Z Dual Endstop setup, set z axis offset to the z2 axis.
   5384             */
   5385            inline void gcode_M666() {
   5386              if (code_seen('Z')) z_endstop_adj = code_value();
   5387              SERIAL_ECHOPAIR("Z Endstop Adjustment set to (mm):", z_endstop_adj);
   5388              SERIAL_EOL;
   5389            }
   5390          
   5391          #endif // !DELTA && Z_DUAL_ENDSTOPS
   5392          
   5393          #if ENABLED(FWRETRACT)
   5394          
   5395            /**
   5396             * M207: Set firmware retraction values
   5397             *
   5398             *   S[+mm]    retract_length
   5399             *   W[+mm]    retract_length_swap (multi-extruder)
   5400             *   F[mm/min] retract_feedrate
   5401             *   Z[mm]     retract_zlift
   5402             */
   5403            inline void gcode_M207() {
   5404              if (code_seen('S')) retract_length = code_value();
   5405              if (code_seen('F')) retract_feedrate = code_value() / 60;
   5406              if (code_seen('Z')) retract_zlift = code_value();
   5407              if (EXTRUDERS > 1)
   5408                if (code_seen('W')) retract_length_swap = code_value();
   5409            }
   5410          
   5411            /**
   5412             * M208: Set firmware un-retraction values
   5413             *
   5414             *   S[+mm]    retract_recover_length (in addition to M207 S*)
   5415             *   W[+mm]    retract_recover_length_swap (multi-extruder)
   5416             *   F[mm/min] retract_recover_feedrate
   5417             */
   5418            inline void gcode_M208() {
   5419              if (code_seen('S')) retract_recover_length = code_value();
   5420              if (code_seen('F')) retract_recover_feedrate = code_value() / 60;
   5421              if (EXTRUDERS > 1)
   5422                if (code_seen('W')) retract_recover_length_swap = code_value();
   5423            }
   5424          
   5425            /**
   5426             * M209: Enable automatic retract (M209 S1)
   5427             *       detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
   5428             */
   5429            inline void gcode_M209() {
   5430              if (code_seen('S')) {
   5431                int t = code_value_short();
   5432                switch (t) {
   5433                  case 0:
   5434                    autoretract_enabled = false;
   5435                    break;
   5436                  case 1:
   5437                    autoretract_enabled = true;
   5438                    break;
   5439                  default:
   5440                    unknown_command_error();
   5441                    return;
   5442                }
   5443                for (int i = 0; i < EXTRUDERS; i++) retracted[i] = false;
   5444              }
   5445            }
   5446          
   5447          #endif // FWRETRACT
   5448          
   5449          //#if EXTRUDERS > 1
   5450          
   5451            /**
   5452             * M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
   5453             */
   5454            inline void gcode_M218() {
   5455              if (setTargetedHotend(218)) return;
   5456          
   5457              if (code_seen('X')) extruder_offset[X_AXIS][target_extruder] = code_value();
   5458              if (code_seen('Y')) extruder_offset[Y_AXIS][target_extruder] = code_value();
   5459          
   5460              #if ENABLED(DUAL_X_CARRIAGE)
   5461                if (code_seen('Z')) extruder_offset[Z_AXIS][target_extruder] = code_value();
   5462              #endif
   5463          
   5464              SERIAL_ECHO_START;
   5465              SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   5466              for (int e = 0; e < EXTRUDERS; e++) {
   5467                SERIAL_CHAR(' ');
   5468                SERIAL_ECHO(extruder_offset[X_AXIS][e]);
   5469                SERIAL_CHAR(',');
   5470                SERIAL_ECHO(extruder_offset[Y_AXIS][e]);
   5471                #if ENABLED(DUAL_X_CARRIAGE)
   5472                  SERIAL_CHAR(',');
   5473                  SERIAL_ECHO(extruder_offset[Z_AXIS][e]);
   5474                #endif
   5475              }
   5476              SERIAL_EOL;
   5477            }
   5478          
   5479          //#endif // EXTRUDERS > 1
   5480          
   5481          /**
   5482           * M220: Set speed percentage factor, aka "Feed Rate" (M220 S95)
   5483           */
   5484          inline void gcode_M220() {
   5485            if (code_seen('S')) feedrate_multiplier = code_value();
   5486          }
   5487          
   5488          /**
   5489           * M221: Set extrusion percentage (M221 T0 S95)
   5490           */
   5491          inline void gcode_M221() {
   5492            if (code_seen('S')) {
   5493              int sval = code_value();
   5494              if (setTargetedHotend(221)) return;
   5495              extruder_multiplier[target_extruder] = sval;
   5496            }
   5497          }
   5498          
   5499          /**
   5500           * M226: Wait until the specified pin reaches the state required (M226 P<pin> S<state>)
   5501           */
   5502          inline void gcode_M226() {
   5503          /*  //yongzong remove support for M226
   5504            if (code_seen('P')) {
   5505              int pin_number = code_value();
   5506          
   5507              int pin_state = code_seen('S') ? code_value() : -1; // required pin state - default is inverted
   5508          
   5509              if (pin_state >= -1 && pin_state <= 1) {
   5510          
   5511                for (uint8_t i = 0; i < COUNT(sensitive_pins); i++) {
   5512                  if (sensitive_pins[i] == pin_number) {
   5513                    pin_number = -1;
   5514                    break;
   5515                  }
   5516                }
   5517          
   5518                if (pin_number > -1) {
   5519                  int target = LOW;
   5520          
   5521                  st_synchronize();
   5522          
   5523                  pinMode(pin_number, INPUT);
   5524          
   5525                  switch (pin_state) {
   5526                    case 1:
   5527                      target = HIGH;
   5528                      break;
   5529          
   5530                    case 0:
   5531                      target = LOW;
   5532                      break;
   5533          
   5534                    case -1:
   5535                      target = !digitalRead(pin_number);
   5536                      break;
   5537                  }
   5538          
   5539                  while (digitalRead(pin_number) != target) idle();
   5540          
   5541                } // pin_number > -1
   5542              } // pin_state -1 0 1
   5543            } // code_seen('P')
   5544          */
   5545          }
   5546          
   5547          #if HAS_SERVOS
   5548          
   5549            /**
   5550             * M280: Get or set servo position. P<index> S<angle>
   5551             */
   5552            inline void gcode_M280() {
   5553              int servo_index = code_seen('P') ? code_value_short() : -1;
   5554              int servo_position = 0;
   5555              if (code_seen('S')) {
   5556                servo_position = code_value_short();
   5557                if (servo_index >= 0 && servo_index < NUM_SERVOS)
   5558                  servo[servo_index].move(servo_position);
   5559                else {
   5560                  SERIAL_ECHO_START;
   5561                  SERIAL_ECHO("Servo ");
   5562                  SERIAL_ECHO(servo_index);
   5563                  SERIAL_ECHOLN(" out of range");
   5564                }
   5565              }
   5566              else if (servo_index >= 0) {
   5567                SERIAL_PROTOCOL(MSG_OK);
   5568                SERIAL_PROTOCOL(" Servo ");
   5569                SERIAL_PROTOCOL(servo_index);
   5570                SERIAL_PROTOCOL(": ");
   5571                SERIAL_PROTOCOL(servo[servo_index].read());
   5572                SERIAL_EOL;
   5573              }
   5574            }
   5575          
   5576          #endif // HAS_SERVOS
   5577          
   5578          #if HAS_BUZZER
   5579          
   5580            /**
   5581             * M300: Play beep sound S<frequency Hz> P<duration ms>
   5582             */
   5583            inline void gcode_M300() {
   5584              uint16_t beepS = code_seen('S') ? code_value_short() : 110;
   5585              uint32_t beepP = code_seen('P') ? code_value_long() : 1000;
   5586              if (beepP > 5000) beepP = 5000; // limit to 5 seconds
   5587              buzz(beepP, beepS);
   5588            }
   5589          
   5590          #endif // HAS_BUZZER
   5591          
   5592          #if ENABLED(PIDTEMP)
   5593          
   5594            /**
   5595             * M301: Set PID parameters P I D (and optionally C, L)
   5596             *
   5597             *   P[float] Kp term
   5598             *   I[float] Ki term (unscaled)
   5599             *   D[float] Kd term (unscaled)
   5600             *
   5601             * With PID_ADD_EXTRUSION_RATE:
   5602             *
   5603             *   C[float] Kc term
   5604             *   L[float] LPQ length
   5605             */
   5606            inline void gcode_M301() {
   5607          
   5608              // multi-extruder PID patch: M301 updates or prints a single extruder's PID values
   5609              // default behaviour (omitting E parameter) is to update for extruder 0 only
   5610              int e = code_seen('E') ? code_value() : 0; // extruder being updated
   5611          
   5612              if (e < EXTRUDERS) { // catch bad input value
   5613                if (code_seen('P')) PID_PARAM(Kp, e) = code_value();
   5614                if (code_seen('I')) PID_PARAM(Ki, e) = scalePID_i(code_value());
   5615                if (code_seen('D')) PID_PARAM(Kd, e) = scalePID_d(code_value());
   5616                #if ENABLED(PID_ADD_EXTRUSION_RATE)
   5617                  if (code_seen('C')) PID_PARAM(Kc, e) = code_value();
   5618                  if (code_seen('L')) lpq_len = code_value();
   5619                  NOMORE(lpq_len, LPQ_MAX_LEN);
   5620                #endif
   5621          
   5622                updatePID();
   5623                //delay(10);
   5624                SERIAL_PROTOCOL(MSG_OK);
   5625                #if ENABLED(PID_PARAMS_PER_EXTRUDER)
   5626                  SERIAL_PROTOCOL(" e:"); // specify extruder in serial output
   5627                  SERIAL_PROTOCOL(e);
   5628                #endif // PID_PARAMS_PER_EXTRUDER
   5629                SERIAL_PROTOCOL(" p:");
   5630                SERIAL_PROTOCOL(PID_PARAM(Kp, e));
   5631                SERIAL_PROTOCOL(" i:");
   5632                SERIAL_PROTOCOL(unscalePID_i(PID_PARAM(Ki, e)));
   5633                SERIAL_PROTOCOL(" d:");
   5634                SERIAL_PROTOCOL(unscalePID_d(PID_PARAM(Kd, e)));
   5635                #if ENABLED(PID_ADD_EXTRUSION_RATE)
   5636                  SERIAL_PROTOCOL(" c:");
   5637                  //Kc does not have scaling applied above, or in resetting defaults
   5638                  SERIAL_PROTOCOL(PID_PARAM(Kc, e));
   5639                #endif
   5640                SERIAL_EOL;
   5641              }
   5642              else {
   5643                SERIAL_ECHO_START;
   5644                SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
   5645              }
   5646            }
   5647          
   5648          #endif // PIDTEMP
   5649          
   5650          #if ENABLED(PIDTEMPBED)
   5651          
   5652            inline void gcode_M304() {
   5653              if (code_seen('P')) bedKp = code_value();
   5654              if (code_seen('I')) bedKi = scalePID_i(code_value());
   5655              if (code_seen('D')) bedKd = scalePID_d(code_value());
   5656          
   5657              updatePID();
   5658              //delay(10);
   5659              SERIAL_PROTOCOL(MSG_OK);
   5660              SERIAL_PROTOCOL(" p:");
   5661              SERIAL_PROTOCOL(bedKp);
   5662              SERIAL_PROTOCOL(" i:");
   5663              SERIAL_PROTOCOL(unscalePID_i(bedKi));
   5664              SERIAL_PROTOCOL(" d:");
   5665              SERIAL_PROTOCOL(unscalePID_d(bedKd));
   5666              SERIAL_EOL;
   5667            }
   5668          
   5669          #endif // PIDTEMPBED
   5670          
   5671          #if defined(CHDK) || HAS_PHOTOGRAPH
   5672          
   5673            /**
   5674             * M240: Trigger a camera by emulating a Canon RC-1
   5675             *       See http://www.doc-diy.net/photo/rc-1_hacked/
   5676             */
   5677            inline void gcode_M240() {
   5678              #ifdef CHDK
   5679          
   5680                OUT_WRITE(CHDK, HIGH);
   5681                chdkHigh = millis();
   5682                chdkActive = true;
   5683          
   5684              #elif HAS_PHOTOGRAPH
   5685          
   5686                const uint8_t NUM_PULSES = 16;
   5687                const float PULSE_LENGTH = 0.01524;
   5688                for (int i = 0; i < NUM_PULSES; i++) {
   5689                  WRITE(PHOTOGRAPH_PIN, HIGH);
   5690                  _delay_ms(PULSE_LENGTH);
   5691                  WRITE(PHOTOGRAPH_PIN, LOW);
   5692                  _delay_ms(PULSE_LENGTH);
   5693                }
   5694                delay(7.33);
   5695                for (int i = 0; i < NUM_PULSES; i++) {
   5696                  WRITE(PHOTOGRAPH_PIN, HIGH);
   5697                  _delay_ms(PULSE_LENGTH);
   5698                  WRITE(PHOTOGRAPH_PIN, LOW);
   5699                  _delay_ms(PULSE_LENGTH);
   5700                }
   5701          
   5702              #endif // !CHDK && HAS_PHOTOGRAPH
   5703            }
   5704          
   5705          #endif // CHDK || PHOTOGRAPH_PIN
   5706          
   5707          #if ENABLED(HAS_LCD_CONTRAST)
   5708          
   5709            /**
   5710             * M250: Read and optionally set the LCD contrast
   5711             */
   5712            inline void gcode_M250() {
   5713              if (code_seen('C')) lcd_setcontrast(code_value_short() & 0x3F);
   5714              SERIAL_PROTOCOLPGM("lcd contrast value: ");
   5715              SERIAL_PROTOCOL(lcd_contrast);
   5716              SERIAL_EOL;
   5717            }
   5718          
   5719          #endif // HAS_LCD_CONTRAST
   5720          
   5721          #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
   5722          
   5723            void set_extrude_min_temp(float temp) { extrude_min_temp = temp; }
   5724          
   5725            /**
   5726             * M302: Allow cold extrudes, or set the minimum extrude S<temperature>.
   5727             */
   5728            inline void gcode_M302() {
   5729              set_extrude_min_temp(code_seen('S') ? code_value() : 0);
   5730            }
   5731          
   5732          #endif // PREVENT_DANGEROUS_EXTRUDE
   5733          
   5734          /**
   5735           * M303: PID relay autotune
   5736           *       S<temperature> sets the target temperature. (default target temperature = 150C)
   5737           *       E<extruder> (-1 for the bed)
   5738           *       C<cycles>
   5739           */
   5740          inline void gcode_M303() {
   5741            int e = code_seen('E') ? code_value_short() : 0;
   5742            int c = code_seen('C') ? code_value_short() : 5;
   5743            float temp = code_seen('S') ? code_value() : (e < 0 ? 70.0 : 150.0);
   5744            PID_autotune(temp, e, c);
   5745          }
   5746          
   5747          #if ENABLED(SCARA)
   5748            bool SCARA_move_to_cal(uint8_t delta_x, uint8_t delta_y) {
   5749              //SoftEndsEnabled = false;              // Ignore soft endstops during calibration
   5750              //SERIAL_ECHOLN(" Soft endstops disabled ");
   5751              if (IsRunning()) {
   5752                //gcode_get_destination(); // For X Y Z E F
   5753                delta[X_AXIS] = delta_x;
   5754                delta[Y_AXIS] = delta_y;
   5755                calculate_SCARA_forward_Transform(delta);
   5756                destination[X_AXIS] = delta[X_AXIS] / axis_scaling[X_AXIS];
   5757                destination[Y_AXIS] = delta[Y_AXIS] / axis_scaling[Y_AXIS];
   5758                prepare_move();
   5759                //ok_to_send();
   5760                return true;
   5761              }
   5762              return false;
   5763            }
   5764          
   5765            /**
   5766             * M360: SCARA calibration: Move to cal-position ThetaA (0 deg calibration)
   5767             */
   5768            inline bool gcode_M360() {
   5769              SERIAL_ECHOLN(" Cal: Theta 0 ");
   5770              return SCARA_move_to_cal(0, 120);
   5771            }
   5772          
   5773            /**
   5774             * M361: SCARA calibration: Move to cal-position ThetaB (90 deg calibration - steps per degree)
   5775             */
   5776            inline bool gcode_M361() {
   5777              SERIAL_ECHOLN(" Cal: Theta 90 ");
   5778              return SCARA_move_to_cal(90, 130);
   5779            }
   5780          
   5781            /**
   5782             * M362: SCARA calibration: Move to cal-position PsiA (0 deg calibration)
   5783             */
   5784            inline bool gcode_M362() {
   5785              SERIAL_ECHOLN(" Cal: Psi 0 ");
   5786              return SCARA_move_to_cal(60, 180);
   5787            }
   5788          
   5789            /**
   5790             * M363: SCARA calibration: Move to cal-position PsiB (90 deg calibration - steps per degree)
   5791             */
   5792            inline bool gcode_M363() {
   5793              SERIAL_ECHOLN(" Cal: Psi 90 ");
   5794              return SCARA_move_to_cal(50, 90);
   5795            }
   5796          
   5797            /**
   5798             * M364: SCARA calibration: Move to cal-position PSIC (90 deg to Theta calibration position)
   5799             */
   5800            inline bool gcode_M364() {
   5801              SERIAL_ECHOLN(" Cal: Theta-Psi 90 ");
   5802              return SCARA_move_to_cal(45, 135);
   5803            }
   5804          
   5805            /**
   5806             * M365: SCARA calibration: Scaling factor, X, Y, Z axis
   5807             */
   5808            inline void gcode_M365() {
   5809              for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
   5810                if (code_seen(axis_codes[i])) {
   5811                  axis_scaling[i] = code_value();
   5812                }
   5813              }
   5814            }
   5815          
   5816          #endif // SCARA
   5817          
   5818          #if ENABLED(EXT_SOLENOID)
   5819          
   5820            void enable_solenoid(uint8_t num) {
   5821              switch (num) {
   5822                case 0:
   5823                  OUT_WRITE(SOL0_PIN, HIGH);
   5824                  break;
   5825                  #if HAS_SOLENOID_1
   5826                    case 1:
   5827                      OUT_WRITE(SOL1_PIN, HIGH);
   5828                      break;
   5829                  #endif
   5830                  #if HAS_SOLENOID_2
   5831                    case 2:
   5832                      OUT_WRITE(SOL2_PIN, HIGH);
   5833                      break;
   5834                  #endif
   5835                  #if HAS_SOLENOID_3
   5836                    case 3:
   5837                      OUT_WRITE(SOL3_PIN, HIGH);
   5838                      break;
   5839                  #endif
   5840                default:
   5841                  SERIAL_ECHO_START;
   5842                  SERIAL_ECHOLNPGM(MSG_INVALID_SOLENOID);
   5843                  break;
   5844              }
   5845            }
   5846          
   5847            void enable_solenoid_on_active_extruder() { enable_solenoid(active_extruder); }
   5848          
   5849            void disable_all_solenoids() {
   5850              OUT_WRITE(SOL0_PIN, LOW);
   5851              OUT_WRITE(SOL1_PIN, LOW);
   5852              OUT_WRITE(SOL2_PIN, LOW);
   5853              OUT_WRITE(SOL3_PIN, LOW);
   5854            }
   5855          
   5856            /**
   5857             * M380: Enable solenoid on the active extruder
   5858             */
   5859            inline void gcode_M380() { enable_solenoid_on_active_extruder(); }
   5860          
   5861            /**
   5862             * M381: Disable all solenoids
   5863             */
   5864            inline void gcode_M381() { disable_all_solenoids(); }
   5865          
   5866          #endif // EXT_SOLENOID
   5867          
   5868          /**
   5869           * M400: Finish all moves
   5870           */
   5871          inline void gcode_M400() { st_synchronize(); extern void EndBuild();EndBuild();}
   5872          
   5873          #if ENABLED(AUTO_BED_LEVELING_FEATURE) && DISABLED(Z_PROBE_SLED) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY))
   5874          
   5875            /**
   5876             * M401: Engage Z Servo endstop if available
   5877             */
   5878            inline void gcode_M401() {
   5879              #if HAS_SERVO_ENDSTOPS
   5880                raise_z_for_servo();
   5881              #endif
   5882              deploy_z_probe();
   5883            }
   5884          
   5885            /**
   5886             * M402: Retract Z Servo endstop if enabled
   5887             */
   5888            inline void gcode_M402() {
   5889              #if HAS_SERVO_ENDSTOPS
   5890                raise_z_for_servo();
   5891              #endif
   5892              stow_z_probe(false);
   5893            }
   5894          
   5895          #endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
   5896          
   5897          #if ENABLED(FILAMENT_SENSOR)
   5898          
   5899            /**
   5900             * M404: Display or set the nominal filament width (3mm, 1.75mm ) W<3.0>
   5901             */
   5902            inline void gcode_M404() {
   5903              #if HAS_FILWIDTH
   5904                if (code_seen('W')) {
   5905                  filament_width_nominal = code_value();
   5906                }
   5907                else {
   5908                  SERIAL_PROTOCOLPGM("Filament dia (nominal mm):");
   5909                  SERIAL_PROTOCOLLN(filament_width_nominal);
   5910                }
   5911              #endif
   5912            }
   5913          
   5914            /**
   5915             * M405: Turn on filament sensor for control
   5916             */
   5917            inline void gcode_M405() {
   5918              if (code_seen('D')) meas_delay_cm = code_value();
   5919              if (meas_delay_cm > MAX_MEASUREMENT_DELAY) meas_delay_cm = MAX_MEASUREMENT_DELAY;
   5920          
   5921              if (delay_index2 == -1) { //initialize the ring buffer if it has not been done since startup
   5922                int temp_ratio = widthFil_to_size_ratio();
   5923          
   5924                for (delay_index1 = 0; delay_index1 < MAX_MEASUREMENT_DELAY + 1; ++delay_index1)
   5925                  measurement_delay[delay_index1] = temp_ratio - 100;  //subtract 100 to scale within a signed byte
   5926          
   5927                delay_index1 = delay_index2 = 0;
   5928              }
   5929          
   5930              filament_sensor = true;
   5931          
   5932              //SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
   5933              //SERIAL_PROTOCOL(filament_width_meas);
   5934              //SERIAL_PROTOCOLPGM("Extrusion ratio(%):");
   5935              //SERIAL_PROTOCOL(extruder_multiplier[active_extruder]);
   5936            }
   5937          
   5938            /**
   5939             * M406: Turn off filament sensor for control
   5940             */
   5941            inline void gcode_M406() { filament_sensor = false; }
   5942          
   5943            /**
   5944             * M407: Get measured filament diameter on serial output
   5945             */
   5946            inline void gcode_M407() {
   5947              SERIAL_PROTOCOLPGM("Filament dia (measured mm):");
   5948              SERIAL_PROTOCOLLN(filament_width_meas);
   5949            }
   5950          
   5951          #endif // FILAMENT_SENSOR
   5952          
   5953          /**
   5954           * M410: Quickstop - Abort all planned moves
   5955           *
   5956           * This will stop the carriages mid-move, so most likely they
   5957           * will be out of sync with the stepper position after this.
   5958           */
   5959          inline void gcode_M410() { quickStop(); }
   5960          
   5961          
   5962          #if ENABLED(MESH_BED_LEVELING)
   5963          
   5964            /**
   5965             * M420: Enable/Disable Mesh Bed Leveling
   5966             */
   5967            inline void gcode_M420() { if (code_seen('S') && code_has_value()) mbl.active = !!code_value_short(); }
   5968          
   5969            /**
   5970             * M421: Set a single Mesh Bed Leveling Z coordinate
   5971             */
   5972            inline void gcode_M421() {
   5973              float x, y, z;
   5974              bool err = false, hasX, hasY, hasZ;
   5975              if ((hasX = code_seen('X'))) x = code_value();
   5976              if ((hasY = code_seen('Y'))) y = code_value();
   5977              if ((hasZ = code_seen('Z'))) z = code_value();
   5978          
   5979              if (!hasX || !hasY || !hasZ) {
   5980                SERIAL_ERROR_START;
   5981                SERIAL_ERRORLNPGM(MSG_ERR_M421_REQUIRES_XYZ);
   5982                err = true;
   5983              }
   5984          
   5985              if (x >= MESH_NUM_X_POINTS || y >= MESH_NUM_Y_POINTS) {
   5986                SERIAL_ERROR_START;
   5987                SERIAL_ERRORLNPGM(MSG_ERR_MESH_INDEX_OOB);
   5988                err = true;
   5989              }
   5990          
   5991              //if (!err) mbl.set_z(mbl.select_x_index(x), mbl.select_y_index(y), z);
   5992              if (!err) mbl.set_z(x, y, z);
   5993            }
   5994          
   5995          #endif
   5996          
   5997          /**
   5998           * M428: Set home_offset based on the distance between the
   5999           *       current_position and the nearest "reference point."
   6000           *       If an axis is past center its endstop position
   6001           *       is the reference-point. Otherwise it uses 0. This allows
   6002           *       the Z offset to be set near the bed when using a max endstop.
   6003           *
   6004           *       M428 can't be used more than 2cm away from 0 or an endstop.
   6005           *
   6006           *       Use M206 to set these values directly.
   6007           */
   6008          inline void gcode_M428() {
   6009            bool err = false;
   6010            float new_offs[3], new_pos[3];
   6011            memcpy(new_pos, current_position, sizeof(new_pos));
   6012            memcpy(new_offs, home_offset, sizeof(new_offs));
   6013            for (int8_t i = X_AXIS; i <= Z_AXIS; i++) {
   6014              if (axis_known_position[i]) {
   6015                float base = (new_pos[i] > (min_pos[i] + max_pos[i]) / 2) ? base_home_pos(i) : 0,
   6016                      diff = new_pos[i] - base;
   6017                if (diff > -20 && diff < 20) {
   6018                  new_offs[i] -= diff;
   6019                  new_pos[i] = base;
   6020                }
   6021                else {
   6022                  SERIAL_ERROR_START;
   6023                  SERIAL_ERRORLNPGM(MSG_ERR_M428_TOO_FAR);
   6024                  //LCD_ALERTMESSAGEPGM("Err: Too far!");
   6025                  #if HAS_BUZZER
   6026                    enqueuecommands_P(PSTR("M300 S40 P200"));
   6027                  #endif
   6028                  err = true;
   6029                  break;
   6030                }
   6031              }
   6032            }
   6033          
   6034            if (!err) {
   6035              memcpy(current_position, new_pos, sizeof(new_pos));
   6036              memcpy(home_offset, new_offs, sizeof(new_offs));
   6037              sync_plan_position();
   6038              //LCD_ALERTMESSAGEPGM("Offset applied.");
   6039              #if HAS_BUZZER
   6040                enqueuecommands_P(PSTR("M300 S659 P200\nM300 S698 P200"));
   6041              #endif
   6042            }
   6043          }
   6044          
   6045          /**
   6046           * M500: Store settings in EEPROM
   6047           */
   6048          inline void gcode_M500() {
   6049            Config_StoreSettings();
   6050          }
   6051          
   6052          /**
   6053           * M501: Read settings from EEPROM
   6054           */
   6055          inline void gcode_M501() {
   6056            Config_RetrieveSettings(false);
   6057          }
   6058          
   6059          /**
   6060           * M502: Revert to default settings
   6061           */
   6062          inline void gcode_M502() {
   6063            Config_ResetDefault();
   6064          }
   6065          
   6066          /**
   6067           * M503: print settings currently in memory
   6068           */
   6069          inline void gcode_M503() {
   6070            Config_PrintSettings(code_seen('S') && code_value() == 0);
   6071          }
   6072          
   6073          #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   6074          
   6075            /**
   6076             * M540: Set whether SD card print should abort on endstop hit (M540 S<0|1>)
   6077             */
   6078            inline void gcode_M540() {
   6079              if (code_seen('S')) abort_on_endstop_hit = (code_value() > 0);
   6080            }
   6081          
   6082          #endif // ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED
   6083          
   6084          //M550 Get/Set SSID
   6085          inline void gcode_M550() {
   6086              extern char wifi_ssid[32];
   6087              if (current_command_args[0]!=0) strcpy(wifi_ssid,current_command_args);
   6088              else SERIAL_PROTOCOLLN(wifi_ssid);
   6089          }
   6090          
   6091          //M551 Get/Set Password
   6092          inline void gcode_M551() {
   6093              extern char wifi_password[32];
   6094              if (current_command_args[0]!=0)
   6095              {
   6096                  extern char wifi_ssid[32];
   6097          
   6098                  strcpy(wifi_password,current_command_args);
   6099                  wifi_writeString((char *)"{WS:");
   6100                  wifi_writeString(wifi_ssid);
   6101                  wifi_writeString((char *)"}{WP:");
   6102                  wifi_writeString(wifi_password);
   6103                  wifi_writeString((char *)"}");
   6104              }
   6105              else SERIAL_PROTOCOLLN(wifi_password);
   6106          }
   6107          
   6108          //M552 Get/Set IP address
   6109          inline void gcode_M552() {
   6110              extern uint8_t wifi_ip[4];
   6111          
   6112              MYSERIAL.print(wifi_ip[0],10);
   6113              SERIAL_PROTOCOLCHAR('.');
   6114              MYSERIAL.print(wifi_ip[1],10);
   6115              SERIAL_PROTOCOLCHAR('.');
   6116              MYSERIAL.print(wifi_ip[2],10);
   6117              SERIAL_PROTOCOLCHAR('.');
   6118              MYSERIAL.print(wifi_ip[3],10);
   6119              SERIAL_EOL;
   6120          }
   6121          
   6122          //M553 Get/Set Netmask
   6123          inline void gcode_M553() {
   6124              extern uint8_t wifi_mask[4];
   6125          
   6126              MYSERIAL.print(wifi_mask[0],10);
   6127              SERIAL_PROTOCOLCHAR('.');
   6128              MYSERIAL.print(wifi_mask[1],10);
   6129              SERIAL_PROTOCOLCHAR('.');
   6130              MYSERIAL.print(wifi_mask[2],10);
   6131              SERIAL_PROTOCOLCHAR('.');
   6132              MYSERIAL.print(wifi_mask[3],10);
   6133              SERIAL_EOL;
   6134          }
   6135          
   6136          //M554 Get/Set Gateway
   6137          inline void gcode_M554() {
   6138              extern uint8_t wifi_gw[4];
   6139          
   6140              MYSERIAL.print(wifi_gw[0],10);
   6141              SERIAL_PROTOCOLCHAR('.');
   6142              MYSERIAL.print(wifi_gw[1],10);
   6143              SERIAL_PROTOCOLCHAR('.');
   6144              MYSERIAL.print(wifi_gw[2],10);
   6145              SERIAL_PROTOCOLCHAR('.');
   6146              MYSERIAL.print(wifi_gw[3],10);
   6147              SERIAL_EOL;
   6148          }
   6149          
   6150          //M555 Network control
   6151          inline void gcode_M555() {
   6152              if (code_seen('P'))
   6153              {
   6154                  uint8_t p=code_value();
   6155                  if (p==1) wifi_writeString((char *)"{R:R}");
   6156              }
   6157              else
   6158              {
   6159                  wifi_writeString((char *)"{R:A}");
   6160              }
   6161          }
   6162          
   6163          //M556 Network status
   6164          inline void gcode_M556() {
   6165              extern char wifi_status;
   6166          
   6167              if (code_seen('P'))
   6168              {
   6169                  wifi_writeString((char *)"{WC:0}");
   6170              }
   6171              if (wifi_status==1) SERIAL_PROTOCOLLN("CONNECTED.");
   6172              else SERIAL_PROTOCOLLN("DISCONNECTED.");
   6173          }
   6174          
   6175          //M557 Get MacAddress
   6176          inline void gcode_M557() {
   6177              extern char wifi_mac[20];
   6178              wifi_writeString((char *)"{R:M}");
   6179              MYSERIAL.print(wifi_mac);
   6180              SERIAL_EOL;
   6181          }
   6182          
   6183          //M560 Update
   6184          inline void gcode_M560() {
   6185              if (code_seen('P'))
   6186              {
   6187                  uint16_t p=code_value();
   6188                  if (p==1234) wifi_writeString((char *)"{R:MX}");
   6189                  else if (p==9229)
   6190                  {
   6191                      //GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);
   6192                      while (1);
   6193                  }
   6194                  else if (p==0)
   6195                  {
   6196                      /*FLASH_EnableWriteProtection(OB_WRP_Pages0to3);
   6197                      FLASH_EnableWriteProtection(FLASH_WRProt_Pages4to7);*/
   6198                  }
   6199                  return;
   6200              }
   6201              wifi_writeString((char *)"{SYS:UPDATE}");
   6202              PWR_BackupAccessCmd(ENABLE);
   6203              /*BKP_ClearFlag();
   6204              BKP_TamperPinLevelConfig(BKP_TamperPinLevel_High);
   6205              BKP_WriteBackupRegister(4,0xBEEF);*/
   6206          
   6207              IWDG_WriteAccessCmd(IWDG_WriteAccess_Enable);
   6208              IWDG_SetPrescaler(IWDG_Prescaler_4);
   6209              IWDG_SetReload(10);
   6210              IWDG_ReloadCounter();
   6211              IWDG_Enable();
   6212              RCC_LSICmd(ENABLE);
   6213              while (1);
   6214          }
   6215          
   6216          //M561 Change thermistor type
   6217          void gcode_M561() {
   6218              /*uint8_t tool=0;
   6219              if (code_seen('T'))
   6220              {
   6221                  tool=code_value();
   6222              }*/
   6223          
   6224              if (code_seen('B'))
   6225              {
   6226                  if (code_seen('P'))
   6227                  {
   6228                      thermistor_bed_type=code_value();
   6229                  }
   6230          
   6231                  SERIAL_PROTOCOL("Heat bed thermsistor type: ");
   6232                  if (thermistor_bed_type==0) SERIAL_PROTOCOLLN("DEFAULT");
   6233                  else if (thermistor_bed_type==1) SERIAL_PROTOCOLLN("104GT-2");
   6234                  else
   6235                  {
   6236                      thermistor_bed_type=0;
   6237                      SERIAL_PROTOCOLLN("DEFAULT");
   6238                  }
   6239                  return;
   6240              }
   6241          
   6242              if (code_seen('P'))
   6243              {
   6244                  thermistor_type=code_value();
   6245              }
   6246          
   6247              SERIAL_PROTOCOL("Thermsistor type: ");
   6248              if (thermistor_type==0) SERIAL_PROTOCOLLN("DEFAULT");
   6249              else if (thermistor_type==1) SERIAL_PROTOCOLLN("104GT-2");
   6250              else
   6251              {
   6252                  thermistor_type=0;
   6253                  SERIAL_PROTOCOLLN("DEFAULT");
   6254              }
   6255          }
   6256          
   6257          //M562 Invert axis
   6258          inline void gcode_M562() {
   6259              extern uint8_t invert_byte;
   6260              if (code_seen('P')) invert_byte=code_value();
   6261              else if (code_seen('M'))
   6262              {
   6263                  if (code_seen('X')) invert_byte^=0x21;
   6264                  if (code_seen('Y')) invert_byte^=0x42;
   6265              }
   6266              else
   6267              {
   6268                  if (code_seen('X')) invert_byte^=0x1;
   6269                  if (code_seen('Y')) invert_byte^=0x2;
   6270                  if (code_seen('Z')) invert_byte^=0x4;
   6271                  if (code_seen('E')) invert_byte^=0x8;
   6272                  if (code_seen('A')) invert_byte^=0x8;
   6273                  if (code_seen('B')) invert_byte^=0x10;
   6274              }
   6275              
   6276              SERIAL_PROTOCOLLN("DIR  |MIRROR");
   6277              SERIAL_PROTOCOLLN("XYZAB|XY");
   6278              if (INVERT_X_DIR) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6279              if (INVERT_Y_DIR) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6280              if (INVERT_Z_DIR) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6281              if (INVERT_E0_DIR) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6282              if (INVERT_E1_DIR) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6283              SERIAL_PROTOCOL('|');
   6284              if (X_HOME_DIR==1) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6285              if (Y_HOME_DIR==1) SERIAL_PROTOCOL('+');else SERIAL_PROTOCOL('-');
   6286              SERIAL_EOL;
   6287          }
   6288          
   6289          //M563 LCD Update
   6290          uint8_t serial_rate=0;
   6291          inline void gcode_M563() {
   6292              if (code_seen('S'))
   6293              {
   6294                USART_InitTypeDef USART_InitStructure;
   6295                extern void serial_init(int baud);
   6296          
   6297                uint16_t s=code_value();
   6298                if (s==serial_rate) return;
   6299                if (s==1)
   6300                {
   6301                  wifi_writeString((char *)"{S:1}");
   6302                  wifi_writeString((char *)"{S:1}");
   6303                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6304                  delay(100);
   6305                  USART_Cmd(WIFI_UART, DISABLE);
   6306                  USART_DeInit(WIFI_UART);
   6307                  serial_init(500000);
   6308                }
   6309                else if (s==2)
   6310                {
   6311                  wifi_writeString((char *)"{S:2}");
   6312                  wifi_writeString((char *)"{S:2}");
   6313                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6314                  delay(100);
   6315                  USART_Cmd(WIFI_UART, DISABLE);
   6316                  USART_DeInit(WIFI_UART);
   6317                  serial_init(512000);
   6318                }
   6319                else if (s==3)
   6320                {
   6321                  wifi_writeString((char *)"{S:3}");
   6322                  wifi_writeString((char *)"{S:3}");
   6323                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6324                  delay(100);
   6325                  USART_Cmd(WIFI_UART, DISABLE);
   6326                  USART_DeInit(WIFI_UART);
   6327                  serial_init(1000000);
   6328                }
   6329                else if (s==4)
   6330                {
   6331                  wifi_writeString((char *)"{S:4}");
   6332                  wifi_writeString((char *)"{S:4}");
   6333                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6334                  delay(100);
   6335                  USART_Cmd(WIFI_UART, DISABLE);
   6336                  USART_DeInit(WIFI_UART);
   6337                  serial_init(2000000);
   6338                }
   6339                else if (s==5)
   6340                {
   6341                  wifi_writeString((char *)"{S:5}");
   6342                  wifi_writeString((char *)"{S:5}");
   6343                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6344                  delay(100);
   6345                  USART_Cmd(WIFI_UART, DISABLE);
   6346                  USART_DeInit(WIFI_UART);
   6347                  serial_init(3000000);
   6348                }
   6349                else if (s==6)
   6350                {
   6351                  wifi_writeString((char *)"{S:6}");
   6352                  wifi_writeString((char *)"{S:6}");
   6353                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6354                  delay(100);
   6355                  USART_Cmd(WIFI_UART, DISABLE);
   6356                  USART_DeInit(WIFI_UART);
   6357                  serial_init(4000000);
   6358                }
   6359                else if (s==1)
   6360                {
   6361                  wifi_writeString((char *)"{S:1}");
   6362                  wifi_writeString((char *)"{S:1}");
   6363                  while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET){}
   6364                  delay(100);
   6365                  USART_Cmd(WIFI_UART, DISABLE);
   6366                  USART_DeInit(WIFI_UART);
   6367                  serial_init(115200);
   6368                }
   6369                serial_rate=s;
   6370                return;
   6371              }
   6372          
   6373              wifi_writeString((char *)"{WU:");
   6374              wifi_writeString(current_command_args);
   6375              wifi_writeString((char *)"}");
   6376          }
   6377          
   6378          bool start_after_download=false;
   6379          //M564 HTTP Download
   6380          void gcode_M564() {
   6381              start_after_download=false;
   6382              if (current_command_args[0]==0)
   6383              {
   6384                SERIAL_PROTOCOLLN("echo: M564 http://server/file.gcode");
   6385                return;
   6386              }
   6387              wifi_writeString((char *)"{H:");
   6388              if (current_command_args[4]==':')
   6389                  wifi_writeString(current_command_args+7);
   6390              else wifi_writeString(current_command_args);
   6391              wifi_writeString((char *)"}");
   6392          }
   6393          
   6394          //M565 Print cached file
   6395          extern "C" void store_char(unsigned char c);
   6396          extern void StartBuild();
   6397          void gcode_M565() {
   6398              start_after_download=true;
   6399              if (current_command_args[0]==0)
   6400              {
   6401                StartBuild();
   6402                MYSERIAL.flush();
   6403                store_char('\r');
   6404                enqueuecommands_P(PSTR("M23 cache.gc"));
   6405                enqueuecommands_P(PSTR("M24"));
   6406                return;
   6407              }
   6408          
   6409              wifi_writeString((char *)"{H:");
   6410              if (current_command_args[4]==':')
   6411                  wifi_writeString(current_command_args+7);
   6412              else wifi_writeString(current_command_args);
   6413              wifi_writeString((char *)"}");
   6414              return;
   6415          }
   6416          
   6417          //M566 Rename cached file
   6418          void gcode_M566()
   6419          {
   6420              if (current_command_args[0]!=0)
   6421              {
   6422                  f_rename("\\cache.gc", current_command_args);
   6423              }
   6424          }
   6425          
   6426          inline void putc(char c)
   6427          {
   6428            while(USART_GetFlagStatus(WIFI_UART, USART_FLAG_TXE) == RESET);
   6429            USART_SendData(WIFI_UART,c);
   6430          }
   6431          
   6432          void puts(uint8_t* s,uint16_t len)
   6433          {
   6434            uint16_t i;
   6435            for (i=0;i<len;i++) putc(s[i]);
   6436          }
   6437          
   6438          void sync()
   6439          {
   6440            uint8_t i;
   6441            const uint8_t sync_packet[]={
   6442              0xC0,0, 8, 36, 0, 0, 0, 0, 0, 7, 7, 18, 32};
   6443            puts((uint8_t*)sync_packet,sizeof(sync_packet));
   6444            for (i=0;i<32;i++) putc(0x55);
   6445            putc(0xC0);
   6446          }
   6447          
   6448          #include "ff.h"
   6449          #include "integer.h"
   6450          
   6451          void update_LCD()
   6452          {
   6453              int ret;
   6454              int i;
   6455              USART_InitTypeDef USART_InitStructure;
   6456              extern bool wifi_download;
   6457              extern volatile int16_t wifi_w_buff_ptr;
   6458              extern void serial_init(int);
   6459          
   6460              IWDG_ReloadCounter();
   6461              card.initsd();
   6462              if (card.cardOK != true) card.initsd();
   6463              if (card.cardOK != true) card.initsd();
   6464              FIL fil;
   6465              IWDG_ReloadCounter();
   6466              if (f_open(&fil, "lcdm.bin", FA_READ) == FR_OK)
   6467              {
   6468                  uint8_t buffer[128];
   6469                  UINT br;
   6470          
   6471                  SET_OUTPUT(FAN_PIN);
   6472          
   6473                  serial_init(115200);
   6474          
   6475                  //USART_Cmd(USART1, DISABLE);
   6476                  wifi_download=1;
   6477                  wifi_w_buff_ptr=0;
   6478          
   6479                  IWDG_ReloadCounter();
   6480                  delay(100);
   6481                  IWDG_ReloadCounter();
   6482          
   6483                  i=0;
   6484                  while (wifi_w_buff_ptr==0)
   6485                  //for (i=0;i<10;i++)
   6486                  {
   6487                    i++;
   6488                    IWDG_ReloadCounter();
   6489                    if (i>100)
   6490                    {
   6491                        WRITE(FAN_PIN,LOW);
   6492                        while (1){IWDG_ReloadCounter();}
   6493                    }
   6494                    sync();
   6495                    delay(10);
   6496                  }
   6497          
   6498                  delay(500);
   6499                  f_read(&fil, buffer, 26, &br);
   6500                  wifi_w_buff_ptr=0;
   6501                  puts(buffer,26);
   6502                  i=0;
   6503                  while (wifi_w_buff_ptr==0)
   6504                  {
   6505                      IWDG_ReloadCounter();
   6506                      if (i++>100)
   6507                      {
   6508                          WRITE(FAN_PIN,LOW);
   6509                          while (1){IWDG_ReloadCounter();}
   6510                      }
   6511                      delay(100);
   6512                  }
   6513          
   6514                  WRITE(FAN_PIN,HIGH);
   6515                  do {
   6516                      IWDG_ReloadCounter();
   6517                      wifi_w_buff_ptr=0;
   6518                      f_read(&fil, buffer, sizeof(buffer), &br);
   6519                      puts(buffer,br);
   6520                      //delay(1);
   6521                  } while (br==sizeof(buffer) && !f_eof(&fil));
   6522          
   6523                  wifi_download=0;
   6524                  WRITE(FAN_PIN,LOW);
   6525                  delay(3000);
   6526              }
   6527          }
   6528          
   6529          #if ENABLED(MESH_BED_LEVELING)
   6530          #ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
   6531          extern "C" void PowerOff(void);
   6532          void recal_probe()
   6533          {
   6534              PowerOff();
   6535          
   6536              NVIC_InitTypeDef NVIC_InitStructure;
   6537              NVIC_InitStructure.NVIC_IRQChannel = USB_IRQn;
   6538              NVIC_InitStructure.NVIC_IRQChannelPriority = 3;
   6539              NVIC_InitStructure.NVIC_IRQChannelCmd = DISABLE;
   6540              NVIC_Init(&NVIC_InitStructure);
   6541              
   6542              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USB, ENABLE);
   6543          
   6544              GPIO_InitTypeDef GPIO_InitStructure;
   6545              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
   6546              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
   6547              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
   6548              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
   6549              
   6550              GPIO_Init(GPIOA, &GPIO_InitStructure);
   6551              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
   6552              GPIO_Init(GPIOA, &GPIO_InitStructure);
   6553              
   6554              delay(100);
   6555              RCC_APB1PeriphResetCmd(RCC_APB1Periph_USB, DISABLE);
   6556          
   6557              enable_endstops(false);
   6558              
   6559              current_position[2] = 0;
   6560              sync_plan_position();
   6561              
   6562              for (unsigned char i=0;i<3;i++) destination[i]=current_position[i];
   6563              destination[2] = -100.0;
   6564              feedrate = homing_feedrate[2];
   6565              line_to_destination();
   6566              
   6567              while (blocks_queued())
   6568              {
   6569                  IWDG_ReloadCounter();
   6570                  if (!GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11))
   6571                  {
   6572                      quickStop();
   6573                      
   6574                      float distance = st_get_position_mm(Z_AXIS);
   6575                      /*SERIAL_PROTOCOLPGM(" Z:");
   6576                      SERIAL_PROTOCOL(distance);
   6577                      SERIAL_EOL;*/
   6578                      
   6579                      if (recal_probe_offset>-3.0f && recal_probe_offset<3.0f) zprobe_zoffset = distance+recal_probe_offset;
   6580                      else zprobe_zoffset = distance+0.5f;
   6581                      
   6582                      float diff = zprobe_zoffset - mbl.z_values[0][0];
   6583                      mbl.z_values[0][0] += diff;
   6584                      mbl.z_values[0][1] += diff;
   6585                      mbl.z_values[1][0] += diff;
   6586                      mbl.z_values[1][1] += diff;
   6587                      
   6588                      Config_StoreSettings();
   6589                      
   6590                      while (1);
   6591                      delay(1000);
   6592                      
   6593                      return;
   6594                  }
   6595                  /*if (GPIO_ReadInputDataBit(GPIOA, GPIO_Pin_11)) {disable_y();}
   6596                  else {enable_y();}*/
   6597              }
   6598          
   6599          }
   6600            inline void gcode_SET_Z_PROBE_OFFSET() {
   6601              SERIAL_ECHO_START;
   6602              SERIAL_ECHOPGM(MSG_ZPROBE_ZOFFSET);
   6603              SERIAL_CHAR(' ');
   6604          
   6605              if (code_seen('Z')) {
   6606                float value = code_value();
   6607                if (Z_PROBE_OFFSET_RANGE_MIN <= value && value <= Z_PROBE_OFFSET_RANGE_MAX) {
   6608                  zprobe_zoffset = value;
   6609                  //delay(10);
   6610                  float diff = zprobe_zoffset - mbl.z_values[0][0];
   6611                  mbl.z_values[0][0] += diff;
   6612                  mbl.z_values[0][1] += diff;
   6613                  mbl.z_values[1][0] += diff;
   6614                  mbl.z_values[1][1] += diff;
   6615                  //
   6616                  SERIAL_ECHOPGM(MSG_OK);
   6617                }
   6618                else {
   6619                  SERIAL_ECHOPGM(MSG_Z_MIN);
   6620                  SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MIN);
   6621                  SERIAL_ECHOPGM(MSG_Z_MAX);
   6622                  SERIAL_ECHO(Z_PROBE_OFFSET_RANGE_MAX);
   6623                }
   6624              }
   6625              else {
   6626                SERIAL_ECHOPAIR(": ", zprobe_zoffset);
   6627              }
   6628          
   6629              SERIAL_EOL;
   6630            }
   6631          #endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
   6632          #else
   6633          void recal_probe(){}
   6634          #endif
   6635          
   6636          #if ENABLED(FILAMENTCHANGEENABLE)
   6637          
   6638            /**
   6639             * M600: Pause for filament change
   6640             *
   6641             *  E[distance] - Retract the filament this far (negative value)
   6642             *  Z[distance] - Move the Z axis by this distance
   6643             *  X[position] - Move to this X position, with Y
   6644             *  Y[position] - Move to this Y position, with X
   6645             *  L[distance] - Retract distance for removal (manual reload)
   6646             *
   6647             *  Default values are used for omitted arguments.
   6648             *
   6649             */
   6650          volatile uint8_t m600_resume;
   6651          void gcode_M600() {
   6652          
   6653              /*if (degHotend(active_extruder) < EXTRUDE_MINTEMP) {
   6654                SERIAL_ERROR_START;
   6655                SERIAL_ERRORLNPGM(MSG_TOO_COLD_FOR_M600);
   6656                return;
   6657              }*/
   6658              m600_resume=0;
   6659          
   6660              float lastpos[NUM_AXIS], fr60 = feedrate / 60;
   6661          
   6662              for (int i = 0; i < NUM_AXIS; i++)
   6663                lastpos[i] = destination[i] = current_position[i];
   6664          
   6665              #if ENABLED(DELTA)
   6666                #define RUNPLAN calculate_delta(destination); \
   6667                                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
   6668              #else
   6669                #define RUNPLAN line_to_destination();
   6670              #endif
   6671          
   6672              //retract by E
   6673              if (code_seen('E')) destination[E_AXIS] += code_value();
   6674              #ifdef FILAMENTCHANGE_FIRSTRETRACT
   6675                else destination[E_AXIS] += FILAMENTCHANGE_FIRSTRETRACT;
   6676              #endif
   6677          
   6678              RUNPLAN;
   6679          
   6680              //lift Z
   6681              if (code_seen('Z')) destination[Z_AXIS] += code_value();
   6682              #ifdef FILAMENTCHANGE_ZADD
   6683                else destination[Z_AXIS] += FILAMENTCHANGE_ZADD;
   6684              #endif
   6685          
   6686              RUNPLAN;
   6687          
   6688              //move xy
   6689              if (code_seen('X')) destination[X_AXIS] = code_value();
   6690              #ifdef FILAMENTCHANGE_XPOS
   6691                else destination[X_AXIS] = FILAMENTCHANGE_XPOS;
   6692              #endif
   6693          
   6694              if (code_seen('Y')) destination[Y_AXIS] = code_value();
   6695              #ifdef FILAMENTCHANGE_YPOS
   6696                else destination[Y_AXIS] = FILAMENTCHANGE_YPOS;
   6697              #endif
   6698          
   6699              RUNPLAN;
   6700          
   6701              if (code_seen('L')) destination[E_AXIS] += code_value();
   6702              #ifdef FILAMENTCHANGE_FINALRETRACT
   6703                else destination[E_AXIS] += FILAMENTCHANGE_FINALRETRACT;
   6704              #endif
   6705          
   6706              RUNPLAN;
   6707          
   6708              //finish moves
   6709              st_synchronize();
   6710              wifi_writeString((char *)"{SYS:PAUSED}");
   6711              //disable extruder steppers so filament can be removed
   6712              disable_e0();
   6713              disable_e1();
   6714              disable_e2();
   6715              disable_e3();
   6716              delay(100);
   6717              //LCD_ALERTMESSAGEPGM(MSG_FILAMENTCHANGE);
   6718              millis_t next_tick = millis()+10000;
   6719          
   6720              while (m600_resume==0) {
   6721                #if DISABLED(AUTO_FILAMENT_CHANGE)
   6722                  /*millis_t ms = millis();
   6723                  if (ms >= next_tick) {
   6724                    lcd_quick_feedback();
   6725                    next_tick = ms + 2500; // feedback every 2.5s while waiting
   6726                  }*/
   6727                  idle();
   6728                #else
   6729          #error 1
   6730                  current_position[E_AXIS] += AUTO_FILAMENT_CHANGE_LENGTH;
   6731                  destination[E_AXIS] = current_position[E_AXIS];
   6732                  line_to_destination(AUTO_FILAMENT_CHANGE_FEEDRATE);
   6733                  st_synchronize();
   6734                #endif
   6735              } // while(!lcd_clicked)
   6736              //lcd_quick_feedback(); // click sound feedback
   6737          
   6738              #if ENABLED(AUTO_FILAMENT_CHANGE)
   6739                current_position[E_AXIS] = 0;
   6740                st_synchronize();
   6741              #endif
   6742          
   6743              //return to normal
   6744              if (code_seen('L')) destination[E_AXIS] -= code_value();
   6745              #ifdef FILAMENTCHANGE_FINALRETRACT
   6746                else destination[E_AXIS] -= FILAMENTCHANGE_FINALRETRACT;
   6747              #endif
   6748              
   6749              current_position[E_AXIS] = destination[E_AXIS]; //the long retract of L is compensated by manual filament feeding
   6750              plan_set_e_position(current_position[E_AXIS]);
   6751          
   6752              RUNPLAN; //should do nothing
   6753          
   6754              //lcd_reset_alert_level();
   6755          
   6756              #if ENABLED(DELTA)
   6757                // Move XYZ to starting position, then E
   6758                calculate_delta(lastpos);
   6759                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], destination[E_AXIS], fr60, active_extruder);
   6760                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], lastpos[E_AXIS], fr60, active_extruder);
   6761              #else
   6762                // Move XY to starting position, then Z, then E
   6763                destination[X_AXIS] = lastpos[X_AXIS];
   6764                destination[Y_AXIS] = lastpos[Y_AXIS];
   6765                line_to_destination();
   6766                destination[Z_AXIS] = lastpos[Z_AXIS];
   6767                line_to_destination();
   6768                destination[E_AXIS] = lastpos[E_AXIS];
   6769                line_to_destination();
   6770              #endif
   6771          
   6772              #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   6773                filrunoutEnqueued = false;
   6774              #endif
   6775          
   6776            }
   6777          
   6778          #endif // FILAMENTCHANGEENABLE
   6779          
   6780          #if ENABLED(DUAL_X_CARRIAGE)
   6781          
   6782            /**
   6783             * M605: Set dual x-carriage movement mode
   6784             *
   6785             *    M605 S0: Full control mode. The slicer has full control over x-carriage movement
   6786             *    M605 S1: Auto-park mode. The inactive head will auto park/unpark without slicer involvement
   6787             *    M605 S2 [Xnnn] [Rmmm]: Duplication mode. The second extruder will duplicate the first with nnn
   6788             *                         millimeters x-offset and an optional differential hotend temperature of
   6789             *                         mmm degrees. E.g., with "M605 S2 X100 R2" the second extruder will duplicate
   6790             *                         the first with a spacing of 100mm in the x direction and 2 degrees hotter.
   6791             *
   6792             *    Note: the X axis should be homed after changing dual x-carriage mode.
   6793             */
   6794            inline void gcode_M605() {
   6795              st_synchronize();
   6796              if (code_seen('S')) dual_x_carriage_mode = code_value();
   6797              switch (dual_x_carriage_mode) {
   6798                case DXC_DUPLICATION_MODE:
   6799                  if (code_seen('X')) duplicate_extruder_x_offset = max(code_value(), X2_MIN_POS - x_home_pos(0));
   6800                  if (code_seen('R')) duplicate_extruder_temp_offset = code_value();
   6801                  SERIAL_ECHO_START;
   6802                  SERIAL_ECHOPGM(MSG_HOTEND_OFFSET);
   6803                  SERIAL_CHAR(' ');
   6804                  SERIAL_ECHO(extruder_offset[X_AXIS][0]);
   6805                  SERIAL_CHAR(',');
   6806                  SERIAL_ECHO(extruder_offset[Y_AXIS][0]);
   6807                  SERIAL_CHAR(' ');
   6808                  SERIAL_ECHO(duplicate_extruder_x_offset);
   6809                  SERIAL_CHAR(',');
   6810                  SERIAL_ECHOLN(extruder_offset[Y_AXIS][1]);
   6811                  break;
   6812                case DXC_FULL_CONTROL_MODE:
   6813                case DXC_AUTO_PARK_MODE:
   6814                  break;
   6815                default:
   6816                  dual_x_carriage_mode = DEFAULT_DUAL_X_CARRIAGE_MODE;
   6817                  break;
   6818              }
   6819              active_extruder_parked = false;
   6820              extruder_duplication_enabled = false;
   6821              delayed_move_time = 0;
   6822            }
   6823          
   6824          #endif // DUAL_X_CARRIAGE
   6825          
   6826          /**
   6827           * M907: Set digital trimpot motor current using axis codes X, Y, Z, E, B, S
   6828           */
   6829          inline void gcode_M907() {
   6830            #if HAS_DIGIPOTSS
   6831              for (int i = 0; i < NUM_AXIS; i++)
   6832                if (code_seen(axis_codes[i])) digipot_current(i, code_value());
   6833              if (code_seen('B')) digipot_current(4, code_value());
   6834              if (code_seen('S')) for (int i = 0; i <= 4; i++) digipot_current(i, code_value());
   6835            #endif
   6836            #ifdef MOTOR_CURRENT_PWM_XY_PIN
   6837              if (code_seen('X')) digipot_current(0, code_value());
   6838            #endif
   6839            #ifdef MOTOR_CURRENT_PWM_Z_PIN
   6840              if (code_seen('Z')) digipot_current(1, code_value());
   6841            #endif
   6842            #ifdef MOTOR_CURRENT_PWM_E_PIN
   6843              if (code_seen('E')) digipot_current(2, code_value());
   6844            #endif
   6845            #if ENABLED(DIGIPOT_I2C)
   6846              // this one uses actual amps in floating point
   6847              for (int i = 0; i < NUM_AXIS; i++) if (code_seen(axis_codes[i])) digipot_i2c_set_current(i, code_value());
   6848              // for each additional extruder (named B,C,D,E..., channels 4,5,6,7...)
   6849              for (int i = NUM_AXIS; i < DIGIPOT_I2C_NUM_CHANNELS; i++) if (code_seen('B' + i - NUM_AXIS)) digipot_i2c_set_current(i, code_value());
   6850            #endif
   6851          }
   6852          
   6853          #if HAS_DIGIPOTSS
   6854          
   6855            /**
   6856             * M908: Control digital trimpot directly (M908 P<pin> S<current>)
   6857             */
   6858            inline void gcode_M908() {
   6859              digitalPotWrite(
   6860                code_seen('P') ? code_value() : 0,
   6861                code_seen('S') ? code_value() : 0
   6862              );
   6863            }
   6864          
   6865          #endif // HAS_DIGIPOTSS
   6866          
   6867          #if HAS_MICROSTEPS
   6868          
   6869            // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
   6870            inline void gcode_M350() {
   6871              if (code_seen('S')) for (int i = 0; i <= 4; i++) microstep_mode(i, code_value());
   6872              for (int i = 0; i < NUM_AXIS; i++) if (code_seen(axis_codes[i])) microstep_mode(i, (uint8_t)code_value());
   6873              if (code_seen('B')) microstep_mode(4, code_value());
   6874              microstep_readings();
   6875            }
   6876          
   6877            /**
   6878             * M351: Toggle MS1 MS2 pins directly with axis codes X Y Z E B
   6879             *       S# determines MS1 or MS2, X# sets the pin high/low.
   6880             */
   6881            inline void gcode_M351() {
   6882              if (code_seen('S')) switch (code_value_short()) {
   6883                case 1:
   6884                  for (int i = 0; i < NUM_AXIS; i++) if (code_seen(axis_codes[i])) microstep_ms(i, code_value(), -1);
   6885                  if (code_seen('B')) microstep_ms(4, code_value(), -1);
   6886                  break;
   6887                case 2:
   6888                  for (int i = 0; i < NUM_AXIS; i++) if (code_seen(axis_codes[i])) microstep_ms(i, -1, code_value());
   6889                  if (code_seen('B')) microstep_ms(4, -1, code_value());
   6890                  break;
   6891              }
   6892              microstep_readings();
   6893            }
   6894          
   6895          #endif // HAS_MICROSTEPS
   6896          
   6897          /**
   6898           * M999: Restart after being stopped
   6899           */
   6900          inline void gcode_M999() {
   6901            Running = true;
   6902            //lcd_reset_alert_level();
   6903            // gcode_LastN = Stopped_gcode_LastN;
   6904            FlushSerialRequestResend();
   6905          
   6906            if (code_seen('S') && code_value_short()==8731)       //yongzong
   6907            {
   6908              //printf("M999!\n");
   6909          
   6910            }
   6911          }
   6912          
   6913          /**
   6914           * T0-T3: Switch tool, usually switching extruders
   6915           *
   6916           *   F[mm/min] Set the movement feedrate
   6917           */
   6918          inline void gcode_T(uint8_t tmp_extruder) {
   6919            if (tmp_extruder >= EXTRUDERS) {
   6920              SERIAL_ECHO_START;
   6921              SERIAL_CHAR('T');
   6922              SERIAL_PROTOCOL_F(tmp_extruder, DEC);
   6923              SERIAL_ECHOLN(MSG_INVALID_EXTRUDER);
   6924            }
   6925            else {
   6926              target_extruder = tmp_extruder;
   6927          
   6928              //#if EXTRUDERS > 1
   6929                bool make_move = false;
   6930              //#endif
   6931          
   6932              if (code_seen('F')) {
   6933          
   6934                //#if EXTRUDERS > 1
   6935                  make_move = true;
   6936                //#endif
   6937          
   6938                float next_feedrate = code_value();
   6939                if (next_feedrate > 0.0) feedrate = next_feedrate;
   6940              }
   6941              //#if EXTRUDERS > 1
   6942              if (EXTRUDERS > 1)
   6943              {
   6944                if (tmp_extruder != active_extruder) {
   6945                  // Save current position to return to after applying extruder offset
   6946                  set_destination_to_current();
   6947                  #if ENABLED(DUAL_X_CARRIAGE)
   6948                    if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE && IsRunning() &&
   6949                        (delayed_move_time != 0 || current_position[X_AXIS] != x_home_pos(active_extruder))) {
   6950                      // Park old head: 1) raise 2) move to park position 3) lower
   6951                      plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
   6952                                       current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
   6953                      plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS] + TOOLCHANGE_PARK_ZLIFT,
   6954                                       current_position[E_AXIS], max_feedrate[X_AXIS], active_extruder);
   6955                      plan_buffer_line(x_home_pos(active_extruder), current_position[Y_AXIS], current_position[Z_AXIS],
   6956                                       current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
   6957                      st_synchronize();
   6958                    }
   6959          
   6960                    // apply Y & Z extruder offset (x offset is already used in determining home pos)
   6961                    current_position[Y_AXIS] = current_position[Y_AXIS] -
   6962                                               extruder_offset[Y_AXIS][active_extruder] +
   6963                                               extruder_offset[Y_AXIS][tmp_extruder];
   6964                    current_position[Z_AXIS] = current_position[Z_AXIS] -
   6965                                               extruder_offset[Z_AXIS][active_extruder] +
   6966                                               extruder_offset[Z_AXIS][tmp_extruder];
   6967                    active_extruder = tmp_extruder;
   6968          
   6969                    // This function resets the max/min values - the current position may be overwritten below.
   6970                    set_axis_is_at_home(X_AXIS);
   6971          
   6972                    if (dual_x_carriage_mode == DXC_FULL_CONTROL_MODE) {
   6973                      current_position[X_AXIS] = inactive_extruder_x_pos;
   6974                      inactive_extruder_x_pos = destination[X_AXIS];
   6975                    }
   6976                    else if (dual_x_carriage_mode == DXC_DUPLICATION_MODE) {
   6977                      active_extruder_parked = (active_extruder == 0); // this triggers the second extruder to move into the duplication position
   6978                      if (active_extruder == 0 || active_extruder_parked)
   6979                        current_position[X_AXIS] = inactive_extruder_x_pos;
   6980                      else
   6981                        current_position[X_AXIS] = destination[X_AXIS] + duplicate_extruder_x_offset;
   6982                      inactive_extruder_x_pos = destination[X_AXIS];
   6983                      extruder_duplication_enabled = false;
   6984                    }
   6985                    else {
   6986                      // record raised toolhead position for use by unpark
   6987                      memcpy(raised_parked_position, current_position, sizeof(raised_parked_position));
   6988                      raised_parked_position[Z_AXIS] += TOOLCHANGE_UNPARK_ZLIFT;
   6989                      active_extruder_parked = true;
   6990                      delayed_move_time = 0;
   6991                    }
   6992                  #else // !DUAL_X_CARRIAGE
   6993                    // Offset extruder (only by XY)
   6994                    for (int i = X_AXIS; i <= Y_AXIS; i++)
   6995                      current_position[i] += extruder_offset[i][tmp_extruder] - extruder_offset[i][active_extruder];
   6996                    // Set the new active extruder and position
   6997                    active_extruder = tmp_extruder;
   6998                  #endif // !DUAL_X_CARRIAGE
   6999                  #if ENABLED(DELTA)
   7000                    sync_plan_position_delta();
   7001                  #else
   7002                    sync_plan_position();
   7003                  #endif
   7004                  // Move to the old position if 'F' was in the parameters
   7005                  if (make_move && IsRunning()) prepare_move();
   7006                }
   7007          
   7008                #if ENABLED(EXT_SOLENOID)
   7009                  st_synchronize();
   7010                  disable_all_solenoids();
   7011                  enable_solenoid_on_active_extruder();
   7012                #endif // EXT_SOLENOID
   7013          
   7014              //#endif // EXTRUDERS > 1
   7015              }
   7016              SERIAL_ECHO_START;
   7017              SERIAL_ECHO(MSG_ACTIVE_EXTRUDER);
   7018              SERIAL_PROTOCOLLN((int)active_extruder);
   7019            }
   7020          }
   7021          
   7022          /**
   7023           * Process a single command and dispatch it to its handler
   7024           * This is called from the main loop()
   7025           */
   7026          void process_next_command() {
   7027            current_command = command_queue[cmd_queue_index_r];
   7028            procpos=curpos[cmd_queue_index_r];
   7029            if ((marlin_debug_flags & DEBUG_ECHO)) {
   7030              SERIAL_ECHO_START;
   7031              SERIAL_ECHOLN(current_command);
   7032            }
   7033          
   7034            // Sanitize the current command:
   7035            //  - Skip leading spaces
   7036            //  - Bypass N[0-9][0-9]*[ ]*
   7037            //  - Overwrite * with nul to mark the end
   7038            //while (*current_command >0x80 || *current_command <= ' ') ++current_command;
   7039            while (*current_command == ' ') ++current_command;
   7040            if (*current_command == 'N' && ((current_command[1] >= '0' && current_command[1] <= '9') || current_command[1] == '-')) {
   7041              current_command += 2; // skip N[-0-9]
   7042              while (*current_command >= '0' && *current_command <= '9') ++current_command; // skip [0-9]*
   7043              while (*current_command == ' ') ++current_command; // skip [ ]*
   7044            }
   7045            char* starpos = strchr(current_command, '*');  // * should always be the last parameter
   7046            if (starpos) while (*starpos == ' ' || *starpos == '*') *starpos-- = '\0'; // nullify '*' and ' '
   7047            
   7048            //YONGZONG: ADDED MACRO PROCESSING
   7049            if (current_command[0]=='#')
   7050            {
   7051              //SERIAL_ECHO("found #: ");
   7052              current_command++;
   7053              //SERIAL_ECHOLN(current_command);
   7054              
   7055              switch (current_command[0])
   7056              {
   7057                  case ('P'):
   7058                      if (current_command[1]=='R' && 
   7059                      current_command[2]=='I' &&
   7060                      current_command[3]=='N' &&
   7061                      current_command[4]=='T')
   7062                      {
   7063                        current_command+=5;
   7064                        while (*current_command == ' ') ++current_command;
   7065                        if (*current_command != 'R')
   7066                            SERIAL_ECHOLN(current_command);
   7067                        else
   7068                        {
   7069                            //current_command++;
   7070                            //if (*current_command == 'R')
   7071                            {
   7072                                seen_pointer=current_command;
   7073                                int codenum = code_value_short();
   7074                                MYSERIAL.write('R');
   7075                                MYSERIAL.print(codenum);
   7076                                MYSERIAL.write('=');
   7077                                MYSERIAL.print(R[codenum]);
   7078                                MYSERIAL.write('\n');
   7079                            }
   7080                        }
   7081                      }
   7082                      break;
   7083                      
   7084                  case ('L'):
   7085                      if (current_command[1]=='A' && 
   7086                      current_command[2]=='B' &&
   7087                      current_command[3]=='L' &&
   7088                      current_command[4]=='E')
   7089                      {
   7090                        current_command+=5;
   7091                        while (*current_command == ' ') ++current_command;
   7092                        
   7093                        if (current_command[0]=='L')
   7094                        {
   7095                            seen_pointer=current_command;
   7096                            int codenum = code_value_short();
   7097                            L[codenum]=curpos[cmd_queue_index_r];
   7098                        }
   7099                      }
   7100                      
   7101                      else if (current_command[1]=='O' && 
   7102                      current_command[2]=='A' &&
   7103                      current_command[3]=='D')
   7104                      {
   7105                          current_command+=4;
   7106                          while (*current_command == ' ') ++current_command;
   7107                          if (*current_command == 'R')
   7108                          {
   7109                              seen_pointer=current_command;
   7110                              int codenum = code_value_short();
   7111                              while (*seen_pointer != ' ') ++seen_pointer;
   7112                              R[codenum]=code_value_short();
   7113                          }
   7114                      }
   7115                      
   7116                      else if (current_command[1]=='O' && 
   7117                      current_command[2]=='O' &&
   7118                      current_command[3]=='P')
   7119                      {
   7120                          current_command+=4;
   7121                          while (*current_command == ' ') ++current_command;
   7122                          if (*current_command == 'R')
   7123                          {
   7124                              seen_pointer=current_command;
   7125                              int Rnum = code_value_short();
   7126                              
   7127                              while (*seen_pointer != ' ') ++seen_pointer;
   7128                              seen_pointer++;
   7129                              if (seen_pointer[0]=='L')
   7130                              {
   7131                                  int Lnum=code_value_short();
   7132                                  R[Rnum]--;
   7133                                  
   7134                                  if (R[Rnum]>0)
   7135                                  {
   7136                                      card.setIndex(L[Lnum]);
   7137                                  }
   7138                              }
   7139                          }
   7140                      }
   7141                      break;
   7142                      
   7143                  case ('J'):
   7144                      if ((current_command[1]=='M' && 
   7145                           current_command[2]=='P') || 
   7146                          (current_command[1]=='U' && 
   7147                           current_command[2]=='M' &&
   7148                           current_command[3]=='P'))
   7149                      {
   7150                          current_command+=4;
   7151                          while (*current_command == ' ') ++current_command;
   7152                          if (current_command[0]=='L')
   7153                          {
   7154                              seen_pointer=current_command;
   7155                              int codenum = code_value_short();
   7156                              card.setIndex(L[codenum]);
   7157                              
   7158                              //sdprinting=true;
   7159                              //commands_in_queue++;
   7160                              //cmd_queue_index_r = (cmd_queue_index_r + 1) % BUFSIZE;
   7161                          }
   7162                      }
   7163                      break;
   7164                      
   7165                        
   7166                  default:
   7167              }
   7168              
   7169              return;
   7170            }
   7171            
   7172            //
   7173          
   7174            // Get the command code, which must be G, M, or T
   7175            char command_code = *current_command;
   7176          
   7177            // The code must have a numeric value
   7178            bool code_is_good = (current_command[1] >= '0' && current_command[1] <= '9');
   7179          
   7180            int codenum; // define ahead of goto
   7181          
   7182            // Bail early if there's no code
   7183            if (!code_is_good) goto ExitUnknownCommand;
   7184          
   7185            // Args pointer optimizes code_seen, especially those taking XYZEF
   7186            // This wastes a little cpu on commands that expect no arguments.
   7187            current_command_args = current_command;
   7188            while (*current_command_args && *current_command_args != ' ') ++current_command_args;
   7189            while (*current_command_args == ' ') ++current_command_args;
   7190          
   7191            // Interpret the code int
   7192            seen_pointer = current_command;
   7193            codenum = code_value_short();
   7194          
   7195            // Handle a known G, M, or T
   7196            switch (command_code) {
   7197              case 'G': switch (codenum) {
   7198          
   7199                // G0, G1
   7200                case 0:
   7201                case 1:
   7202                  gcode_G0_G1();
   7203                  break;
   7204          
   7205                // G2, G3
   7206                #if DISABLED(SCARA)
   7207                  case 2: // G2  - CW ARC
   7208                  case 3: // G3  - CCW ARC
   7209                    gcode_G2_G3(codenum == 2);
   7210                    break;
   7211                #endif
   7212          
   7213                // G4 Dwell
   7214                case 4:
   7215                  gcode_G4();
   7216                  break;
   7217          
   7218                #if ENABLED(FWRETRACT)
   7219          
   7220                  case 10: // G10: retract
   7221                  case 11: // G11: retract_recover
   7222                    gcode_G10_G11(codenum == 10);
   7223                    break;
   7224          
   7225                #endif //FWRETRACT
   7226          
   7227                case 28: // G28: Home all axes, one at a time
   7228                  extern bool unlocked;
   7229                  
   7230                  if (unlocked==true) gcode_G28();
   7231          #if ENABLED(MESH_BED_LEVELING)
   7232                  mbl.active = 1;
   7233          #endif
   7234                  //if (homeZ) enqueuecommands_P(PSTR("G1 Z0"));
   7235                  break;
   7236          
   7237                #if ENABLED(AUTO_BED_LEVELING_FEATURE) || ENABLED(MESH_BED_LEVELING)
   7238                  case 29: // G29 Detailed Z probe, probes the bed at 3 or more points.
   7239                    gcode_G29();
   7240                    disable_all_steppers();
   7241                    break;
   7242                #endif
   7243                    
   7244          #if ENABLED(DELTA)
   7245                    case 30: // G30 Single Z probe
   7246                      gcode_G30();
   7247                      break;
   7248          #endif
   7249                      
   7250                #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   7251          
   7252                  #if DISABLED(Z_PROBE_SLED)
   7253          
   7254                    /*case 30: // G30 Single Z probe
   7255                      gcode_G30();
   7256                      break;*/
   7257          
   7258                  #else // Z_PROBE_SLED
   7259          
   7260                      case 31: // G31: dock the sled
   7261                      case 32: // G32: undock the sled
   7262                        dock_sled(codenum == 31);
   7263                        break;
   7264          
   7265                  #endif // Z_PROBE_SLED
   7266          
   7267                #endif // AUTO_BED_LEVELING_FEATURE
   7268          
   7269                case 90: // G90
   7270                  relative_mode = false;
   7271                  break;
   7272                case 91: // G91
   7273                  relative_mode = true;
   7274                  break;
   7275          
   7276                case 92: // G92
   7277                  gcode_G92();
   7278                  break;
   7279              }
   7280              break;
   7281          
   7282              case 'M': switch (codenum) {
   7283                #if ENABLED(ULTIPANEL)
   7284                  case 0: // M0 - Unconditional stop - Wait for user button press on LCD
   7285                  case 1: // M1 - Conditional stop - Wait for user button press on LCD
   7286                    gcode_M0_M1();
   7287                    break;
   7288                #endif // ULTIPANEL
   7289          
   7290                case 17:
   7291                  gcode_M17();
   7292                  break;
   7293          
   7294                #if ENABLED(SDSUPPORT)
   7295          
   7296                  case 20: // M20 - list SD card
   7297                    gcode_M20(); break;
   7298                  case 21: // M21 - init SD card
   7299                    gcode_M21(); break;
   7300                  case 22: //M22 - release SD card
   7301                    gcode_M22(); break;
   7302                  case 23: //M23 - Select file
   7303                    gcode_M23(); break;
   7304                  case 24: //M24 - Start SD print
   7305                    gcode_M24(); break;
   7306                  case 25: //M25 - Pause SD print
   7307                    gcode_M25(); break;
   7308                  case 26: //M26 - Set SD index
   7309                    gcode_M26(); break;
   7310                  case 27: //M27 - Get SD status
   7311                    gcode_M27(); break;
   7312                  case 28: //M28 - Start SD write
   7313                    gcode_M28(); break;
   7314                  case 29: //M29 - Stop SD write
   7315                    gcode_M29(); break;
   7316                  case 30: //M30 <filename> Delete File
   7317                    gcode_M30(); break;
   7318                  case 32: //M32 - Select file and start SD print
   7319                    gcode_M32(); break;
   7320          
   7321                  #if ENABLED(LONG_FILENAME_HOST_SUPPORT)
   7322                    case 33: //M33 - Get the long full path to a file or folder
   7323                      gcode_M33(); break;
   7324                  #endif // LONG_FILENAME_HOST_SUPPORT
   7325          
   7326                  case 928: //M928 - Start SD write
   7327                    gcode_M928(); break;
   7328          
   7329                #endif //SDSUPPORT
   7330          
   7331                case 31: //M31 take time since the start of the SD print or an M109 command
   7332                  gcode_M31();
   7333                  break;
   7334          
   7335                case 42: //M42 -Change pin status via gcode
   7336                  gcode_M42();
   7337                  break;
   7338          
   7339                #if ENABLED(AUTO_BED_LEVELING_FEATURE) && ENABLED(Z_MIN_PROBE_REPEATABILITY_TEST)
   7340                  case 48: // M48 Z probe repeatability
   7341                    gcode_M48();
   7342                    break;
   7343                #endif // AUTO_BED_LEVELING_FEATURE && Z_MIN_PROBE_REPEATABILITY_TEST
   7344          
   7345                #if ENABLED(M100_FREE_MEMORY_WATCHER)
   7346                  case 100:
   7347                    gcode_M100();
   7348                    break;
   7349                #endif
   7350          
   7351                case 104: // M104
   7352                  gcode_M104();
   7353                  break;
   7354          
   7355                case 111: // M111: Set debug level
   7356                  gcode_M111();
   7357                  break;
   7358          
   7359                case 112: // M112: Emergency Stop
   7360                  gcode_M112();
   7361                  break;
   7362          
   7363                case 140: // M140: Set bed temp
   7364                  gcode_M140();
   7365                  break;
   7366          
   7367                case 105: // M105: Read current temperature
   7368                  gcode_M105();
   7369                  return; // "ok" already printed
   7370          
   7371                case 109: // M109: Wait for temperature
   7372                  gcode_M109();
   7373                  break;
   7374          
   7375                #if HAS_TEMP_BED
   7376                  case 190: // M190: Wait for bed heater to reach target
   7377                    gcode_M190();
   7378                    break;
   7379                #endif // HAS_TEMP_BED
   7380          
   7381                #if HAS_FAN
   7382                  case 106: // M106: Fan On
   7383                    gcode_M106();
   7384                    break;
   7385                  case 107: // M107: Fan Off
   7386                    gcode_M107();
   7387                    break;
   7388                #endif // HAS_FAN
   7389          
   7390                #if ENABLED(BARICUDA)
   7391                  // PWM for HEATER_1_PIN
   7392                  #if HAS_HEATER_1
   7393                    case 126: // M126: valve open
   7394                      gcode_M126();
   7395                      break;
   7396                    case 127: // M127: valve closed
   7397                      gcode_M127();
   7398                      break;
   7399                  #endif // HAS_HEATER_1
   7400          
   7401                  // PWM for HEATER_2_PIN
   7402                  #if HAS_HEATER_2
   7403                    case 128: // M128: valve open
   7404                      gcode_M128();
   7405                      break;
   7406                    case 129: // M129: valve closed
   7407                      gcode_M129();
   7408                      break;
   7409                  #endif // HAS_HEATER_2
   7410                #endif // BARICUDA
   7411          
   7412                #if HAS_POWER_SWITCH
   7413          
   7414                  case 80: // M80: Turn on Power Supply
   7415                    gcode_M80();
   7416                    break;
   7417          
   7418                #endif // HAS_POWER_SWITCH
   7419          
   7420                case 81: // M81: Turn off Power, including Power Supply, if possible
   7421                  gcode_M81();
   7422                  break;
   7423          
   7424                case 82:
   7425                  gcode_M82();
   7426                  break;
   7427                case 83:
   7428                  gcode_M83();
   7429                  break;
   7430                case 18: // (for compatibility)
   7431                case 84: // M84
   7432                  gcode_M18_M84();
   7433                  break;
   7434                case 85: // M85
   7435                  gcode_M85();
   7436                  break;
   7437                case 92: // M92: Set the steps-per-unit for one or more axes
   7438                  gcode_M92();
   7439                  break;
   7440                case 115: // M115: Report capabilities
   7441                  gcode_M115();
   7442                  break;
   7443                case 117: // M117: Set LCD message text, if possible
   7444                  gcode_M117();
   7445                  break;
   7446                case 114: // M114: Report current position
   7447                  gcode_M114();
   7448                  break;
   7449                case 120: // M120: Enable endstops
   7450                  gcode_M120();
   7451                  break;
   7452                case 121: // M121: Disable endstops
   7453                  gcode_M121();
   7454                  break;
   7455                case 119: // M119: Report endstop states
   7456                  gcode_M119();
   7457                  break;
   7458          
   7459                #if ENABLED(ULTIPANEL)
   7460          
   7461                  case 145: // M145: Set material heatup parameters
   7462                    gcode_M145();
   7463                    break;
   7464          
   7465                #endif
   7466          
   7467                #if ENABLED(BLINKM)
   7468          
   7469                  case 150: // M150
   7470                    gcode_M150();
   7471                    break;
   7472          
   7473                #endif //BLINKM
   7474          
   7475                case 200: // M200 D<millimeters> set filament diameter and set E axis units to cubic millimeters (use S0 to set back to millimeters).
   7476                  gcode_M200();
   7477                  break;
   7478                case 201: // M201
   7479                  gcode_M201();
   7480                  break;
   7481                #if 0 // Not used for Sprinter/grbl gen6
   7482                  case 202: // M202
   7483                    gcode_M202();
   7484                    break;
   7485                #endif
   7486                case 203: // M203 max feedrate mm/sec
   7487                  gcode_M203();
   7488                  break;
   7489                case 204: // M204 acclereration S normal moves T filmanent only moves
   7490                  gcode_M204();
   7491                  break;
   7492                case 205: //M205 advanced settings:  minimum travel speed S=while printing T=travel only,  B=minimum segment time X= maximum xy jerk, Z=maximum Z jerk
   7493                  gcode_M205();
   7494                  break;
   7495                case 206: // M206 additional homing offset
   7496                  gcode_M206();
   7497                  break;
   7498          
   7499                #if ENABLED(DELTA)
   7500                  case 665: // M665 set delta configurations L<diagonal_rod> R<delta_radius> S<segments_per_sec>
   7501                    gcode_M665();
   7502                    break;
   7503                #endif
   7504          
   7505                #if ENABLED(DELTA) || ENABLED(Z_DUAL_ENDSTOPS)
   7506                  case 666: // M666 set delta / dual endstop adjustment
   7507                    gcode_M666();
   7508                    break;
   7509                #endif
   7510          
   7511                #if ENABLED(FWRETRACT)
   7512                  case 207: //M207 - set retract length S[positive mm] F[feedrate mm/min] Z[additional zlift/hop]
   7513                    gcode_M207();
   7514                    break;
   7515                  case 208: // M208 - set retract recover length S[positive mm surplus to the M207 S*] F[feedrate mm/min]
   7516                    gcode_M208();
   7517                    break;
   7518                  case 209: // M209 - S<1=true/0=false> enable automatic retract detect if the slicer did not support G10/11: every normal extrude-only move will be classified as retract depending on the direction.
   7519                    gcode_M209();
   7520                    break;
   7521                #endif // FWRETRACT
   7522          
   7523                //#if EXTRUDERS > 1
   7524                  case 218: // M218 - set hotend offset (in mm), T<extruder_number> X<offset_on_X> Y<offset_on_Y>
   7525                    gcode_M218();
   7526                    break;
   7527                //#endif
   7528          
   7529                case 220: // M220 S<factor in percent>- set speed factor override percentage
   7530                  gcode_M220();
   7531                  break;
   7532          
   7533                case 221: // M221 S<factor in percent>- set extrude factor override percentage
   7534                  gcode_M221();
   7535                  break;
   7536          
   7537                case 226: // M226 P<pin number> S<pin state>- Wait until the specified pin reaches the state required
   7538                  gcode_M226();
   7539                  break;
   7540          
   7541                #if HAS_SERVOS
   7542                  case 280: // M280 - set servo position absolute. P: servo index, S: angle or microseconds
   7543                    gcode_M280();
   7544                    break;
   7545                #endif // HAS_SERVOS
   7546          
   7547                #if HAS_BUZZER
   7548                  case 300: // M300 - Play beep tone
   7549                    gcode_M300();
   7550                    break;
   7551                #endif // HAS_BUZZER
   7552          
   7553                #if ENABLED(PIDTEMP)
   7554                  case 301: // M301
   7555                    gcode_M301();
   7556                    break;
   7557                #endif // PIDTEMP
   7558          
   7559                #if ENABLED(PIDTEMPBED)
   7560                  case 304: // M304
   7561                    gcode_M304();
   7562                    break;
   7563                #endif // PIDTEMPBED
   7564          
   7565                #if defined(CHDK) || HAS_PHOTOGRAPH
   7566                  case 240: // M240  Triggers a camera by emulating a Canon RC-1 : http://www.doc-diy.net/photo/rc-1_hacked/
   7567                    gcode_M240();
   7568                    break;
   7569                #endif // CHDK || PHOTOGRAPH_PIN
   7570          
   7571                #if ENABLED(HAS_LCD_CONTRAST)
   7572                  case 250: // M250  Set LCD contrast value: C<value> (value 0..63)
   7573                    gcode_M250();
   7574                    break;
   7575                #endif // HAS_LCD_CONTRAST
   7576          
   7577                #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
   7578                  case 302: // allow cold extrudes, or set the minimum extrude temperature
   7579                    gcode_M302();
   7580                    break;
   7581                #endif // PREVENT_DANGEROUS_EXTRUDE
   7582          
   7583                case 303: // M303 PID autotune
   7584                  gcode_M303();
   7585                  break;
   7586          
   7587                #if ENABLED(SCARA)
   7588                  case 360:  // M360 SCARA Theta pos1
   7589                    if (gcode_M360()) return;
   7590                    break;
   7591                  case 361:  // M361 SCARA Theta pos2
   7592                    if (gcode_M361()) return;
   7593                    break;
   7594                  case 362:  // M362 SCARA Psi pos1
   7595                    if (gcode_M362()) return;
   7596                    break;
   7597                  case 363:  // M363 SCARA Psi pos2
   7598                    if (gcode_M363()) return;
   7599                    break;
   7600                  case 364:  // M364 SCARA Psi pos3 (90 deg to Theta)
   7601                    if (gcode_M364()) return;
   7602                    break;
   7603                  case 365: // M365 Set SCARA scaling for X Y Z
   7604                    gcode_M365();
   7605                    break;
   7606                #endif // SCARA
   7607          
   7608                case 400: // M400 finish all moves
   7609                  gcode_M400();
   7610                  break;
   7611          
   7612                #if ENABLED(AUTO_BED_LEVELING_FEATURE) && (HAS_SERVO_ENDSTOPS || ENABLED(Z_PROBE_ALLEN_KEY)) && DISABLED(Z_PROBE_SLED)
   7613                  case 401:
   7614                    gcode_M401();
   7615                    break;
   7616                  case 402:
   7617                    gcode_M402();
   7618                    break;
   7619                #endif // AUTO_BED_LEVELING_FEATURE && (HAS_SERVO_ENDSTOPS || Z_PROBE_ALLEN_KEY) && !Z_PROBE_SLED
   7620          
   7621                #if ENABLED(FILAMENT_SENSOR)
   7622                  case 404:  //M404 Enter the nominal filament width (3mm, 1.75mm ) N<3.0> or display nominal filament width
   7623                    gcode_M404();
   7624                    break;
   7625                  case 405:  //M405 Turn on filament sensor for control
   7626                    gcode_M405();
   7627                    break;
   7628                  case 406:  //M406 Turn off filament sensor for control
   7629                    gcode_M406();
   7630                    break;
   7631                  case 407:   //M407 Display measured filament diameter
   7632                    gcode_M407();
   7633                    break;
   7634                #endif // FILAMENT_SENSOR
   7635          
   7636                case 410: // M410 quickstop - Abort all the planned moves.
   7637                  gcode_M410();
   7638                  break;
   7639          
   7640                #if ENABLED(MESH_BED_LEVELING)
   7641                  case 420: // M420 Enable/Disable Mesh Bed Leveling
   7642                    gcode_M420();
   7643                    break;
   7644                  case 421: // M421 Set a Mesh Bed Leveling Z coordinate
   7645                    gcode_M421();
   7646                    break;
   7647                #endif
   7648          
   7649                case 428: // M428 Apply current_position to home_offset
   7650                  gcode_M428();
   7651                  break;
   7652          
   7653                case 500: // M500 Store settings in EEPROM
   7654                  gcode_M500();
   7655                  break;
   7656                case 501: // M501 Read settings from EEPROM
   7657                  gcode_M501();
   7658                  break;
   7659                case 502: // M502 Revert to default settings
   7660                  gcode_M502();
   7661                  break;
   7662                case 503: // M503 print settings currently in memory
   7663                  gcode_M503();
   7664                  break;
   7665          
   7666                #if ENABLED(ABORT_ON_ENDSTOP_HIT_FEATURE_ENABLED)
   7667                  case 540:
   7668                    gcode_M540();
   7669                    break;
   7670                #endif
   7671          
   7672                case 550: // M550 SSID
   7673                  gcode_M550();
   7674                  break;
   7675          
   7676                case 551: // M551 Password
   7677                  gcode_M551();
   7678                  break;
   7679          
   7680                case 552: // M552 IP
   7681                  gcode_M552();
   7682                  break;
   7683          
   7684                case 553: // M553 Netmask
   7685                  gcode_M553();
   7686                  break;
   7687          
   7688                case 554: // M554 Gateway
   7689                  gcode_M554();
   7690                  break;
   7691          
   7692                case 555: // M555 Wifi control
   7693                  gcode_M555();
   7694                  break;
   7695          
   7696                case 556: // M556 Network status
   7697                  gcode_M556();
   7698                  break;
   7699          
   7700                case 557: // M557 Mac Address
   7701                  gcode_M557();
   7702                  break;
   7703          
   7704                case 560: // M560 Update
   7705                  gcode_M560();
   7706                  break;
   7707          
   7708                case 561: // M561 Change thermistor type
   7709                  gcode_M561();
   7710                  break;
   7711          
   7712                case 562: // M562 Invert axis
   7713                  gcode_M562();
   7714                  break;
   7715          
   7716                case 563: // M563 Update LCD
   7717                  gcode_M563();
   7718                  break;
   7719          
   7720                case 564: // M564 HTTP Download
   7721                  gcode_M564();
   7722                  break;
   7723          
   7724                case 565: // M565 Print cached file
   7725                  gcode_M565();
   7726                  break;
   7727          
   7728                case 566: // M566 Rename cached file
   7729                  gcode_M566();
   7730                  break;
   7731          #if ENABLED(MESH_BED_LEVELING)
   7732                #ifdef CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
   7733                  case CUSTOM_M_CODE_SET_Z_PROBE_OFFSET:
   7734                    gcode_SET_Z_PROBE_OFFSET();
   7735                    break;
   7736                #endif // CUSTOM_M_CODE_SET_Z_PROBE_OFFSET
   7737          #endif
   7738                    
   7739                #if ENABLED(FILAMENTCHANGEENABLE)
   7740                  case 600: //Pause for filament change X[pos] Y[pos] Z[relative lift] E[initial retract] L[later retract distance for removal]
   7741                    gcode_M600();
   7742                    break;
   7743                #endif // FILAMENTCHANGEENABLE
   7744          
   7745                #if ENABLED(DUAL_X_CARRIAGE)
   7746                  case 605:
   7747                    gcode_M605();
   7748                    break;
   7749                #endif // DUAL_X_CARRIAGE
   7750          
   7751                case 907: // M907 Set digital trimpot motor current using axis codes.
   7752                  gcode_M907();
   7753                  break;
   7754          
   7755                #if HAS_DIGIPOTSS
   7756                  case 908: // M908 Control digital trimpot directly.
   7757                    gcode_M908();
   7758                    break;
   7759                #endif // HAS_DIGIPOTSS
   7760          
   7761                #if HAS_MICROSTEPS
   7762          
   7763                  case 350: // M350 Set microstepping mode. Warning: Steps per unit remains unchanged. S code sets stepping mode for all drivers.
   7764                    gcode_M350();
   7765                    break;
   7766          
   7767                  case 351: // M351 Toggle MS1 MS2 pins directly, S# determines MS1 or MS2, X# sets the pin high/low.
   7768                    gcode_M351();
   7769                    break;
   7770          
   7771                #endif // HAS_MICROSTEPS
   7772          
   7773                //yongzong
   7774                case 800:
   7775                  extern void USB_enable(uint8_t en);
   7776                  USB_enable(0);
   7777                  break;
   7778                case 801:
   7779                  USB_enable(1);
   7780                  break;
   7781          
   7782                case 999: // M999: Restart after being Stopped
   7783                  gcode_M999();
   7784                  break;
   7785              }
   7786              break;
   7787          
   7788              case 'T':
   7789                gcode_T(codenum);
   7790                break;
   7791          
   7792              default: code_is_good = false;
   7793            }
   7794          
   7795          ExitUnknownCommand:
   7796          
   7797            if (current_command[0]==0) return;
   7798            // Still unknown command? Throw an error
   7799            if (!code_is_good) unknown_command_error();
   7800          
   7801            ok_to_send();
   7802          }
   7803          
   7804          void FlushSerialRequestResend() {
   7805            //char command_queue[cmd_queue_index_r][100]="Resend:";
   7806            //MYSERIAL.flush();
   7807            SERIAL_PROTOCOLPGM(MSG_RESEND);
   7808            SERIAL_PROTOCOLLN(gcode_LastN + 1);
   7809            ok_to_send();
   7810          }
   7811          
   7812          void ok_to_send() {
   7813            refresh_cmd_timeout();
   7814            #if ENABLED(SDSUPPORT)
   7815              if (fromsd[cmd_queue_index_r]) return;
   7816            #endif
   7817          
   7818            //SERIAL_PROTOCOLCHAR((uint8_t)0);
   7819            //delay(10);
   7820            SERIAL_PROTOCOLPGM(MSG_OK);
   7821            #if ENABLED(ADVANCED_OK)
   7822              SERIAL_PROTOCOLPGM(" N"); SERIAL_PROTOCOL(gcode_LastN);
   7823              SERIAL_PROTOCOLPGM(" P"); SERIAL_PROTOCOL(int(BLOCK_BUFFER_SIZE - movesplanned() - 1));
   7824              SERIAL_PROTOCOLPGM(" B"); SERIAL_PROTOCOL(BUFSIZE - commands_in_queue);
   7825            #endif
   7826            SERIAL_EOL;
   7827          }
   7828          
   7829          void clamp_to_software_endstops(float target[3]) {
   7830            if (min_software_endstops) {
   7831              NOLESS(target[X_AXIS], min_pos[X_AXIS]);
   7832              NOLESS(target[Y_AXIS], min_pos[Y_AXIS]);
   7833          
   7834              float negative_z_offset = 0;
   7835              //#if ENABLED(AUTO_BED_LEVELING_FEATURE)
   7836                if (zprobe_zoffset < 0) negative_z_offset += zprobe_zoffset;
   7837                if (home_offset[Z_AXIS] < 0) {
   7838                  #if ENABLED(DEBUG_LEVELING_FEATURE)
   7839                    if (marlin_debug_flags & DEBUG_LEVELING) {
   7840                      SERIAL_ECHOPAIR("> clamp_to_software_endstops > Add home_offset[Z_AXIS]:", home_offset[Z_AXIS]);
   7841                      SERIAL_EOL;
   7842                    }
   7843                  #endif
   7844                  negative_z_offset += home_offset[Z_AXIS];
   7845                }
   7846              //#endif
   7847              NOLESS(target[Z_AXIS], min_pos[Z_AXIS] + negative_z_offset);
   7848            }
   7849          
   7850            if (max_software_endstops) {
   7851              NOMORE(target[X_AXIS], max_pos[X_AXIS]);
   7852              NOMORE(target[Y_AXIS], max_pos[Y_AXIS]);
   7853              NOMORE(target[Z_AXIS], max_pos[Z_AXIS]);
   7854            }
   7855          }
   7856          
   7857          #if ENABLED(DELTA)
   7858          
   7859            void recalc_delta_settings(float radius, float diagonal_rod) {
   7860              delta_tower1_x = -SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);  // front left tower
   7861              delta_tower1_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_1);
   7862              delta_tower2_x =  SIN_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);  // front right tower
   7863              delta_tower2_y = -COS_60 * (radius + DELTA_RADIUS_TRIM_TOWER_2);
   7864              delta_tower3_x = 0.0;                                             // back middle tower
   7865              delta_tower3_y = (radius + DELTA_RADIUS_TRIM_TOWER_3);
   7866              delta_diagonal_rod_2_tower_1 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_1);
   7867              delta_diagonal_rod_2_tower_2 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_2);
   7868              delta_diagonal_rod_2_tower_3 = sq(delta_diagonal_rod + delta_diagonal_rod_trim_tower_3);
   7869            }
   7870          
   7871            void calculate_delta(float cartesian[3]) {
   7872          
   7873              delta[TOWER_1] = sqrt(delta_diagonal_rod_2_tower_1
   7874                                    - sq(delta_tower1_x - cartesian[X_AXIS])
   7875                                    - sq(delta_tower1_y - cartesian[Y_AXIS])
   7876                                   ) + cartesian[Z_AXIS];
   7877              delta[TOWER_2] = sqrt(delta_diagonal_rod_2_tower_2
   7878                                    - sq(delta_tower2_x - cartesian[X_AXIS])
   7879                                    - sq(delta_tower2_y - cartesian[Y_AXIS])
   7880                                   ) + cartesian[Z_AXIS];
   7881              delta[TOWER_3] = sqrt(delta_diagonal_rod_2_tower_3
   7882                                    - sq(delta_tower3_x - cartesian[X_AXIS])
   7883                                    - sq(delta_tower3_y - cartesian[Y_AXIS])
   7884                                   ) + cartesian[Z_AXIS];
   7885              /*
   7886              SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
   7887              SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
   7888              SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
   7889          
   7890              SERIAL_ECHOPGM("delta a="); SERIAL_ECHO(delta[TOWER_1]);
   7891              SERIAL_ECHOPGM(" b="); SERIAL_ECHO(delta[TOWER_2]);
   7892              SERIAL_ECHOPGM(" c="); SERIAL_ECHOLN(delta[TOWER_3]);
   7893              */
   7894            }
   7895          
   7896            #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   7897          
   7898              // Adjust print surface height by linear interpolation over the bed_level array.
   7899              void adjust_delta(float cartesian[3]) {
   7900                if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
   7901          
   7902                int half = (auto_bed_leveling_grid_points - 1) / 2;
   7903                float h1 = 0.001 - half, h2 = half - 0.001,
   7904                      grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
   7905                      grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
   7906                int floor_x = floor(grid_x), floor_y = floor(grid_y);
   7907                float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
   7908                      z1 = bed_level[floor_x + half][floor_y + half],
   7909                      z2 = bed_level[floor_x + half][floor_y + half + 1],
   7910                      z3 = bed_level[floor_x + half + 1][floor_y + half],
   7911                      z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
   7912                      left = (1 - ratio_y) * z1 + ratio_y * z2,
   7913                      right = (1 - ratio_y) * z3 + ratio_y * z4,
   7914                      offset = (1 - ratio_x) * left + ratio_x * right;
   7915          
   7916                delta[X_AXIS] += offset;
   7917                delta[Y_AXIS] += offset;
   7918                delta[Z_AXIS] += offset;
   7919          
   7920                /*
   7921                SERIAL_ECHOPGM("grid_x="); SERIAL_ECHO(grid_x);
   7922                SERIAL_ECHOPGM(" grid_y="); SERIAL_ECHO(grid_y);
   7923                SERIAL_ECHOPGM(" floor_x="); SERIAL_ECHO(floor_x);
   7924                SERIAL_ECHOPGM(" floor_y="); SERIAL_ECHO(floor_y);
   7925                SERIAL_ECHOPGM(" ratio_x="); SERIAL_ECHO(ratio_x);
   7926                SERIAL_ECHOPGM(" ratio_y="); SERIAL_ECHO(ratio_y);
   7927                SERIAL_ECHOPGM(" z1="); SERIAL_ECHO(z1);
   7928                SERIAL_ECHOPGM(" z2="); SERIAL_ECHO(z2);
   7929                SERIAL_ECHOPGM(" z3="); SERIAL_ECHO(z3);
   7930                SERIAL_ECHOPGM(" z4="); SERIAL_ECHO(z4);
   7931                SERIAL_ECHOPGM(" left="); SERIAL_ECHO(left);
   7932                SERIAL_ECHOPGM(" right="); SERIAL_ECHO(right);
   7933                SERIAL_ECHOPGM(" offset="); SERIAL_ECHOLN(offset);
   7934                */
   7935              }
   7936            #endif // AUTO_BED_LEVELING_FEATURE
   7937          
   7938          #endif // DELTA
   7939          
   7940          #if ENABLED(MESH_BED_LEVELING)
   7941          
   7942          // This function is used to split lines on mesh borders so each segment is only part of one mesh area
   7943          void mesh_plan_buffer_line(float x, float y, float z, const float e, float feed_rate, const uint8_t& extruder, uint8_t x_splits = 0xff, uint8_t y_splits = 0xff) {
   7944            if (!mbl.active) {
   7945              plan_buffer_line(x, y, z, e, feed_rate, extruder);
   7946              set_current_to_destination();
   7947              return;
   7948            }
   7949            int pix = mbl.select_x_index(current_position[X_AXIS]);
   7950            int piy = mbl.select_y_index(current_position[Y_AXIS]);
   7951            int ix = mbl.select_x_index(x);
   7952            int iy = mbl.select_y_index(y);
   7953            pix = min(pix, MESH_NUM_X_POINTS - 2);
   7954            piy = min(piy, MESH_NUM_Y_POINTS - 2);
   7955            ix = min(ix, MESH_NUM_X_POINTS - 2);
   7956            iy = min(iy, MESH_NUM_Y_POINTS - 2);
   7957            if (pix == ix && piy == iy) {
   7958              // Start and end on same mesh square
   7959              plan_buffer_line(x, y, z, e, feed_rate, extruder);
   7960              set_current_to_destination();
   7961              return;
   7962            }
   7963            float nx, ny, ne, normalized_dist;
   7964            if (ix > pix && (x_splits) & BIT(ix)) {
   7965              nx = mbl.get_x(ix);
   7966              normalized_dist = (nx - current_position[X_AXIS]) / (x - current_position[X_AXIS]);
   7967              ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;
   7968              ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;
   7969              x_splits ^= BIT(ix);
   7970            }
   7971            else if (ix < pix && (x_splits) & BIT(pix)) {
   7972              nx = mbl.get_x(pix);
   7973              normalized_dist = (nx - current_position[X_AXIS]) / (x - current_position[X_AXIS]);
   7974              ny = current_position[Y_AXIS] + (y - current_position[Y_AXIS]) * normalized_dist;
   7975              ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;
   7976              x_splits ^= BIT(pix);
   7977            }
   7978            else if (iy > piy && (y_splits) & BIT(iy)) {
   7979              ny = mbl.get_y(iy);
   7980              normalized_dist = (ny - current_position[Y_AXIS]) / (y - current_position[Y_AXIS]);
   7981              nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;
   7982              ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;
   7983              y_splits ^= BIT(iy);
   7984            }
   7985            else if (iy < piy && (y_splits) & BIT(piy)) {
   7986              ny = mbl.get_y(piy);
   7987              normalized_dist = (ny - current_position[Y_AXIS]) / (y - current_position[Y_AXIS]);
   7988              nx = current_position[X_AXIS] + (x - current_position[X_AXIS]) * normalized_dist;
   7989              ne = current_position[E_AXIS] + (e - current_position[E_AXIS]) * normalized_dist;
   7990              y_splits ^= BIT(piy);
   7991            }
   7992            else {
   7993              // Already split on a border
   7994              plan_buffer_line(x, y, z, e, feed_rate, extruder);
   7995              set_current_to_destination();
   7996              return;
   7997            }
   7998            // Do the split and look for more borders
   7999            destination[X_AXIS] = nx;
   8000            destination[Y_AXIS] = ny;
   8001            destination[E_AXIS] = ne;
   8002            mesh_plan_buffer_line(nx, ny, z, ne, feed_rate, extruder, x_splits, y_splits);
   8003            destination[X_AXIS] = x;
   8004            destination[Y_AXIS] = y;
   8005            destination[E_AXIS] = e;
   8006            mesh_plan_buffer_line(x, y, z, e, feed_rate, extruder, x_splits, y_splits);
   8007          }
   8008          #endif  // MESH_BED_LEVELING
   8009          
   8010          #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
   8011          
   8012            inline void prevent_dangerous_extrude(float& curr_e, float& dest_e) {
   8013              if (marlin_debug_flags & DEBUG_DRYRUN) return;
   8014              float de = dest_e - curr_e;
   8015              if (de) {
   8016                if (degHotend(active_extruder) < extrude_min_temp) {
   8017                  curr_e = dest_e; // Behave as if the move really took place, but ignore E part
   8018                  SERIAL_ECHO_START;
   8019                  SERIAL_ECHOLNPGM(MSG_ERR_COLD_EXTRUDE_STOP);
   8020                }
   8021                #if ENABLED(PREVENT_LENGTHY_EXTRUDE)
   8022                  if (labs(de) > EXTRUDE_MAXLENGTH) {
   8023                    curr_e = dest_e; // Behave as if the move really took place, but ignore E part
   8024                    SERIAL_ECHO_START;
   8025                    SERIAL_ECHOLNPGM(MSG_ERR_LONG_EXTRUDE_STOP);
   8026                  }
   8027                #endif
   8028              }
   8029            }
   8030          
   8031          #endif // PREVENT_DANGEROUS_EXTRUDE
   8032          
   8033          #if ENABLED(DELTA) || ENABLED(SCARA)
   8034          
   8035            inline bool prepare_move_delta(float target[NUM_AXIS]) {
   8036              float difference[NUM_AXIS];
   8037              for (int8_t i = 0; i < NUM_AXIS; i++) difference[i] = target[i] - current_position[i];
   8038          
   8039              float cartesian_mm = sqrt(sq(difference[X_AXIS]) + sq(difference[Y_AXIS]) + sq(difference[Z_AXIS]));
   8040              if (cartesian_mm < 0.000001) cartesian_mm = abs(difference[E_AXIS]);
   8041              if (cartesian_mm < 0.000001) return false;
   8042              float seconds = 6000 * cartesian_mm / feedrate / feedrate_multiplier;
   8043              int steps = max(1, int(delta_segments_per_second * seconds));
   8044          
   8045              // SERIAL_ECHOPGM("mm="); SERIAL_ECHO(cartesian_mm);
   8046              // SERIAL_ECHOPGM(" seconds="); SERIAL_ECHO(seconds);
   8047              // SERIAL_ECHOPGM(" steps="); SERIAL_ECHOLN(steps);
   8048          
   8049              for (int s = 1; s <= steps; s++) {
   8050          
   8051                float fraction = float(s) / float(steps);
   8052          
   8053                for (int8_t i = 0; i < NUM_AXIS; i++)
   8054                  target[i] = current_position[i] + difference[i] * fraction;
   8055          
   8056                calculate_delta(target);
   8057          
   8058                #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   8059                  adjust_delta(target);
   8060                #endif
   8061          
   8062                //SERIAL_ECHOPGM("target[X_AXIS]="); SERIAL_ECHOLN(target[X_AXIS]);
   8063                //SERIAL_ECHOPGM("target[Y_AXIS]="); SERIAL_ECHOLN(target[Y_AXIS]);
   8064                //SERIAL_ECHOPGM("target[Z_AXIS]="); SERIAL_ECHOLN(target[Z_AXIS]);
   8065                //SERIAL_ECHOPGM("delta[X_AXIS]="); SERIAL_ECHOLN(delta[X_AXIS]);
   8066                //SERIAL_ECHOPGM("delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
   8067                //SERIAL_ECHOPGM("delta[Z_AXIS]="); SERIAL_ECHOLN(delta[Z_AXIS]);
   8068          
   8069                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feedrate / 60 * feedrate_multiplier / 100.0, active_extruder);
   8070              }
   8071              return true;
   8072            }
   8073          
   8074          #endif // DELTA || SCARA
   8075          
   8076          #if ENABLED(SCARA)
   8077            inline bool prepare_move_scara(float target[NUM_AXIS]) { return prepare_move_delta(target); }
   8078          #endif
   8079          
   8080          #if ENABLED(DUAL_X_CARRIAGE)
   8081          
   8082            inline bool prepare_move_dual_x_carriage() {
   8083              if (active_extruder_parked) {
   8084                if (dual_x_carriage_mode == DXC_DUPLICATION_MODE && active_extruder == 0) {
   8085                  // move duplicate extruder into correct duplication position.
   8086                  plan_set_position(inactive_extruder_x_pos, current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS]);
   8087                  plan_buffer_line(current_position[X_AXIS] + duplicate_extruder_x_offset,
   8088                                   current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[X_AXIS], 1);
   8089                  sync_plan_position();
   8090                  st_synchronize();
   8091                  extruder_duplication_enabled = true;
   8092                  active_extruder_parked = false;
   8093                }
   8094                else if (dual_x_carriage_mode == DXC_AUTO_PARK_MODE) { // handle unparking of head
   8095                  if (current_position[E_AXIS] == destination[E_AXIS]) {
   8096                    // This is a travel move (with no extrusion)
   8097                    // Skip it, but keep track of the current position
   8098                    // (so it can be used as the start of the next non-travel move)
   8099                    if (delayed_move_time != 0xFFFFFFFFUL) {
   8100                      set_current_to_destination();
   8101                      NOLESS(raised_parked_position[Z_AXIS], destination[Z_AXIS]);
   8102                      delayed_move_time = millis();
   8103                      return false;
   8104                    }
   8105                  }
   8106                  delayed_move_time = 0;
   8107                  // unpark extruder: 1) raise, 2) move into starting XY position, 3) lower
   8108                  plan_buffer_line(raised_parked_position[X_AXIS], raised_parked_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
   8109                  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], raised_parked_position[Z_AXIS], current_position[E_AXIS], min(max_feedrate[X_AXIS], max_feedrate[Y_AXIS]), active_extruder);
   8110                  plan_buffer_line(current_position[X_AXIS], current_position[Y_AXIS], current_position[Z_AXIS], current_position[E_AXIS], max_feedrate[Z_AXIS], active_extruder);
   8111                  active_extruder_parked = false;
   8112                }
   8113              }
   8114              return true;
   8115            }
   8116          
   8117          #endif // DUAL_X_CARRIAGE
   8118          
   8119          #if DISABLED(DELTA) && DISABLED(SCARA)
   8120          /*
   8121          float adjust_cartesian(float cartesian[3]) {
   8122                if (delta_grid_spacing[0] == 0 || delta_grid_spacing[1] == 0) return; // G29 not done!
   8123          
   8124                int half = (auto_bed_leveling_grid_points - 1) / 2;
   8125                float h1 = 0.001 - half, h2 = half - 0.001,
   8126                      grid_x = max(h1, min(h2, cartesian[X_AXIS] / delta_grid_spacing[0])),
   8127                      grid_y = max(h1, min(h2, cartesian[Y_AXIS] / delta_grid_spacing[1]));
   8128                int floor_x = floor(grid_x), floor_y = floor(grid_y);
   8129                float ratio_x = grid_x - floor_x, ratio_y = grid_y - floor_y,
   8130                      z1 = bed_level[floor_x + half][floor_y + half],
   8131                      z2 = bed_level[floor_x + half][floor_y + half + 1],
   8132                      z3 = bed_level[floor_x + half + 1][floor_y + half],
   8133                      z4 = bed_level[floor_x + half + 1][floor_y + half + 1],
   8134                      left = (1 - ratio_y) * z1 + ratio_y * z2,
   8135                      right = (1 - ratio_y) * z3 + ratio_y * z4,
   8136                      offset = (1 - ratio_x) * left + ratio_x * right;
   8137          
   8138                //delta[Z_AXIS] += offset;
   8139                return offset;
   8140          }*/
   8141            inline bool prepare_move_cartesian() {
   8142              // Do not use feedrate_multiplier for E or Z only moves
   8143              if (current_position[X_AXIS] == destination[X_AXIS] && current_position[Y_AXIS] == destination[Y_AXIS]) {
   8144                line_to_destination();
   8145              }
   8146              else {
   8147                #if ENABLED(MESH_BED_LEVELING)
   8148                  mesh_plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS], destination[E_AXIS], (feedrate / 60) * (feedrate_multiplier / 100.0), active_extruder);
   8149                  return false;
   8150                #else
   8151                  line_to_destination(feedrate * feedrate_multiplier / 100.0);
   8152                #endif
   8153              }
   8154              return true;
   8155            }
   8156          
   8157          #endif // !DELTA && !SCARA
   8158          
   8159          /**
   8160           * Prepare a single move and get ready for the next one
   8161           *
   8162           * (This may call plan_buffer_line several times to put
   8163           *  smaller moves into the planner for DELTA or SCARA.)
   8164           */
   8165          void prepare_move() {
   8166            clamp_to_software_endstops(destination);
   8167            refresh_cmd_timeout();
   8168          
   8169            #if ENABLED(PREVENT_DANGEROUS_EXTRUDE)
   8170              prevent_dangerous_extrude(current_position[E_AXIS], destination[E_AXIS]);
   8171            #endif
   8172          
   8173            #if ENABLED(SCARA)
   8174              if (!prepare_move_scara(destination)) return;
   8175            #elif ENABLED(DELTA)
   8176              if (!prepare_move_delta(destination)) return;
   8177            #endif
   8178          
   8179            #if ENABLED(DUAL_X_CARRIAGE)
   8180              if (!prepare_move_dual_x_carriage()) return;
   8181            #endif
   8182          
   8183            #if DISABLED(DELTA) && DISABLED(SCARA)
   8184              if (!prepare_move_cartesian()) return;
   8185            #endif
   8186          
   8187            set_current_to_destination();
   8188          }
   8189          
   8190          /**
   8191           * Plan an arc in 2 dimensions
   8192           *
   8193           * The arc is approximated by generating many small linear segments.
   8194           * The length of each segment is configured in MM_PER_ARC_SEGMENT (Default 1mm)
   8195           * Arcs should only be made relatively large (over 5mm), as larger arcs with
   8196           * larger segments will tend to be more efficient. Your slicer should have
   8197           * options for G2/G3 arc generation. In future these options may be GCode tunable.
   8198           */
   8199          void plan_arc(
   8200            float target[NUM_AXIS], // Destination position
   8201            float* offset,          // Center of rotation relative to current_position
   8202            uint8_t clockwise       // Clockwise?
   8203          ) {
   8204          
   8205            float radius = hypot(offset[X_AXIS], offset[Y_AXIS]),
   8206                  center_axis0 = current_position[X_AXIS] + offset[X_AXIS],
   8207                  center_axis1 = current_position[Y_AXIS] + offset[Y_AXIS],
   8208                  linear_travel = target[Z_AXIS] - current_position[Z_AXIS],
   8209                  extruder_travel = target[E_AXIS] - current_position[E_AXIS],
   8210                  r_axis0 = -offset[X_AXIS],  // Radius vector from center to current location
   8211                  r_axis1 = -offset[Y_AXIS],
   8212                  rt_axis0 = target[X_AXIS] - center_axis0,
   8213                  rt_axis1 = target[Y_AXIS] - center_axis1;
   8214          
   8215            // CCW angle of rotation between position and target from the circle center. Only one atan2() trig computation required.
   8216            float angular_travel = atan2(r_axis0 * rt_axis1 - r_axis1 * rt_axis0, r_axis0 * rt_axis0 + r_axis1 * rt_axis1);
   8217            if (angular_travel < 0)  angular_travel += RADIANS(360);
   8218            if (clockwise)  angular_travel -= RADIANS(360);
   8219          
   8220            // Make a circle if the angular rotation is 0
   8221            if (current_position[X_AXIS] == target[X_AXIS] && current_position[Y_AXIS] == target[Y_AXIS] && angular_travel == 0)
   8222              angular_travel += RADIANS(360);
   8223          
   8224            float mm_of_travel = hypot(angular_travel * radius, fabs(linear_travel));
   8225            if (mm_of_travel < 0.001)  return;
   8226            uint16_t segments = floor(mm_of_travel / MM_PER_ARC_SEGMENT);
   8227            if (segments == 0) segments = 1;
   8228          
   8229            float theta_per_segment = angular_travel / segments;
   8230            float linear_per_segment = linear_travel / segments;
   8231            float extruder_per_segment = extruder_travel / segments;
   8232          
   8233            /* Vector rotation by transformation matrix: r is the original vector, r_T is the rotated vector,
   8234               and phi is the angle of rotation. Based on the solution approach by Jens Geisler.
   8235                   r_T = [cos(phi) -sin(phi);
   8236                          sin(phi)  cos(phi] * r ;
   8237          
   8238               For arc generation, the center of the circle is the axis of rotation and the radius vector is
   8239               defined from the circle center to the initial position. Each line segment is formed by successive
   8240               vector rotations. This requires only two cos() and sin() computations to form the rotation
   8241               matrix for the duration of the entire arc. Error may accumulate from numerical round-off, since
   8242               all double numbers are single precision on the Arduino. (True double precision will not have
   8243               round off issues for CNC applications.) Single precision error can accumulate to be greater than
   8244               tool precision in some cases. Therefore, arc path correction is implemented.
   8245          
   8246               Small angle approximation may be used to reduce computation overhead further. This approximation
   8247               holds for everything, but very small circles and large MM_PER_ARC_SEGMENT values. In other words,
   8248               theta_per_segment would need to be greater than 0.1 rad and N_ARC_CORRECTION would need to be large
   8249               to cause an appreciable drift error. N_ARC_CORRECTION~=25 is more than small enough to correct for
   8250               numerical drift error. N_ARC_CORRECTION may be on the order a hundred(s) before error becomes an
   8251               issue for CNC machines with the single precision Arduino calculations.
   8252          
   8253               This approximation also allows plan_arc to immediately insert a line segment into the planner
   8254               without the initial overhead of computing cos() or sin(). By the time the arc needs to be applied
   8255               a correction, the planner should have caught up to the lag caused by the initial plan_arc overhead.
   8256               This is important when there are successive arc motions.
   8257            */
   8258            // Vector rotation matrix values
   8259            float cos_T = 1 - 0.5 * theta_per_segment * theta_per_segment; // Small angle approximation
   8260            float sin_T = theta_per_segment;
   8261          
   8262            float arc_target[NUM_AXIS];
   8263            float sin_Ti;
   8264            float cos_Ti;
   8265            float r_axisi;
   8266            uint16_t i;
   8267            int8_t count = 0;
   8268          
   8269            // Initialize the linear axis
   8270            arc_target[Z_AXIS] = current_position[Z_AXIS];
   8271          
   8272            // Initialize the extruder axis
   8273            arc_target[E_AXIS] = current_position[E_AXIS];
   8274          
   8275            float feed_rate = feedrate * feedrate_multiplier / 6000.0;
   8276          
   8277            for (i = 1; i < segments; i++) { // Increment (segments-1)
   8278          
   8279              if (count < N_ARC_CORRECTION) {
   8280                // Apply vector rotation matrix to previous r_axis0 / 1
   8281                r_axisi = r_axis0 * sin_T + r_axis1 * cos_T;
   8282                r_axis0 = r_axis0 * cos_T - r_axis1 * sin_T;
   8283                r_axis1 = r_axisi;
   8284                count++;
   8285              }
   8286              else {
   8287                // Arc correction to radius vector. Computed only every N_ARC_CORRECTION increments.
   8288                // Compute exact location by applying transformation matrix from initial radius vector(=-offset).
   8289                cos_Ti = cos(i * theta_per_segment);
   8290                sin_Ti = sin(i * theta_per_segment);
   8291                r_axis0 = -offset[X_AXIS] * cos_Ti + offset[Y_AXIS] * sin_Ti;
   8292                r_axis1 = -offset[X_AXIS] * sin_Ti - offset[Y_AXIS] * cos_Ti;
   8293                count = 0;
   8294              }
   8295          
   8296              // Update arc_target location
   8297              arc_target[X_AXIS] = center_axis0 + r_axis0;
   8298              arc_target[Y_AXIS] = center_axis1 + r_axis1;
   8299              arc_target[Z_AXIS] += linear_per_segment;
   8300              arc_target[E_AXIS] += extruder_per_segment;
   8301          
   8302              clamp_to_software_endstops(arc_target);
   8303          
   8304              #if ENABLED(DELTA) || ENABLED(SCARA)
   8305                calculate_delta(arc_target);
   8306                #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   8307                  adjust_delta(arc_target);
   8308                #endif
   8309                plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);
   8310              #else
   8311                plan_buffer_line(arc_target[X_AXIS], arc_target[Y_AXIS], arc_target[Z_AXIS], arc_target[E_AXIS], feed_rate, active_extruder);
   8312              #endif
   8313            }
   8314          
   8315            // Ensure last segment arrives at target location.
   8316            #if ENABLED(DELTA) || ENABLED(SCARA)
   8317              calculate_delta(target);
   8318              #if ENABLED(AUTO_BED_LEVELING_FEATURE)
   8319                adjust_delta(target);
   8320              #endif
   8321              plan_buffer_line(delta[X_AXIS], delta[Y_AXIS], delta[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);
   8322            #else
   8323              plan_buffer_line(target[X_AXIS], target[Y_AXIS], target[Z_AXIS], target[E_AXIS], feed_rate, active_extruder);
   8324            #endif
   8325          
   8326            // As far as the parser is concerned, the position is now == target. In reality the
   8327            // motion control system might still be processing the action and the real tool position
   8328            // in any intermediate location.
   8329            set_current_to_destination();
   8330          }
   8331          
   8332          #if HAS_CONTROLLERFAN
   8333          
   8334            void controllerFan() {
   8335              static millis_t lastMotor = 0;      // Last time a motor was turned on
   8336              static millis_t lastMotorCheck = 0; // Last time the state was checked
   8337              millis_t ms = millis();
   8338              if (ms >= lastMotorCheck + 2500) { // Not a time critical function, so we only check every 2500ms
   8339                lastMotorCheck = ms;
   8340                if (X_ENABLE_READ == X_ENABLE_ON || Y_ENABLE_READ == Y_ENABLE_ON || Z_ENABLE_READ == Z_ENABLE_ON || soft_pwm_bed > 0
   8341                    || E0_ENABLE_READ == E_ENABLE_ON // If any of the drivers are enabled...
   8342                      || (EXTRUDERS > 1 && E1_ENABLE_READ == E_ENABLE_ON)
   8343                      /*#if EXTRUDERS > 1
   8344                      || E1_ENABLE_READ == E_ENABLE_ON
   8345                      #if HAS_X2_ENABLE
   8346                        || X2_ENABLE_READ == X_ENABLE_ON
   8347                      #endif
   8348                      #if EXTRUDERS > 2
   8349                        || E2_ENABLE_READ == E_ENABLE_ON
   8350                        #if EXTRUDERS > 3
   8351                          || E3_ENABLE_READ == E_ENABLE_ON
   8352                        #endif
   8353                      #endif
   8354                    #endif*/
   8355                ) {
   8356                  lastMotor = ms; //... set time to NOW so the fan will turn on
   8357                }
   8358                uint8_t speed = (lastMotor == 0 || ms >= lastMotor + (CONTROLLERFAN_SECS * 1000UL)) ? 0 : CONTROLLERFAN_SPEED;
   8359                // allows digital or PWM fan output to be used (see M42 handling)
   8360                digitalWrite(CONTROLLERFAN_PIN, speed);
   8361                analogWrite(CONTROLLERFAN_PIN, speed);
   8362              }
   8363            }
   8364          
   8365          #endif // HAS_CONTROLLERFAN
   8366          
   8367          #if ENABLED(SCARA)
   8368          
   8369            void calculate_SCARA_forward_Transform(float f_scara[3]) {
   8370              // Perform forward kinematics, and place results in delta[3]
   8371              // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
   8372          
   8373              float x_sin, x_cos, y_sin, y_cos;
   8374          
   8375              //SERIAL_ECHOPGM("f_delta x="); SERIAL_ECHO(f_scara[X_AXIS]);
   8376              //SERIAL_ECHOPGM(" y="); SERIAL_ECHO(f_scara[Y_AXIS]);
   8377          
   8378              x_sin = sin(f_scara[X_AXIS] / SCARA_RAD2DEG) * Linkage_1;
   8379              x_cos = cos(f_scara[X_AXIS] / SCARA_RAD2DEG) * Linkage_1;
   8380              y_sin = sin(f_scara[Y_AXIS] / SCARA_RAD2DEG) * Linkage_2;
   8381              y_cos = cos(f_scara[Y_AXIS] / SCARA_RAD2DEG) * Linkage_2;
   8382          
   8383              //SERIAL_ECHOPGM(" x_sin="); SERIAL_ECHO(x_sin);
   8384              //SERIAL_ECHOPGM(" x_cos="); SERIAL_ECHO(x_cos);
   8385              //SERIAL_ECHOPGM(" y_sin="); SERIAL_ECHO(y_sin);
   8386              //SERIAL_ECHOPGM(" y_cos="); SERIAL_ECHOLN(y_cos);
   8387          
   8388              delta[X_AXIS] = x_cos + y_cos + SCARA_offset_x;  //theta
   8389              delta[Y_AXIS] = x_sin + y_sin + SCARA_offset_y;  //theta+phi
   8390          
   8391              //SERIAL_ECHOPGM(" delta[X_AXIS]="); SERIAL_ECHO(delta[X_AXIS]);
   8392              //SERIAL_ECHOPGM(" delta[Y_AXIS]="); SERIAL_ECHOLN(delta[Y_AXIS]);
   8393            }
   8394          
   8395            void calculate_delta(float cartesian[3]) {
   8396              //reverse kinematics.
   8397              // Perform reversed kinematics, and place results in delta[3]
   8398              // The maths and first version has been done by QHARLEY . Integrated into masterbranch 06/2014 and slightly restructured by Joachim Cerny in June 2014
   8399          
   8400              float SCARA_pos[2];
   8401              static float SCARA_C2, SCARA_S2, SCARA_K1, SCARA_K2, SCARA_theta, SCARA_psi;
   8402          
   8403              SCARA_pos[X_AXIS] = cartesian[X_AXIS] * axis_scaling[X_AXIS] - SCARA_offset_x;  //Translate SCARA to standard X Y
   8404              SCARA_pos[Y_AXIS] = cartesian[Y_AXIS] * axis_scaling[Y_AXIS] - SCARA_offset_y;  // With scaling factor.
   8405          
   8406              #if (Linkage_1 == Linkage_2)
   8407                SCARA_C2 = ((sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS])) / (2 * (float)L1_2)) - 1;
   8408              #else
   8409                SCARA_C2 = (sq(SCARA_pos[X_AXIS]) + sq(SCARA_pos[Y_AXIS]) - (float)L1_2 - (float)L2_2) / 45000;
   8410              #endif
   8411          
   8412              SCARA_S2 = sqrt(1 - sq(SCARA_C2));
   8413          
   8414              SCARA_K1 = Linkage_1 + Linkage_2 * SCARA_C2;
   8415              SCARA_K2 = Linkage_2 * SCARA_S2;
   8416          
   8417              SCARA_theta = (atan2(SCARA_pos[X_AXIS], SCARA_pos[Y_AXIS]) - atan2(SCARA_K1, SCARA_K2)) * -1;
   8418              SCARA_psi = atan2(SCARA_S2, SCARA_C2);
   8419          
   8420              delta[X_AXIS] = SCARA_theta * SCARA_RAD2DEG;  // Multiply by 180/Pi  -  theta is support arm angle
   8421              delta[Y_AXIS] = (SCARA_theta + SCARA_psi) * SCARA_RAD2DEG;  //       -  equal to sub arm angle (inverted motor)
   8422              delta[Z_AXIS] = cartesian[Z_AXIS];
   8423          
   8424              /*
   8425              SERIAL_ECHOPGM("cartesian x="); SERIAL_ECHO(cartesian[X_AXIS]);
   8426              SERIAL_ECHOPGM(" y="); SERIAL_ECHO(cartesian[Y_AXIS]);
   8427              SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(cartesian[Z_AXIS]);
   8428          
   8429              SERIAL_ECHOPGM("scara x="); SERIAL_ECHO(SCARA_pos[X_AXIS]);
   8430              SERIAL_ECHOPGM(" y="); SERIAL_ECHOLN(SCARA_pos[Y_AXIS]);
   8431          
   8432              SERIAL_ECHOPGM("delta x="); SERIAL_ECHO(delta[X_AXIS]);
   8433              SERIAL_ECHOPGM(" y="); SERIAL_ECHO(delta[Y_AXIS]);
   8434              SERIAL_ECHOPGM(" z="); SERIAL_ECHOLN(delta[Z_AXIS]);
   8435          
   8436              SERIAL_ECHOPGM("C2="); SERIAL_ECHO(SCARA_C2);
   8437              SERIAL_ECHOPGM(" S2="); SERIAL_ECHO(SCARA_S2);
   8438              SERIAL_ECHOPGM(" Theta="); SERIAL_ECHO(SCARA_theta);
   8439              SERIAL_ECHOPGM(" Psi="); SERIAL_ECHOLN(SCARA_psi);
   8440              SERIAL_EOL;
   8441              */
   8442            }
   8443          
   8444          #endif // SCARA
   8445          
   8446          #if ENABLED(TEMP_STAT_LEDS)
   8447          
   8448            static bool red_led = false;
   8449            static millis_t next_status_led_update_ms = 0;
   8450          
   8451            void handle_status_leds(void) {
   8452              float max_temp = 0.0;
   8453              if (millis() > next_status_led_update_ms) {
   8454                next_status_led_update_ms += 500; // Update every 0.5s
   8455                for (int8_t cur_extruder = 0; cur_extruder < EXTRUDERS; ++cur_extruder)
   8456                  max_temp = max(max(max_temp, degHotend(cur_extruder)), degTargetHotend(cur_extruder));
   8457                #if HAS_TEMP_BED
   8458                  max_temp = max(max(max_temp, degTargetBed()), degBed());
   8459                #endif
   8460                bool new_led = (max_temp > 55.0) ? true : (max_temp < 54.0) ? false : red_led;
   8461                if (new_led != red_led) {
   8462                  red_led = new_led;
   8463                  digitalWrite(STAT_LED_RED, new_led ? HIGH : LOW);
   8464                  digitalWrite(STAT_LED_BLUE, new_led ? LOW : HIGH);
   8465                }
   8466              }
   8467            }
   8468          
   8469          #endif
   8470          
   8471          void enable_all_steppers() {
   8472            enable_x();
   8473            enable_y();
   8474            enable_z();
   8475            enable_e0();
   8476            enable_e1();
   8477            enable_e2();
   8478            enable_e3();
   8479          }
   8480          
   8481          void disable_all_steppers() {
   8482            disable_x();
   8483            disable_y();
   8484            disable_z();
   8485            disable_e0();
   8486            disable_e1();
   8487            disable_e2();
   8488            disable_e3();
   8489          }
   8490          
   8491          /**
   8492           * Standard idle routine keeps the machine alive
   8493           */
   8494          void idle() {
   8495            manage_heater();
   8496            manage_inactivity();
   8497            extern void wifi_update();
   8498            wifi_update();
   8499            IWDG_ReloadCounter();
   8500          }
   8501          
   8502          /**
   8503           * Manage several activities:
   8504           *  - Check for Filament Runout
   8505           *  - Keep the command buffer full
   8506           *  - Check for maximum inactive time between commands
   8507           *  - Check for maximum inactive time between stepper commands
   8508           *  - Check if pin CHDK needs to go LOW
   8509           *  - Check for KILL button held down
   8510           *  - Check for HOME button held down
   8511           *  - Check if cooling fan needs to be switched on
   8512           *  - Check if an idle but hot extruder needs filament extruded (EXTRUDER_RUNOUT_PREVENT)
   8513           */
   8514          void manage_inactivity(bool ignore_stepper_queue/*=false*/) {
   8515          
   8516            #if HAS_FILRUNOUT
   8517              if (IS_SD_PRINTING && !(READ(FILRUNOUT_PIN) ^ FIL_RUNOUT_INVERTING))
   8518                filrunout();
   8519            #endif
   8520          
   8521            if (commands_in_queue < BUFSIZE - 1) get_command();
   8522          
   8523            millis_t ms = millis();
   8524          
   8525            if (max_inactive_time && ms > previous_cmd_ms + max_inactive_time) kill(PSTR(MSG_KILLED));
   8526          
   8527            if (stepper_inactive_time && ms > previous_cmd_ms + stepper_inactive_time
   8528                && !ignore_stepper_queue && !blocks_queued()) {
   8529              #if DISABLE_X == true
   8530                disable_x();
   8531              #endif
   8532              #if DISABLE_Y == true
   8533                disable_y();
   8534              #endif
   8535              #if DISABLE_Z == true
   8536                disable_z();
   8537              #endif
   8538              #if DISABLE_E == true
   8539                disable_e0();
   8540                disable_e1();
   8541                disable_e2();
   8542                disable_e3();
   8543              #endif
   8544            }
   8545          
   8546            #ifdef CHDK // Check if pin should be set to LOW after M240 set it to HIGH
   8547              if (chdkActive && ms > chdkHigh + CHDK_DELAY) {
   8548                chdkActive = false;
   8549                WRITE(CHDK, LOW);
   8550              }
   8551            #endif
   8552          
   8553            #if HAS_KILL
   8554          
   8555              // Check if the kill button was pressed and wait just in case it was an accidental
   8556              // key kill key press
   8557              // -------------------------------------------------------------------------------
   8558              static int killCount = 0;   // make the inactivity button a bit less responsive
   8559              const int KILL_DELAY = 750;
   8560              if (!READ(KILL_PIN))
   8561                killCount++;
   8562              else if (killCount > 0)
   8563                killCount--;
   8564          
   8565              // Exceeded threshold and we can confirm that it was not accidental
   8566              // KILL the machine
   8567              // ----------------------------------------------------------------
   8568              if (killCount >= KILL_DELAY) kill(PSTR(MSG_KILLED));
   8569            #endif
   8570          
   8571            #if HAS_HOME
   8572              // Check to see if we have to home, use poor man's debouncer
   8573              // ---------------------------------------------------------
   8574              static int homeDebounceCount = 0;   // poor man's debouncing count
   8575              const int HOME_DEBOUNCE_DELAY = 2500;
   8576              if (!READ(HOME_PIN)) {
   8577                if (!homeDebounceCount) {
   8578                  enqueuecommands_P(PSTR("G28"));
   8579                  LCD_MESSAGEPGM(MSG_AUTO_HOME);
   8580                }
   8581                if (homeDebounceCount < HOME_DEBOUNCE_DELAY)
   8582                  homeDebounceCount++;
   8583                else
   8584                  homeDebounceCount = 0;
   8585              }
   8586            #endif
   8587          
   8588            #if HAS_CONTROLLERFAN
   8589              controllerFan(); // Check if fan should be turned on to cool stepper drivers down
   8590            #endif
   8591          
   8592            #if ENABLED(EXTRUDER_RUNOUT_PREVENT)
   8593              if (ms > previous_cmd_ms + EXTRUDER_RUNOUT_SECONDS * 1000)
   8594                if (degHotend(active_extruder) > EXTRUDER_RUNOUT_MINTEMP) {
   8595                  bool oldstatus;
   8596                  switch (active_extruder) {
   8597                    case 0:
   8598                      oldstatus = E0_ENABLE_READ;
   8599                      enable_e0();
   8600                      break;
   8601                    //#if EXTRUDERS > 1
   8602                      case 1:
   8603                        oldstatus = E1_ENABLE_READ;
   8604                        enable_e1();
   8605                        break;
   8606                      #if EXTRUDERS > 2
   8607                        case 2:
   8608                          oldstatus = E2_ENABLE_READ;
   8609                          enable_e2();
   8610                          break;
   8611                        #if EXTRUDERS > 3
   8612                          case 3:
   8613                            oldstatus = E3_ENABLE_READ;
   8614                            enable_e3();
   8615                            break;
   8616                        #endif
   8617                      #endif
   8618                    //#endif
   8619                  }
   8620                  float oldepos = current_position[E_AXIS], oldedes = destination[E_AXIS];
   8621                  plan_buffer_line(destination[X_AXIS], destination[Y_AXIS], destination[Z_AXIS],
   8622                                   destination[E_AXIS] + EXTRUDER_RUNOUT_EXTRUDE * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS],
   8623                                   EXTRUDER_RUNOUT_SPEED / 60. * EXTRUDER_RUNOUT_ESTEPS / axis_steps_per_unit[E_AXIS], active_extruder);
   8624                current_position[E_AXIS] = oldepos;
   8625                destination[E_AXIS] = oldedes;
   8626                plan_set_e_position(oldepos);
   8627                previous_cmd_ms = ms; // refresh_cmd_timeout()
   8628                st_synchronize();
   8629                switch (active_extruder) {
   8630                  case 0:
   8631                    E0_ENABLE_WRITE(oldstatus);
   8632                    break;
   8633                  //#if EXTRUDERS > 1
   8634                    case 1:
   8635                      E1_ENABLE_WRITE(oldstatus);
   8636                      break;
   8637                    #if EXTRUDERS > 2
   8638                      case 2:
   8639                        E2_ENABLE_WRITE(oldstatus);
   8640                        break;
   8641                      #if EXTRUDERS > 3
   8642                        case 3:
   8643                          E3_ENABLE_WRITE(oldstatus);
   8644                          break;
   8645                      #endif
   8646                    #endif
   8647                  //#endif
   8648                }
   8649              }
   8650            #endif
   8651          
   8652            #if ENABLED(DUAL_X_CARRIAGE)
   8653              // handle delayed move timeout
   8654              if (delayed_move_time && ms > delayed_move_time + 1000 && IsRunning()) {
   8655                // travel moves have been received so enact them
   8656                delayed_move_time = 0xFFFFFFFFUL; // force moves to be done
   8657                set_destination_to_current();
   8658                prepare_move();
   8659              }
   8660            #endif
   8661          
   8662            #if ENABLED(TEMP_STAT_LEDS)
   8663              handle_status_leds();
   8664            #endif
   8665          
   8666            check_axes_activity();
   8667          }
   8668          
   8669          void kill(const char* lcd_msg) {
   8670            #if ENABLED(ULTRA_LCD)
   8671              lcd_setalertstatuspgm(lcd_msg);
   8672            #else
   8673              UNUSED(lcd_msg);
   8674            #endif
   8675          
   8676            //printf(">>SYSTEM KILLED.");//yongzong
   8677          
   8678            cli(); // Stop interrupts
   8679            disable_all_heaters();
   8680            disable_all_steppers();
   8681          
   8682            #if HAS_POWER_SWITCH
   8683              pinMode(PS_ON_PIN, INPUT);
   8684            #endif
   8685          
   8686            SERIAL_ERROR_START;
   8687            SERIAL_ERRORLNPGM(MSG_ERR_KILLED);
   8688          
   8689            wifi_writeString("{SYS:ERROR}");
   8690          
   8691            return;//yongzong
   8692            /*// FMC small patch to update the LCD before ending
   8693            sei();   // enable interrupts
   8694            for (int i = 5; i--; lcd_update()) delay(200); // Wait a short time
   8695            cli();   // disable interrupts
   8696            suicide();*/
   8697            while (1) { /* Intentionally left empty */ } // Wait for reset
   8698          }
   8699          
   8700          #if ENABLED(FILAMENT_RUNOUT_SENSOR)
   8701          
   8702            void filrunout() {
   8703              if (!filrunoutEnqueued) {
   8704                filrunoutEnqueued = true;
   8705                enqueuecommands_P(PSTR(FILAMENT_RUNOUT_SCRIPT));
   8706                st_synchronize();
   8707              }
   8708            }
   8709          
   8710          #endif // FILAMENT_RUNOUT_SENSOR
   8711          
   8712          #if ENABLED(FAST_PWM_FAN)
   8713          
   8714            void setPwmFrequency(uint8_t pin, int val) {
   8715              val &= 0x07;
   8716              switch (digitalPinToTimer(pin)) {
   8717                #if defined(TCCR0A)
   8718                  case TIMER0A:
   8719                  case TIMER0B:
   8720                    // TCCR0B &= ~(_BV(CS00) | _BV(CS01) | _BV(CS02));
   8721                    // TCCR0B |= val;
   8722                    break;
   8723                #endif
   8724                #if defined(TCCR1A)
   8725                  case TIMER1A:
   8726                  case TIMER1B:
   8727                    // TCCR1B &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
   8728                    // TCCR1B |= val;
   8729                    break;
   8730                #endif
   8731                #if defined(TCCR2)
   8732                  case TIMER2:
   8733                  case TIMER2:
   8734                    TCCR2 &= ~(_BV(CS10) | _BV(CS11) | _BV(CS12));
   8735                    TCCR2 |= val;
   8736                    break;
   8737                #endif
   8738                #if defined(TCCR2A)
   8739                  case TIMER2A:
   8740                  case TIMER2B:
   8741                    TCCR2B &= ~(_BV(CS20) | _BV(CS21) | _BV(CS22));
   8742                    TCCR2B |= val;
   8743                    break;
   8744                #endif
   8745                #if defined(TCCR3A)
   8746                  case TIMER3A:
   8747                  case TIMER3B:
   8748                  case TIMER3C:
   8749                    TCCR3B &= ~(_BV(CS30) | _BV(CS31) | _BV(CS32));
   8750                    TCCR3B |= val;
   8751                    break;
   8752                #endif
   8753                #if defined(TCCR4A)
   8754                  case TIMER4A:
   8755                  case TIMER4B:
   8756                  case TIMER4C:
   8757                    TCCR4B &= ~(_BV(CS40) | _BV(CS41) | _BV(CS42));
   8758                    TCCR4B |= val;
   8759                    break;
   8760                #endif
   8761                #if defined(TCCR5A)
   8762                  case TIMER5A:
   8763                  case TIMER5B:
   8764                  case TIMER5C:
   8765                    TCCR5B &= ~(_BV(CS50) | _BV(CS51) | _BV(CS52));
   8766                    TCCR5B |= val;
   8767                    break;
   8768                #endif
   8769              }
   8770            }
   8771          
   8772          #endif // FAST_PWM_FAN
   8773          
   8774          void Stop() {
   8775            disable_all_heaters();
   8776            if (IsRunning()) {
   8777              Running = false;
   8778              Stopped_gcode_LastN = gcode_LastN; // Save last g_code for restart
   8779              SERIAL_ERROR_START;
   8780              SERIAL_ERRORLNPGM(MSG_ERR_STOPPED);
   8781              //LCD_MESSAGEPGM(MSG_STOPPED);
   8782            }
   8783          }
   8784          
   8785          /**
   8786           * Set target_extruder from the T parameter or the active_extruder
   8787           *
   8788           * Returns TRUE if the target is invalid
   8789           */
   8790          bool setTargetedHotend(int code) {
   8791            target_extruder = active_extruder;
   8792            if (code_seen('T')) {
   8793              target_extruder = code_value_short();
   8794              if (target_extruder >= EXTRUDERS) {
   8795                SERIAL_ECHO_START;
   8796                SERIAL_CHAR('M');
   8797                SERIAL_ECHO(code);
   8798                SERIAL_ECHOPGM(" " MSG_INVALID_EXTRUDER " ");
   8799                SERIAL_ECHOLN(target_extruder);
   8800                return true;
   8801              }
   8802            }
   8803            return false;
   8804          }
   8805          
   8806          float calculate_volumetric_multiplier(float diameter) {
   8807            if (!volumetric_enabled || diameter == 0) return 1.0;
   8808            float d2 = diameter * 0.5;
   8809            return 1.0 / (M_PI * d2 * d2);
   8810          }
   8811          
   8812          void calculate_volumetric_multipliers() {
   8813            for (int i = 0; i < EXTRUDERS; i++)
   8814              volumetric_multiplier[i] = calculate_volumetric_multiplier(filament_size[i]);
   8815          }

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   CardReader::eof()
       8   CardReader::setIndex(long)
         8   -> f_lseek
       8   FlushSerialRequestResend()
         8   -> MarlinSerial::print(long, int)
         8   -> MarlinSerial::write(uint8_t *, uint8_t)
         8   -> ok_to_send()
         8   -> serialprintPGM(char const *)
       8   MarlinSerial::print(char const *)
         8   -> MarlinSerial::write(char const *)
      16   MarlinSerial::write(char const *)
        16   -> CDC_Send_DATA_str
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
      24   MarlinSerial::write(uint8_t *, uint8_t)
        24   -> CDC_Send_DATA
        24   -> USART_GetFlagStatus
        24   -> USART_SendData
      16   MarlinSerial::write(uint8_t)
        16   -> CDC_Send_DATA
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
       8   Stop()
         8   -> MarlinSerial::write(uint8_t *, uint8_t)
         8   -> disable_all_heaters()
         8   -> serialprintPGM(char const *)
       8   __sti__routine()
         8   -> CardReader::CardReader()
      16   autotempShutdown()
        16   -> __aeabi_i2f
        16   -> setTargetHotend(float const &, uint8_t)
        16 __aeabi_cfcmple
      16   base_home_pos(uint8_t)
        16   -> __aeabi_i2f
       8   buffered_printing()
         8   -> StartBuild()
      16   calculate_volumetric_multiplier(float)
        16   -> __aeabi_fdiv
        16   -> __aeabi_fmul
        16 __aeabi_cfcmpeq
      24   calculate_volumetric_multipliers()
        24   -> calculate_volumetric_multiplier(float)
       0   clamp_to_software_endstops(float *)
       0   code_has_value()
       8   code_seen(char)
         8   -> __iar_Strchr
      16   code_value()
        16   -> __aeabi_d2f
        16   -> __iar_Strchr
        16   -> strtod
       8   code_value_long()
         8   -> strtol
       8   code_value_short()
         8   -> strtol
      16   disable_all_steppers()
        16   -> GPIO_WriteBit
        16   -> disable_z()
      56   drain_queued_commands_P()
        56   -> enqueuecommand(char const *)
        56   -> strncpy
      16   enable_all_steppers()
        16   -> GPIO_WriteBit
        16   -> enable_z()
      16   enqueuecommand(char const *)
        16   -> strcpy
       8   enqueuecommands_P(char const *)
         8   -> drain_queued_commands_P()
      24   gcode_G28()
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> StartBuild()
        24   -> __aeabi_fmul
        24   -> code_seen(char)
        24   -> code_value()
        24   -> enable_endstops(bool)
        24   -> endstops_hit_on_purpose()
        24   -> homeaxis(AxisEnum)
        24   -> line_to_destination()
        24   -> print_xyz(char const *, float const *)
        24   -> refresh_cmd_timeout()
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
        24   -> set_destination_to_current()
        24   -> st_synchronize()
        24   -> sync_plan_position()
      32   gcode_M105()
        32   -> MarlinSerial::print(double, int)
        32   -> MarlinSerial::print(int, int)
        32   -> MarlinSerial::print(long, int)
        32   -> MarlinSerial::write(uint8_t *, uint8_t)
        32   -> MarlinSerial::write(uint8_t)
        32   -> __aeabi_f2d
        32   -> __aeabi_i2f
        32   -> getHeaterPower(int)
        32   -> serialprintPGM(char const *)
        32   -> setTargetedHotend(int)
      24   gcode_M109()
        24   -> MarlinSerial::print(double, int)
        24   -> MarlinSerial::print(int, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> StartBuild()
        24   -> __aeabi_f2d
        24   -> __aeabi_i2f
        24   -> code_seen(char)
        24   -> code_value()
        24   -> idle()
        24   -> isHeatingHotend(uint8_t)
        24   -> millis()
        24   -> refresh_cmd_timeout()
        24   -> serialprintPGM(char const *)
        24   -> setTargetHotend(float const &, uint8_t)
        24   -> setTargetedHotend(int)
        24 __aeabi_cfcmple
      24   gcode_M114()
        24   -> MarlinSerial::print(double, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_f2d
        24   -> serialprintPGM(char const *)
        24   -> st_get_position_mm(AxisEnum)
      24   gcode_M190()
        24   -> MarlinSerial::print(double, int)
        24   -> MarlinSerial::print(int, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_f2d
        24   -> __aeabi_f2iz
        24   -> __aeabi_i2f
        24   -> code_seen(char)
        24   -> code_value()
        24   -> idle()
        24   -> millis()
        24   -> refresh_cmd_timeout()
        24   -> serialprintPGM(char const *)
        24 __aeabi_cfcmple
      24   gcode_M301()
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::print(double, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_f2d
        24   -> __aeabi_f2iz
        24   -> code_seen(char)
        24   -> code_value()
        24   -> scalePID_d(float)
        24   -> scalePID_i(float)
        24   -> serialprintPGM(char const *)
        24   -> unscalePID_d(float)
        24   -> unscalePID_i(float)
        24   -> updatePID()
      48   gcode_M428()
        48   -> MarlinSerial::write(uint8_t *, uint8_t)
        48   -> __aeabi_fadd
        48   -> __aeabi_fmul
        48   -> __aeabi_fsub
        48   -> base_home_pos(uint8_t)
        48   -> serialprintPGM(char const *)
        48   -> sync_plan_position()
        48 __aeabi_cfcmple
        48 __aeabi_cfrcmple
      24   gcode_M561()
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_f2iz
        24   -> code_seen(char)
        24   -> code_value()
      24   gcode_M562()
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::print(char, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_f2iz
        24   -> code_seen(char)
        24   -> code_value()
      24   gcode_M563()
        24   -> USART_Cmd
        24   -> USART_DeInit
        24   -> USART_GetFlagStatus
        24   -> __aeabi_f2iz
        24   -> code_seen(char)
        24   -> code_value()
        24   -> delay(unsigned long)
        24   -> serial_init(int)
        24   -> wifi_writeString(char *)
       8   gcode_M564()
         8   -> MarlinSerial::print(char const *)
         8   -> MarlinSerial::write(uint8_t *, uint8_t)
         8   -> wifi_writeString(char *)
       8   gcode_M565()
         8   -> MarlinSerial::flush()
         8   -> StartBuild()
         8   -> enqueuecommands_P(char const *)
         8   -> store_char
         8   -> wifi_writeString(char *)
       8   gcode_M566()
         8   -> f_rename
      40   gcode_M600()
        40   -> GPIO_WriteBit
        40   -> __aeabi_fadd
        40   -> __aeabi_fsub
        40   -> code_seen(char)
        40   -> code_value()
        40   -> delay(unsigned long)
        40   -> idle()
        40   -> line_to_destination()
        40   -> millis()
        40   -> plan_set_e_position(float const &)
        40   -> st_synchronize()
        40   -> wifi_writeString(char *)
      24   gcode_T(uint8_t)
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::print(int, int)
        24   -> MarlinSerial::print(unsigned char, int)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> MarlinSerial::write(uint8_t)
        24   -> __aeabi_fadd
        24   -> __aeabi_fsub
        24   -> code_seen(char)
        24   -> code_value()
        24   -> prepare_move()
        24   -> serialprintPGM(char const *)
        24   -> set_destination_to_current()
        24   -> sync_plan_position()
        24 __aeabi_cfrcmple
      24   gcode_get_destination()
        24   -> __aeabi_fadd
        24   -> code_seen(char)
        24   -> code_value()
        24 __aeabi_cfrcmple
      16   gcode_line_error(char const *, bool)
        16   -> FlushSerialRequestResend()
        16   -> MarlinSerial::print(long, int)
        16   -> MarlinSerial::write(uint8_t *, uint8_t)
        16   -> serialprintPGM(char const *)
      80   get_command()
        80   -> CardReader::checkautostart(bool)
        80   -> CardReader::eof()
        80   -> CardReader::initsd()
        80   -> CardReader::openFile(char *, bool, bool)
        80   -> CardReader::printingHasFinished()
        80   -> MarlinSerial::print(char const *)
        80   -> MarlinSerial::read()
        80   -> MarlinSerial::write(uint8_t *, uint8_t)
        80   -> __iar_Strchr
        80   -> __iar_Strstr
        80   -> drain_queued_commands_P()
        80   -> f_close
        80   -> f_lseek
        80   -> f_read
        80   -> gcode_line_error(char const *, bool)
        80   -> idle()
        80   -> kill(char const *)
        80   -> millis()
        80   -> serialprintPGM(char const *)
        80   -> sprintf
        80   -> strcmp
        80   -> strtol
        80 __aeabi_uidiv
        80 __aeabi_uidivmod
       0   home_bump_mm(int)
      48   homeaxis(AxisEnum)
        48   -> MarlinSerial::write(uint8_t *, uint8_t)
        48   -> MarlinSerial::write(uint8_t)
        48   -> __aeabi_d2f
        48   -> __aeabi_dmul
        48   -> __aeabi_fmul
        48   -> __aeabi_i2d
        48   -> __aeabi_i2f
        48   -> enable_endstops(bool)
        48   -> endstops_hit_on_purpose()
        48   -> home_bump_mm(int)
        48   -> line_to_destination()
        48   -> print_xyz(char const *, float const *)
        48   -> serial_echopair_P(char const *, unsigned long)
        48   -> serialprintPGM(char const *)
        48   -> set_axis_is_at_home(AxisEnum)
        48   -> set_homing_bump_feedrate(AxisEnum)
        48   -> st_synchronize()
        48   -> sync_plan_position()
       8   idle()
         8   -> IWDG_ReloadCounter
         8   -> manage_heater()
         8   -> manage_inactivity(bool)
         8   -> wifi_update()
       8   isHeatingHotend(uint8_t)
         8   -> __aeabi_i2f
         8 __aeabi_cfcmple
       8   kill(char const *)
         8   -> MarlinSerial::write(uint8_t *, uint8_t)
         8   -> disable_all_heaters()
         8   -> disable_all_steppers()
         8   -> serialprintPGM(char const *)
         8   -> wifi_writeString(char *)
       8   line_to_destination()
         8   -> line_to_destination(float)
      16   line_to_destination(float)
        16   -> __aeabi_fdiv
        16   -> plan_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
      24   loop()
        24   -> CardReader::checkautostart(bool)
        24   -> CardReader::closefile(bool)
        24   -> CardReader::write_command(char *)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> __aeabi_memclr4
        24   -> __iar_Strstr
        24   -> autotempShutdown()
        24   -> checkHitEndstops()
        24   -> finishAndDisableSteppers()
        24   -> get_command()
        24   -> idle()
        24   -> process_next_command()
        24   -> quickStop()
        24   -> serialprintPGM(char const *)
      16   manage_inactivity(bool)
        16   -> check_axes_activity()
        16   -> get_command()
        16   -> kill(char const *)
        16   -> millis()
      16   ok_to_send()
        16   -> MarlinSerial::print(int, int)
        16   -> MarlinSerial::print(long, int)
        16   -> MarlinSerial::write(uint8_t *, uint8_t)
        16   -> refresh_cmd_timeout()
        16   -> serialprintPGM(char const *)
      88   plan_arc(float *, float *, uint8_t)
        88   -> __aeabi_f2iz
        88   -> __aeabi_fadd
        88   -> __aeabi_fdiv
        88   -> __aeabi_fmul
        88   -> __aeabi_fsub
        88   -> __aeabi_i2f
        88   -> __aeabi_ui2f
        88   -> atan2f
        88   -> cosf
        88   -> floorf
        88   -> hypotf
        88   -> plan_buffer_line(float const &, float const &, float const &, float const &, float, uint8_t)
        88   -> set_current_to_destination()
        88   -> sinf
        88 __aeabi_cfcmpeq
        88 __aeabi_cfcmple
       8   prepare_move()
         8   -> __aeabi_fdiv
         8   -> __aeabi_fmul
         8   -> __aeabi_i2f
         8   -> line_to_destination()
         8   -> line_to_destination(float)
         8   -> refresh_cmd_timeout()
         8   -> set_current_to_destination()
         8 __aeabi_cfcmpeq
       8   print_xyz(char const *, float const *)
         8   -> print_xyz(char const *, float, float, float)
      24   print_xyz(char const *, float, float, float)
        24   -> MarlinSerial::print(char const *)
        24   -> MarlinSerial::write(uint8_t *, uint8_t)
        24   -> serial_echopair_P(char const *, float)
        24   -> serialprintPGM(char const *)
      64   process_next_command()
        64   -- Indirect call
        64   -> CardReader::getStatus()
        64   -> CardReader::initsd()
        64   -> CardReader::ls()
        64   -> CardReader::openFile(char *, bool, bool)
        64   -> CardReader::openLogFile(char *)
        64   -> CardReader::pauseSDPrint()
        64   -> CardReader::printLongPath(char *)
        64   -> CardReader::release()
        64   -> CardReader::removeFile(char *)
        64   -> CardReader::setIndex(long)
        64   -> CardReader::startFileprint()
        64   -> Config_PrintSettings(bool)
        64   -> Config_ResetDefault()
        64   -> Config_RetrieveSettings(bool)
        64   -> Config_StoreSettings()
        64   -> EndBuild()
        64   -> FlushSerialRequestResend()
        64   -> GPIO_ReadInputDataBit_filtered
        64   -> GPIO_WriteBit
        64   -> IWDG_Enable
        64   -> IWDG_ReloadCounter
        64   -> IWDG_SetPrescaler
        64   -> IWDG_SetReload
        64   -> IWDG_WriteAccessCmd
        64   -> MarlinSerial::print(char const *)
        64   -> MarlinSerial::print(double, int)
        64   -> MarlinSerial::print(int, int)
        64   -> MarlinSerial::print(unsigned char, int)
        64   -> MarlinSerial::write(uint8_t *, uint8_t)
        64   -> MarlinSerial::write(uint8_t)
        64   -> PID_autotune(float, int, int)
        64   -> PWR_BackupAccessCmd
        64   -> RCC_LSICmd
        64   -> SYSCFG_MemoryRemapConfig
        64   -> StartBuild()
        64   -> USB_enable(uint8_t)
        64   -> __aeabi_f2d
        64   -> __aeabi_f2iz
        64   -> __aeabi_f2uiz
        64   -> __aeabi_fdiv
        64   -> __aeabi_fmul
        64   -> __aeabi_ui2f
        64   -> __iar_Strchr
        64   -> autotempShutdown()
        64   -> calculate_volumetric_multipliers()
        64   -> code_seen(char)
        64   -> code_value()
        64   -> code_value_short()
        64   -> delay(unsigned long)
        64   -> disable_all_heaters()
        64   -> disable_z()
        64   -> enable_all_steppers()
        64   -> enable_endstops(bool)
        64   -> finishAndDisableSteppers()
        64   -> gcode_G28()
        64   -> gcode_M105()
        64   -> gcode_M109()
        64   -> gcode_M114()
        64   -> gcode_M190()
        64   -> gcode_M301()
        64   -> gcode_M428()
        64   -> gcode_M561()
        64   -> gcode_M562()
        64   -> gcode_M563()
        64   -> gcode_M564()
        64   -> gcode_M565()
        64   -> gcode_M566()
        64   -> gcode_M600()
        64   -> gcode_T(uint8_t)
        64   -> gcode_get_destination()
        64   -> idle()
        64   -> kill(char const *)
        64   -> millis()
        64   -> ok_to_send()
        64   -> plan_arc(float *, float *, uint8_t)
        64   -> plan_set_e_position(float const &)
        64   -> port_init
        64   -> prepare_move()
        64   -> quickStop()
        64   -> refresh_cmd_timeout()
        64   -> reset_acceleration_rates()
        64   -> scalePID_d(float)
        64   -> scalePID_i(float)
        64   -> serial_echopair_P(char const *, float)
        64   -> serialprintPGM(char const *)
        64   -> setTargetHotend(float const &, uint8_t)
        64   -> setTargetedHotend(int)
        64   -> sprintf
        64   -> st_synchronize()
        64   -> strcpy
        64   -> strtol
        64   -> sync_plan_position()
        64   -> unknown_command_error()
        64   -> unscalePID_d(float)
        64   -> unscalePID_i(float)
        64   -> updatePID()
        64   -> wifi_writeString(char *)
        64 __aeabi_cfcmpeq
        64 __aeabi_cfcmple
        64 __aeabi_cfrcmple
        64 __aeabi_uidiv
        64 __aeabi_uidivmod
      16   putc(char)
        16   -> USART_GetFlagStatus
        16   -> USART_SendData
      16   puts(uint8_t *, uint16_t)
        16   -> putc(char)
       0   recal_probe()
       8   refresh_cmd_timeout()
         8   -> millis()
      16   serial_echopair_P(char const *, double)
        16   -> MarlinSerial::print(double, int)
        16   -> serialprintPGM(char const *)
      16   serial_echopair_P(char const *, float)
        16   -> MarlinSerial::print(double, int)
        16   -> __aeabi_f2d
        16   -> serialprintPGM(char const *)
       8   serial_echopair_P(char const *, int)
         8   -> MarlinSerial::print(int, int)
         8   -> serialprintPGM(char const *)
       8   serial_echopair_P(char const *, long)
         8   -> MarlinSerial::print(long, int)
         8   -> serialprintPGM(char const *)
       8   serial_echopair_P(char const *, unsigned long)
         8   -> MarlinSerial::print(unsigned long, int)
         8   -> serialprintPGM(char const *)
       8   serialprintPGM(char const *)
         8   -> MarlinSerial::write(char const *)
       0   servo_init()
       8   setTargetHotend(float const &, uint8_t)
         8   -> __aeabi_f2iz
         8   -> start_watching_heater(int)
      16   setTargetedHotend(int)
        16   -> MarlinSerial::print(int, int)
        16   -> MarlinSerial::print(unsigned char, int)
        16   -> MarlinSerial::write(uint8_t *, uint8_t)
        16   -> MarlinSerial::write(uint8_t)
        16   -> code_seen(char)
        16   -> code_value_short()
        16   -> serialprintPGM(char const *)
      24   set_axis_is_at_home(AxisEnum)
        24   -> __aeabi_fadd
        24   -> __aeabi_i2f
        24   -> base_home_pos(uint8_t)
        24   -> print_xyz(char const *, float const *)
        24   -> serial_echopair_P(char const *, float)
        24   -> serial_echopair_P(char const *, unsigned long)
      12   set_current_to_destination()
      12   set_destination_to_current()
      16   set_homing_bump_feedrate(AxisEnum)
        16   -> MarlinSerial::write(uint8_t *, uint8_t)
        16   -> __aeabi_fdiv
        16   -> __aeabi_i2f
        16   -> serialprintPGM(char const *)
      16   setup()
        16   -> Config_RetrieveSettings(bool)
        16   -> analog_init()
        16   -> plan_init()
        16   -> st_init()
        16   -> tp_init()
        16   -> wifi_init()
       0   setup_filrunoutpin()
       0   setup_homepin()
       0   setup_killpin()
       0   setup_photpin()
       0   setup_powerhold()
       0   suicide()
       8   sync()
         8   -> putc(char)
         8   -> puts(uint8_t *, uint16_t)
       8   sync_plan_position()
         8   -> plan_set_position(float const &, float const &, float const &, float const &)
       8   unknown_command_error()
         8   -> MarlinSerial::print(char const *)
         8   -> serialprintPGM(char const *)
     752   update_LCD()
       752   -> CardReader::initsd()
       752   -> GPIO_Init
       752   -> GPIO_WriteBit
       752   -> IWDG_ReloadCounter
       752   -> delay(unsigned long)
       752   -> f_open
       752   -> f_read
       752   -> puts(uint8_t *, uint16_t)
       752   -> serial_init(int)
       752   -> sync()


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable63
       4  ??DataTable63_1
       4  ??DataTable63_10
       4  ??DataTable63_11
       4  ??DataTable63_12
       4  ??DataTable63_2
       4  ??DataTable63_3
       4  ??DataTable63_4
       4  ??DataTable63_5
       4  ??DataTable63_6
       4  ??DataTable63_7
       4  ??DataTable63_8
       4  ??DataTable63_9
       4  ??DataTable64
       4  ??DataTable64_1
       4  ??DataTable64_2
       4  ??DataTable64_3
       4  ??DataTable65
       4  ??DataTable67
       4  ??DataTable69
       4  ??DataTable70
       4  ??DataTable71
       4  ??DataTable73
       4  ??DataTable73_1
       4  ??DataTable73_10
       4  ??DataTable73_2
       4  ??DataTable73_3
       4  ??DataTable73_4
       4  ??DataTable73_5
       4  ??DataTable73_6
       4  ??DataTable73_7
       4  ??DataTable73_8
       4  ??DataTable73_9
       4  ??DataTable74
       4  ??DataTable74_1
       4  ??DataTable74_2
       4  ??DataTable74_3
       4  ??DataTable75
       4  ??DataTable75_1
       4  ??DataTable75_2
       4  ??DataTable76
       4  ??DataTable76_1
       4  ??DataTable76_2
       4  ??DataTable76_3
       4  ??DataTable76_4
       4  ??DataTable77
       4  ??DataTable77_1
       4  ??DataTable78
       4  ??DataTable78_1
       4  ??DataTable79
       4  ??DataTable79_1
       4  ??DataTable82
       4  ??DataTable82_1
       4  ??DataTable82_10
       4  ??DataTable82_11
       4  ??DataTable82_12
       4  ??DataTable82_13
       4  ??DataTable82_2
       4  ??DataTable82_3
       4  ??DataTable82_4
       4  ??DataTable82_5
       4  ??DataTable82_6
       4  ??DataTable82_7
       4  ??DataTable82_8
       4  ??DataTable82_9
       4  ??DataTable83
       4  ??DataTable83_1
       4  ??DataTable83_10
       4  ??DataTable83_2
       4  ??DataTable83_3
       4  ??DataTable83_4
       4  ??DataTable83_5
       4  ??DataTable83_6
       4  ??DataTable83_7
       4  ??DataTable83_8
       4  ??DataTable83_9
       4  ??DataTable84
       4  ??DataTable84_1
       4  ??DataTable84_10
       4  ??DataTable84_11
       4  ??DataTable84_12
       4  ??DataTable84_13
       4  ??DataTable84_14
       4  ??DataTable84_15
       4  ??DataTable84_2
       4  ??DataTable84_3
       4  ??DataTable84_4
       4  ??DataTable84_5
       4  ??DataTable84_6
       4  ??DataTable84_7
       4  ??DataTable84_8
       4  ??DataTable84_9
       4  ??DataTable85
       4  ??DataTable85_1
       4  ??DataTable85_2
       4  ??DataTable86
       4  ??DataTable86_1
       4  ??DataTable86_2
       4  ??DataTable86_3
       4  ??DataTable86_4
       4  ??DataTable86_5
       4  ??DataTable86_6
       4  ??DataTable86_7
       4  ??DataTable86_8
       4  ??DataTable87
       4  ??DataTable87_1
       4  ??DataTable88
       4  ??DataTable88_1
       4  ??DataTable88_10
       4  ??DataTable88_11
       4  ??DataTable88_12
       4  ??DataTable88_13
       4  ??DataTable88_14
       4  ??DataTable88_15
       4  ??DataTable88_16
       4  ??DataTable88_17
       4  ??DataTable88_18
       4  ??DataTable88_19
       4  ??DataTable88_2
       4  ??DataTable88_20
       4  ??DataTable88_21
       4  ??DataTable88_22
       4  ??DataTable88_23
       4  ??DataTable88_24
       4  ??DataTable88_25
       4  ??DataTable88_26
       4  ??DataTable88_3
       4  ??DataTable88_4
       4  ??DataTable88_5
       4  ??DataTable88_6
       4  ??DataTable88_7
       4  ??DataTable88_8
       4  ??DataTable88_9
       4  ??DataTable90
       4  ??DataTable91
       4  ??DataTable91_1
       4  ??DataTable92
       4  ??DataTable92_1
       4  ??DataTable94
       4  ??DataTable97
       4  ??DataTable97_1
       4  ??DataTable97_10
       4  ??DataTable97_11
       4  ??DataTable97_12
       4  ??DataTable97_13
       4  ??DataTable97_14
       4  ??DataTable97_15
       4  ??DataTable97_16
       4  ??DataTable97_17
       4  ??DataTable97_18
       4  ??DataTable97_19
       4  ??DataTable97_2
       4  ??DataTable97_20
       4  ??DataTable97_21
       4  ??DataTable97_3
       4  ??DataTable97_4
       4  ??DataTable97_5
       4  ??DataTable97_6
       4  ??DataTable97_7
       4  ??DataTable97_8
       4  ??DataTable97_9
      28  ?Subroutine0
      10  ?Subroutine1
       8  ?Subroutine2
     260  ?_0
       2  ?_10
       4  ?_11
       8  ?_12
      32  ?_13
       8  ?_14
      12  ?_15
      20  ?_16
      20  ?_17
       4  ?_18
       4  ?_19
       2  ?_20
      24  ?_21
      24  ?_22
      24  ?_23
      16  ?_24
      28  ?_25
      24  ?_26
      16  ?_27
      20  ?_28
       4  ?_29
       4  ?_30
       4  ?_31
       4  ?_32
       4  ?_33
      12  ?_34
      28  ?_35
       8  ?_36
       8  ?_37
      20  ?_38
       4  ?_39
      48  ?_4
       2  ?_40
      16  ?_41
       4  ?_42
      12  ?_43
      12  ?_44
      16  ?_45
      12  ?_46
       4  ?_47
       4  ?_48
       4  ?_49
      88  ?_5
      32  ?_50
      12  ?_51
      20  ?_52
      36  ?_7
       4  ?_8
      20  ?_9
      30  CardReader::eof()
      22  CardReader::setIndex(long)
      40  FlushSerialRequestResend()
      96  L
          R
          procpos
          extruder_multiplier
          fanSpeed
       8  MarlinSerial::print(char const *)
      60  MarlinSerial::write(char const *)
      72  MarlinSerial::write(uint8_t *, uint8_t)
      56  MarlinSerial::write(uint8_t)
      42  Stop()
       4  Stopped_gcode_LastN
      10  __sti__routine()
      72  autotempShutdown()
       4  axis_codes
     128  axis_relative_modes
          axis_known_position
          Running
          marlin_debug_flags
          volumetric_enabled
          active_extruder
          cancel_heatup
          relative_mode
          target_extruder
          buffer_status
          current_position
          destination
          extruder_offset
          feedrate
          current_command
          current_command_args
          cmd_queue_index_r
          feedrate_multiplier
          filament_size
          home_offset
          seen_pointer
          previous_cmd_ms
          max_inactive_time
          stepper_inactive_time
          print_job_start_ms
          print_job_stop_ms
      50  base_home_pos(uint8_t)
      52  buffered_printing()
      66  calculate_volumetric_multiplier(float)
      34  calculate_volumetric_multipliers()
    1712  card
       2  clamp_to_software_endstops(float *)
      38  code_has_value()
      22  code_seen(char)
      54  code_value()
      18  code_value_long()
      20  code_value_short()
    1536  command_queue
      58  disable_all_steppers()
      80  drain_queued_commands_P()
       8  echomagic
      52  enable_all_steppers()
      60  enqueuecommand(char const *)
      12  enqueuecommands_P(char const *)
       8  errormagic
       4  execpos
     552  gcode_G28()
     468  gcode_M105()
     396  gcode_M109()
     212  gcode_M114()
     340  gcode_M190()
     372  gcode_M301()
     220  gcode_M428()
     118  gcode_M561()
     412  gcode_M562()
     456  gcode_M563()
      42  gcode_M564()
      48  gcode_M565()
      22  gcode_M566()
     306  gcode_M600()
     240  gcode_T(uint8_t)
      80  gcode_get_destination()
      56  gcode_line_error(char const *, bool)
     968  get_command()
       8  home_bump_mm(int)
      12  home_bump_mm_P
     562  homeaxis(AxisEnum)
     124  homing
          serial_char
          comment_mode
          no_wait_for_cooling
          target_direction
          home_all_axis
          sdprint_cancel
          stop_buffering
          homeX
          homeY
          homeZ
          fromsd
          saved_feedrate
          gcode_N
          gcode_LastN
          cmd_queue_index_w
          commands_in_queue
          curpos
          saved_feedrate_multiplier
          serial_count
          recal_probe_offset
      12  homing_bump_divisor
      22  idle()
      44  isHeatingHotend(uint8_t)
      42  kill(char const *)
      16  line_to_destination()
      48  line_to_destination(float)
     208  loop()
       4  lpq_len
       1  m600_resume
      76  manage_inactivity(bool)
      24  min_pos
          base_min_pos_P
     108  ok_to_send()
     710  plan_arc(float *, float *, uint8_t)
      62  prepare_move()
      14  print_xyz(char const *, float const *)
      56  print_xyz(char const *, float, float, float)
    4924  process_next_command()
      32  putc(char)
      26  puts(uint8_t *, uint16_t)
       4  queued_commands_P
       2  recal_probe()
      16  refresh_cmd_timeout()
      26  serial_echopair_P(char const *, double)
      30  serial_echopair_P(char const *, float)
      20  serial_echopair_P(char const *, int)
      20  serial_echopair_P(char const *, long)
      20  serial_echopair_P(char const *, unsigned long)
       1  serial_rate
      16  serialprintPGM(char const *)
       2  servo_init()
      28  setTargetHotend(float const &, uint8_t)
      96  setTargetedHotend(int)
     106  set_axis_is_at_home(AxisEnum)
      20  set_current_to_destination()
      20  set_destination_to_current()
      88  set_homing_bump_feedrate(AxisEnum)
      48  setup()
       2  setup_filrunoutpin()
       8  setup_homepin()
       2  setup_killpin()
       2  setup_photpin()
       2  setup_powerhold()
       1  start_after_download
       2  suicide()
      30  sync()
      16  sync_packet
      28  sync_plan_position()
      32  unknown_command_error()
     340  update_LCD()
       8  volumetric_multiplier
       4  zprobe_zoffset
    1094  -- Other

 
  3'291 bytes in section .bss
    372 bytes in section .data
      4 bytes in section .init_array
  2'136 bytes in section .rodata
 14'992 bytes in section .text
 
 10'864 bytes of CODE  memory (+ 4'132 bytes shared)
  1'046 bytes of CONST memory (+ 1'090 bytes shared)
  3'663 bytes of DATA  memory

Errors: none
Warnings: 35

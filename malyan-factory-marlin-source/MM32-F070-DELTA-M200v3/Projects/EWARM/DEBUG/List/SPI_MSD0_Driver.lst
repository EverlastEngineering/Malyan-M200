###############################################################################
#
# IAR ANSI C/C++ Compiler V8.40.1.212/W32 for ARM         10/Oct/2019  17:00:21
# Copyright 1999-2019 IAR Systems AB.
#
#    Cpu mode     =  
#    Endian       =  little
#    Source file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\SPI_MSD0_Driver.c
#    Command line =
#        -f C:\Users\yongzong\AppData\Local\Temp\EW3E63.tmp
#        (D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\SPI_MSD0_Driver.c
#        -D USE_STDPERIPH_DRIVER -D USE_STM32072B_EVAL -D STM32F072 -lcN
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List
#        -o
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj
#        --debug --endian=little --cpu=Cortex-M0 -e --fpu=None --dlib_config
#        "C:\Program Files (x86)\IAR Systems\Embedded Workbench
#        8.3\arm\inc\c\DLib_Config_Normal.h" -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\ -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\fs\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\js\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\marlin\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\rtt\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\src\usb\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\CMSIS\Device\ST\STM32F0xx\Include\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32F0xx_StdPeriph_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Driver\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Core\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\hid\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\cdc_msc_wrapper\inc\
#        -I
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\..\..\Libraries\STM32_USB_Device_Library\Class\msc\inc\
#        -Ohz --use_c++_inline -I "C:\Program Files (x86)\IAR Systems\Embedded
#        Workbench 8.3\arm\CMSIS\Core\Include\" -I "C:\Program Files (x86)\IAR
#        Systems\Embedded Workbench 8.3\arm\CMSIS\DSP\Include\" --relaxed_fp)
#    Locale       =  C
#    List file    =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\List\SPI_MSD0_Driver.lst
#    Object file  =
#        D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\EWARM\DEBUG\Obj\SPI_MSD0_Driver.o
#
###############################################################################

D:\Projects\3DPrint\SRC\MM32-F070-DELTA-M200v3\Projects\src\fs\SPI_MSD0_Driver.c
      1          /**
      2            ******************************************************************************
      3            * @file    SPI_MSD0_Driver.c
      4            * $Author: wdluo $
      5            * $Revision: 17 $
      6            * $Date:: 2012-07-06 11:16:48 +0800 #$
      7            * @brief   Ö÷º¯Êý.
      8            ******************************************************************************
      9            * @attention
     10            *
     11            *<h3><center>&copy; Copyright 2009-2012, ViewTool</center>
     12            *<center><a href="http:\\www.viewtool.com">http://www.viewtool.com</a></center>
     13            *<center>All Rights Reserved</center></h3>
     14            *
     15            ******************************************************************************
     16            */
     17          /* Includes ------------------------------------------------------------------*/
     18          #include "SPI_MSD0_Driver.h"
     19          #include <stdio.h>
     20          //#define PRINT_INFO  1
     21          
     22          unsigned char card_type=0;
     23          
     24          /* Private define ------------------------------------------------------------*/
     25          extern uint8_t model;
     26          void MSD0_card_enable()
     27          {
     28              if (model==4 || model==5)
     29                  GPIO_ResetBits(GPIOB,GPIO_Pin_0);
     30              else if (model==6)
     31                  GPIO_ResetBits(GPIOB,GPIO_Pin_6);
     32              else
     33                  GPIO_ResetBits(GPIOA,GPIO_Pin_4);
     34          }
     35          void MSD0_card_disable()
     36          {
     37              if (model==4 || model==5)
     38                  GPIO_SetBits(GPIOB,GPIO_Pin_0);
     39              else if (model==6)
     40                  GPIO_ResetBits(GPIOB,GPIO_Pin_6);//GPIO_SetBits(GPIOB,GPIO_Pin_6);
     41              else
     42                  GPIO_ResetBits(GPIOA,GPIO_Pin_4);
     43          }
     44          /* Private variables ---------------------------------------------------------*/
     45          MSD_CARDINFO SD0_CardInfo;
     46          
     47          static const uint16_t crc16_table[256] = {
     48              0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50A5, 0x60C6, 0x70E7,
     49              0x8108, 0x9129, 0xA14A, 0xB16B, 0xC18C, 0xD1AD, 0xE1CE, 0xF1EF,
     50              0x1231, 0x0210, 0x3273, 0x2252, 0x52B5, 0x4294, 0x72F7, 0x62D6,
     51              0x9339, 0x8318, 0xB37B, 0xA35A, 0xD3BD, 0xC39C, 0xF3FF, 0xE3DE,
     52              0x2462, 0x3443, 0x0420, 0x1401, 0x64E6, 0x74C7, 0x44A4, 0x5485,
     53              0xA56A, 0xB54B, 0x8528, 0x9509, 0xE5EE, 0xF5CF, 0xC5AC, 0xD58D,
     54              0x3653, 0x2672, 0x1611, 0x0630, 0x76D7, 0x66F6, 0x5695, 0x46B4,
     55              0xB75B, 0xA77A, 0x9719, 0x8738, 0xF7DF, 0xE7FE, 0xD79D, 0xC7BC,
     56              0x48C4, 0x58E5, 0x6886, 0x78A7, 0x0840, 0x1861, 0x2802, 0x3823,
     57              0xC9CC, 0xD9ED, 0xE98E, 0xF9AF, 0x8948, 0x9969, 0xA90A, 0xB92B,
     58              0x5AF5, 0x4AD4, 0x7AB7, 0x6A96, 0x1A71, 0x0A50, 0x3A33, 0x2A12,
     59              0xDBFD, 0xCBDC, 0xFBBF, 0xEB9E, 0x9B79, 0x8B58, 0xBB3B, 0xAB1A,
     60              0x6CA6, 0x7C87, 0x4CE4, 0x5CC5, 0x2C22, 0x3C03, 0x0C60, 0x1C41,
     61              0xEDAE, 0xFD8F, 0xCDEC, 0xDDCD, 0xAD2A, 0xBD0B, 0x8D68, 0x9D49,
     62              0x7E97, 0x6EB6, 0x5ED5, 0x4EF4, 0x3E13, 0x2E32, 0x1E51, 0x0E70,
     63              0xFF9F, 0xEFBE, 0xDFDD, 0xCFFC, 0xBF1B, 0xAF3A, 0x9F59, 0x8F78,
     64              0x9188, 0x81A9, 0xB1CA, 0xA1EB, 0xD10C, 0xC12D, 0xF14E, 0xE16F,
     65              0x1080, 0x00A1, 0x30C2, 0x20E3, 0x5004, 0x4025, 0x7046, 0x6067,
     66              0x83B9, 0x9398, 0xA3FB, 0xB3DA, 0xC33D, 0xD31C, 0xE37F, 0xF35E,
     67              0x02B1, 0x1290, 0x22F3, 0x32D2, 0x4235, 0x5214, 0x6277, 0x7256,
     68              0xB5EA, 0xA5CB, 0x95A8, 0x8589, 0xF56E, 0xE54F, 0xD52C, 0xC50D,
     69              0x34E2, 0x24C3, 0x14A0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,
     70              0xA7DB, 0xB7FA, 0x8799, 0x97B8, 0xE75F, 0xF77E, 0xC71D, 0xD73C,
     71              0x26D3, 0x36F2, 0x0691, 0x16B0, 0x6657, 0x7676, 0x4615, 0x5634,
     72              0xD94C, 0xC96D, 0xF90E, 0xE92F, 0x99C8, 0x89E9, 0xB98A, 0xA9AB,
     73              0x5844, 0x4865, 0x7806, 0x6827, 0x18C0, 0x08E1, 0x3882, 0x28A3,
     74              0xCB7D, 0xDB5C, 0xEB3F, 0xFB1E, 0x8BF9, 0x9BD8, 0xABBB, 0xBB9A,
     75              0x4A75, 0x5A54, 0x6A37, 0x7A16, 0x0AF1, 0x1AD0, 0x2AB3, 0x3A92,
     76              0xFD2E, 0xED0F, 0xDD6C, 0xCD4D, 0xBDAA, 0xAD8B, 0x9DE8, 0x8DC9,
     77              0x7C26, 0x6C07, 0x5C64, 0x4C45, 0x3CA2, 0x2C83, 0x1CE0, 0x0CC1,
     78              0xEF1F, 0xFF3E, 0xCF5D, 0xDF7C, 0xAF9B, 0xBFBA, 0x8FD9, 0x9FF8,
     79              0x6E17, 0x7E36, 0x4E55, 0x5E74, 0x2E93, 0x3EB2, 0x0ED1, 0x1EF0
     80          };
     81          
     82          uint16_t sd_crc16(const uint8_t *data, uint16_t len) {
     83              uint16_t crc = 0;
     84              while (len--)
     85                  crc = (crc << 8) ^
     86                      (crc16_table[((crc >> 8) ^ (*data++)) & 0xFF]);
     87              return crc;
     88          }
     89          
     90          static char crc7;
     91          uint8_t update_crc7(uint8_t data)
     92          {
     93            uint8_t j,d;
     94            d=data;
     95            for (j = 0; j < 8; j++)
     96            {
     97            crc7 <<= 1;
     98            if ( (d & 0x80) ^ (crc7 & 0x80) )
     99                crc7 ^= 0x09;
    100            d <<= 1;
    101            }
    102            return data;
    103          }
    104          /*******************************************************************************
    105          * Function Name  : MSD0_spi_read_write
    106          * Description    : None
    107          * Input          : - data:
    108          * Output         : None
    109          * Return         : None
    110          * Attention		 : None
    111          *******************************************************************************/
    112          uint8_t MSD0_spi_read_write(uint8_t data)
    113          {
    114            int timeout;
    115          
    116            //update_crc7(data);
    117            //while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
    118            /*while(!(SPI1->SR & SPI_I2S_FLAG_TXE));
    119          
    120            //SPI_I2S_SendData(SPI1, data);
    121            SPI1->DR = data;
    122          
    123            //while (SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
    124            timeout=0;
    125            while(!(SPI1->SR & SPI_I2S_FLAG_RXNE));
    126          
    127            //return SPI_I2S_ReceiveData(SPI1);
    128            return SPI1->DR;*/
    129            timeout=0;
    130            while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET)
    131            {
    132              if (timeout++>100) break;
    133            }
    134            SPI_SendData8(SPI1, data);
    135            timeout=0;
    136            while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) != SET)
    137            {
    138              if (timeout++>100) break;
    139            }
    140            return SPI_ReceiveData8(SPI1);
    141          }
    142          
    143          /*******************************************************************************
    144          * Function Name  : MSD0_SPI_Configuration
    145          * Description    : SD Card SPI Configuration
    146          * Input          : None
    147          * Output         : None
    148          * Return         : None
    149          * Attention		 : None
    150          *******************************************************************************/
    151          void MSD0_SPI_Configuration(void)
    152          {
    153            GPIO_InitTypeDef GPIO_InitStructure;
    154          
    155            RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
    156            RCC_AHBPeriphClockCmd(RCC_AHBPeriph_GPIOA|RCC_AHBPeriph_GPIOB, ENABLE);
    157          
    158            if (model==6)
    159            {
    160              GPIO_PinAFConfig( GPIOB , GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5, GPIO_AF_0 );
    161          
    162              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
    163              GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    164              GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    165              GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    166              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    167              GPIO_Init(GPIOB, &GPIO_InitStructure);
    168          
    169              GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    170              GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    171              GPIO_Init(GPIOB, &GPIO_InitStructure);
    172              
    173              GPIO_PinAFConfig(GPIOB, GPIO_PinSource3, GPIO_AF_0);
    174              GPIO_PinAFConfig(GPIOB, GPIO_PinSource4, GPIO_AF_0);
    175              GPIO_PinAFConfig(GPIOB, GPIO_PinSource5, GPIO_AF_0);
    176            }
    177            else
    178            {
    179            GPIO_PinAFConfig(GPIOA,GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7,GPIO_AF_0);
    180            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
    181            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    182            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    183            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    184            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    185            GPIO_Init(GPIOA, &GPIO_InitStructure);
    186          
    187            if (model!=4 && model!=5)
    188            {
    189                GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;
    190                GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    191                GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    192                GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    193                GPIO_Init(GPIOA, &GPIO_InitStructure);
    194            }
    195          
    196            GPIO_PinAFConfig(GPIOA, GPIO_PinSource5, GPIO_AF_0);
    197            GPIO_PinAFConfig(GPIOA, GPIO_PinSource6, GPIO_AF_0);
    198            GPIO_PinAFConfig(GPIOA, GPIO_PinSource7, GPIO_AF_0);
    199            /*
    200            GPIO_PinAFConfig(GPIOB,GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5,GPIO_AF_0);
    201            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;
    202            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    203            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    204            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_UP;
    205            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    206            GPIO_Init(GPIOB, &GPIO_InitStructure);
    207            
    208            GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;
    209            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
    210            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    211            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    212            GPIO_Init(GPIOB, &GPIO_InitStructure);
    213            */
    214            }
    215            MSD0_card_disable();
    216          
    217            MSD0_SPIHighSpeed(0);
    218            
    219            SPI_Cmd(SPI1, ENABLE);
    220          }
    221          
    222          /*******************************************************************************
    223          * Function Name  : MSD0_SPIHighSpeed
    224          * Description    : SD Card Speed Set
    225          * Input          : - b_high: 1 = 18MHz, 0 = 281.25Hz
    226          * Output         : None
    227          * Return         : None
    228          * Attention		 : None
    229          *******************************************************************************/
    230          char slow_card=0;
    231          void MSD0_SPIHighSpeed(uint8_t b_high)
    232          {
    233            SPI_InitTypeDef SPI_InitStructure;
    234          
    235            //SPI_I2S_DeInit(SPI1);  
    236            //SPI_RxFIFOThresholdConfig(SPI1, SPI_RxFIFOThreshold_QF);
    237            //while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) != SET);
    238            SPI_RxFIFOThresholdConfig(SPI1, SPI_RxFIFOThreshold_QF);
    239          
    240            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    241            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    242            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
    243            SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
    244            SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
    245            SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;
    246            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    247            SPI_InitStructure.SPI_CRCPolynomial = 7;
    248            
    249            if (model==4 || model==5)
    250            {
    251                if(b_high == 0) SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
    252                else SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    253                SPI_Init(SPI1, &SPI_InitStructure);
    254                return;
    255            }
    256            /* Speed select */
    257            if (slow_card==1)
    258            {
    259                SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_256;
    260            }
    261            else if(b_high == 0)
    262            {
    263          	 SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
    264            }
    265            else
    266            {
    267          	 SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4;
    268            }
    269          
    270            SPI_Init(SPI1, &SPI_InitStructure);
    271          }
    272          
    273          int MSD0_Init2()
    274          {
    275            /*uint8_t r1;
    276            r1 = MSD0_send_command(CMD0, 0, 0x95);
    277            if (r1==0x01) return 1;
    278            do
    279            {
    280              MSD0_card_disable();
    281              MSD0_spi_read_write(DUMMY_BYTE);
    282              r1 = MSD0_send_command(CMD1, 0, 0xFF);
    283            }
    284            while (r1==0);
    285            
    286            MSD0_card_disable();
    287            MSD0_spi_read_write(DUMMY_BYTE);
    288            
    289            return 0;*/
    290            
    291            uint8_t r1;
    292            uint16_t retry=0;
    293            for (retry=0;retry<0x7F;retry++)
    294            {
    295              MSD0_card_disable();
    296              MSD0_spi_read_write(DUMMY_BYTE);
    297              MSD0_card_enable();
    298              r1 = MSD0_send_command_hold(CMD1, 0, 0xFF);
    299              if (r1==0) break;
    300            }
    301            
    302            if (retry==0x7F) return 1;
    303            MSD0_card_disable();
    304            MSD0_spi_read_write(DUMMY_BYTE);
    305            
    306            card_type=9;
    307            return 0;
    308          }
    309          /*******************************************************************************
    310          * Function Name  : MSD0_Init
    311          * Description    : SD Card initializtion
    312          * Input          : None
    313          * Output         : None
    314          * Return         : None
    315          * Attention		 : None
    316          *******************************************************************************/
    317          int MSD0_Init(void)
    318          {
    319          	uint8_t r1;
    320          	uint8_t buff[6] = {0};
    321          	uint16_t retry;
    322                  
    323                  card_type=0;
    324          
    325          	/* Check , if no card insert */
    326              if( MSD0_card_insert() )
    327          	{
    328          #ifdef PRINT_INFO
    329          		printf("There is no card detected! \r\n");
    330          #endif
    331          	  /* FATFS error flag */
    332                return -1;
    333          	}
    334          
    335          	/* Power on and delay some times */
    336          	for(retry=0; retry<0x100; retry++)
    337          	{
    338          		MSD0_card_power_on();
    339          	}
    340          
    341          	/* Satrt send 74 clocks at least */
    342          	for(retry=0; retry<10; retry++)
    343          	{
    344          		MSD0_spi_read_write(DUMMY_BYTE);
    345          	}
    346          
    347          	/* Start send CMD0 till return 0x01 means in IDLE state */
    348          	for(retry=0; retry<0x7F; retry++)
    349          	{
    350          		r1 = MSD0_send_command(CMD0, 0, 0x95);
    351          		if(r1 == 0x01)
    352          		{
    353          			retry = 0;
    354          			break;
    355          		}
    356          	}
    357          	/* Timeout return */
    358          	if(retry == 0x7F)
    359          	{
    360          #ifdef PRINT_INFO
    361          		printf("Reset card into IDLE state failed!\r\n");
    362          #endif
    363          		return MSD0_Init2();
    364          	}
    365          
    366                  for(retry=0; retry<0x7F; retry++)
    367          	{
    368                          MSD0_card_disable();
    369                          MSD0_spi_read_write(DUMMY_BYTE);
    370                          r1 = MSD0_send_command(CMD1, 0, 0xFF);
    371          		if(r1 == 0)
    372          		{
    373          			retry = 0;
    374          			break;
    375          		}
    376          	}
    377          
    378          	/* Get the card type, version */
    379          	r1 = MSD0_send_command_hold(CMD8, 0x1AA, 0x87);
    380          	/* r1=0x05 -> V1.0 */
    381          	if(r1 == 0x05)
    382          	{
    383          	  SD0_CardInfo.CardType = CARDTYPE_SDV1;
    384          
    385          	  /* End of CMD8, chip disable and dummy byte */
    386          	  MSD0_card_disable();
    387          	  MSD0_spi_read_write(DUMMY_BYTE);
    388          
    389          	  /* SD1.0/MMC start initialize */
    390          	  /* Send CMD55+ACMD41, No-response is a MMC card, otherwise is a SD1.0 card */
    391          	  for(retry=0; retry<0xFF; retry++)
    392          	  {
    393          	     r1 = MSD0_send_command(CMD55, 0, 0);			/* should be return 0x01 */
    394          		 if(r1 != 0x01)
    395          		 {
    396          #ifdef PRINT_INFO
    397          			printf("Send CMD55 should return 0x01, response=0x%02x\r\n", r1);
    398          #endif
    399          			return r1;
    400          		 }
    401          
    402          		 r1 = MSD0_send_command(ACMD41, 0, 0);			/* should be return 0x00 */
    403          		 if(r1 == 0x00)
    404          		 {
    405          			retry = 0;
    406          			break;
    407          		 }
    408          	  }
    409          
    410          	  /* MMC card initialize start */
    411          	  if(retry == 0xFF)
    412          	  {
    413          		 for(retry=0; retry<0xFF; retry++)
    414          	     {
    415          			 r1 = MSD0_send_command(CMD1, 0, 0);		/* should be return 0x00 */
    416          			 if(r1 == 0x00)
    417          			 {
    418          				retry = 0;
    419          				break;
    420          			 }
    421          		 }
    422          
    423          		 /* Timeout return */
    424          		 if(retry == 0xFF)
    425          		 {
    426          #ifdef PRINT_INFO
    427          			printf("Send CMD1 should return 0x00, response=0x%02x\r\n", r1);
    428          #endif
    429          			return 2;
    430          		 }
    431          
    432          		SD0_CardInfo.CardType = CARDTYPE_MMC;
    433          #ifdef PRINT_INFO
    434          		printf("Card Type                     : MMC\r\n");
    435          #endif
    436          	  }
    437          		/* SD1.0 card detected, print information */
    438          #ifdef PRINT_INFO
    439          	  else
    440          	  {
    441          		 printf("Card Type                     : SD V1\r\n");
    442          	  }
    443          #endif
    444          
    445          	  /* Set spi speed high */
    446          	  MSD0_SPIHighSpeed(1);
    447          #if 0
    448          	  /* CRC disable */
    449          	  r1 = MSD0_send_command(CMD59, 1, 0x01);
    450          	  if(r1 != 0x00)
    451          	  {
    452          #ifdef PRINT_INFO
    453          		  printf("Send CMD59 should return 0x00, response=0x%02x\r\n", r1);
    454          #endif
    455          		  return r1;		/* response error, return r1 */
    456          	  }
    457          #endif
    458          
    459          	  /* Set the block size */
    460          	  r1 = MSD0_send_command(CMD16, MSD_BLOCKSIZE, 0xFF);
    461                //extern int MSD0_send_command_crc(uint8_t cmd, uint32_t arg);
    462                //r1 = MSD0_send_command_crc(CMD16, MSD_BLOCKSIZE);
    463          	  if(r1 != 0x00)
    464          	  {
    465          #ifdef PRINT_INFO
    466          		  printf("Send CMD16 should return 0x00, response=0x%02x\r\n", r1);
    467          #endif
    468          		  return r1;		/* response error, return r1 */
    469          	  }
    470             }
    471             /* r1=0x01 -> V2.x, read OCR register, check version */
    472             else if(r1 == 0x01)
    473             {
    474          	 /* 4Bytes returned after CMD8 sent	*/
    475          	 buff[0] = MSD0_spi_read_write(DUMMY_BYTE);				/* should be 0x00 */
    476          	 buff[1] = MSD0_spi_read_write(DUMMY_BYTE);				/* should be 0x00 */
    477          	 buff[2] = MSD0_spi_read_write(DUMMY_BYTE);				/* should be 0x01 */
    478          	 buff[3] = MSD0_spi_read_write(DUMMY_BYTE);				/* should be 0xAA */
    479          
    480          	 /* End of CMD8, chip disable and dummy byte */
    481          	 MSD0_card_disable();
    482          	 MSD0_spi_read_write(DUMMY_BYTE);
    483          
    484          	 /* Check voltage range be 2.7-3.6V	*/
    485          	 if(buff[2]==0x01 && buff[3]==0xAA)
    486          	 {
    487          		for(retry=0; retry<0xFF; retry++)
    488          		{
    489          			r1 = MSD0_send_command(CMD55, 0, 0xFF);			/* should be return 0x01 */
    490          			if(r1!=0x01)
    491          			{
    492          #ifdef PRINT_INFO
    493          				printf("Send CMD55 should return 0x01, response=0x%02x\r\n", r1);
    494          #endif
    495                                          
    496                                          return MSD0_Init2();
    497          /*
    498                                          //uint16_t retry=0;
    499                                          for (retry=0;retry<0x7F;retry++)
    500                                          {
    501                                            MSD0_card_disable();
    502                                            MSD0_spi_read_write(DUMMY_BYTE);
    503                                            MSD0_card_enable();
    504                                            r1 = MSD0_send_command_hold(CMD1, 0, 0xFF);
    505                                            if (r1==0) break;
    506                                          }
    507                                          
    508                                          if (retry==0x7F) return 1;
    509                                          MSD0_card_disable();
    510                                          MSD0_spi_read_write(DUMMY_BYTE);
    511                                          card_type=9;
    512                                          
    513                                          return 0;
    514                                          */
    515          				//return r1;
    516          			}
    517          
    518          			r1 = MSD0_send_command(ACMD41, 0x40000000, 0xFF);	/* should be return 0x00 */
    519          			if(r1 == 0x00)
    520          			{
    521          				retry = 0;
    522          				break;
    523          			}
    524          		}
    525          
    526          		/* Timeout return */
    527          		if(retry == 0xFF)
    528          		{
    529          #ifdef PRINT_INFO
    530          			printf("Send ACMD41 should return 0x00, response=0x%02x\r\n", r1);
    531          #endif
    532          			return 3;
    533          		}
    534          
    535          		/* Read OCR by CMD58 */
    536          	    r1 = MSD0_send_command_hold(CMD58, 0, 0);
    537          	    if(r1!=0x00)
    538          	    {
    539          #ifdef PRINT_INFO
    540          			printf("Send CMD58 should return 0x00, response=0x%02x\r\n", r1);
    541          #endif
    542                      return r1;		/* response error, return r1 */
    543          	    }
    544          
    545          	    buff[0] = MSD0_spi_read_write(DUMMY_BYTE);
    546          		buff[1] = MSD0_spi_read_write(DUMMY_BYTE);
    547          		buff[2] = MSD0_spi_read_write(DUMMY_BYTE);
    548          		buff[3] = MSD0_spi_read_write(DUMMY_BYTE);
    549          
    550          		/* End of CMD58, chip disable and dummy byte */
    551          		MSD0_card_disable();
    552          		MSD0_spi_read_write(DUMMY_BYTE);
    553          
    554          	    /* OCR -> CCS(bit30)  1: SDV2HC	 0: SDV2 */
    555          	    if(buff[0] & 0x40)
    556          	    {
    557                     SD0_CardInfo.CardType = CARDTYPE_SDV2HC;
    558          #ifdef PRINT_INFO
    559          		   printf("Card Type                     : SD V2HC\r\n");
    560          #endif
    561          	    }
    562          	    else
    563          	    {
    564                     SD0_CardInfo.CardType = CARDTYPE_SDV2;
    565          #ifdef PRINT_INFO
    566          		   printf("Card Type                     : SD V2\r\n");
    567          #endif
    568          	    }
    569          
    570          		/* Set spi speed high */
    571          		//MSD0_SPIHighSpeed(1);
    572          		}
    573             }
    574             else return MSD0_Init2();
    575             return 0;
    576          }
    577          
    578          /*******************************************************************************
    579          * Function Name  : MSD0_GetCardInfo
    580          * Description    : Get SD Card Information
    581          * Input          : None
    582          * Output         : None
    583          * Return         : 0£ºNO_ERR; TRUE: Error
    584          * Attention		 : None
    585          *******************************************************************************/
    586          int MSD0_GetCardInfo(PMSD_CARDINFO SD0_CardInfo)
    587          {
    588            uint8_t r1;
    589            uint8_t CSD_Tab[16];
    590            uint8_t CID_Tab[16];
    591          
    592            /* Send CMD9, Read CSD */
    593            r1 = MSD0_send_command(CMD9, 0, 0xFF);
    594            if(r1 != 0x00)
    595            {
    596              return r1;
    597            }
    598          
    599            if(MSD0_read_buffer(CSD_Tab, 16, RELEASE))
    600            {
    601          	return 1;
    602            }
    603          
    604            /* Send CMD10, Read CID */
    605            r1 = MSD0_send_command(CMD10, 0, 0xFF);
    606            if(r1 != 0x00)
    607            {
    608              return r1;
    609            }
    610          
    611            if(MSD0_read_buffer(CID_Tab, 16, RELEASE))
    612            {
    613          	return 2;
    614            }
    615          
    616            /* Byte 0 */
    617            SD0_CardInfo->CSD.CSDStruct = (CSD_Tab[0] & 0xC0) >> 6;
    618            SD0_CardInfo->CSD.SysSpecVersion = (CSD_Tab[0] & 0x3C) >> 2;
    619            SD0_CardInfo->CSD.Reserved1 = CSD_Tab[0] & 0x03;
    620            /* Byte 1 */
    621            SD0_CardInfo->CSD.TAAC = CSD_Tab[1] ;
    622            /* Byte 2 */
    623            SD0_CardInfo->CSD.NSAC = CSD_Tab[2];
    624            /* Byte 3 */
    625            SD0_CardInfo->CSD.MaxBusClkFrec = CSD_Tab[3];
    626            /* Byte 4 */
    627            SD0_CardInfo->CSD.CardComdClasses = CSD_Tab[4] << 4;
    628            /* Byte 5 */
    629            SD0_CardInfo->CSD.CardComdClasses |= (CSD_Tab[5] & 0xF0) >> 4;
    630            SD0_CardInfo->CSD.RdBlockLen = CSD_Tab[5] & 0x0F;
    631            /* Byte 6 */
    632            SD0_CardInfo->CSD.PartBlockRead = (CSD_Tab[6] & 0x80) >> 7;
    633            SD0_CardInfo->CSD.WrBlockMisalign = (CSD_Tab[6] & 0x40) >> 6;
    634            SD0_CardInfo->CSD.RdBlockMisalign = (CSD_Tab[6] & 0x20) >> 5;
    635            SD0_CardInfo->CSD.DSRImpl = (CSD_Tab[6] & 0x10) >> 4;
    636            SD0_CardInfo->CSD.Reserved2 = 0; /* Reserved */
    637            SD0_CardInfo->CSD.DeviceSize = (CSD_Tab[6] & 0x03) << 10;
    638            /* Byte 7 */
    639            SD0_CardInfo->CSD.DeviceSize |= (CSD_Tab[7]) << 2;
    640            /* Byte 8 */
    641            SD0_CardInfo->CSD.DeviceSize |= (CSD_Tab[8] & 0xC0) >> 6;
    642            SD0_CardInfo->CSD.MaxRdCurrentVDDMin = (CSD_Tab[8] & 0x38) >> 3;
    643            SD0_CardInfo->CSD.MaxRdCurrentVDDMax = (CSD_Tab[8] & 0x07);
    644            /* Byte 9 */
    645            SD0_CardInfo->CSD.MaxWrCurrentVDDMin = (CSD_Tab[9] & 0xE0) >> 5;
    646            SD0_CardInfo->CSD.MaxWrCurrentVDDMax = (CSD_Tab[9] & 0x1C) >> 2;
    647            SD0_CardInfo->CSD.DeviceSizeMul = (CSD_Tab[9] & 0x03) << 1;
    648            /* Byte 10 */
    649            SD0_CardInfo->CSD.DeviceSizeMul |= (CSD_Tab[10] & 0x80) >> 7;
    650            SD0_CardInfo->CSD.EraseGrSize = (CSD_Tab[10] & 0x7C) >> 2;
    651            SD0_CardInfo->CSD.EraseGrMul = (CSD_Tab[10] & 0x03) << 3;
    652            /* Byte 11 */
    653            SD0_CardInfo->CSD.EraseGrMul |= (CSD_Tab[11] & 0xE0) >> 5;
    654            SD0_CardInfo->CSD.WrProtectGrSize = (CSD_Tab[11] & 0x1F);
    655            /* Byte 12 */
    656            SD0_CardInfo->CSD.WrProtectGrEnable = (CSD_Tab[12] & 0x80) >> 7;
    657            SD0_CardInfo->CSD.ManDeflECC = (CSD_Tab[12] & 0x60) >> 5;
    658            SD0_CardInfo->CSD.WrSpeedFact = (CSD_Tab[12] & 0x1C) >> 2;
    659            SD0_CardInfo->CSD.MaxWrBlockLen = (CSD_Tab[12] & 0x03) << 2;
    660            /* Byte 13 */
    661            SD0_CardInfo->CSD.MaxWrBlockLen |= (CSD_Tab[13] & 0xc0) >> 6;
    662            SD0_CardInfo->CSD.WriteBlockPaPartial = (CSD_Tab[13] & 0x20) >> 5;
    663            SD0_CardInfo->CSD.Reserved3 = 0;
    664            SD0_CardInfo->CSD.ContentProtectAppli = (CSD_Tab[13] & 0x01);
    665            /* Byte 14 */
    666            SD0_CardInfo->CSD.FileFormatGrouop = (CSD_Tab[14] & 0x80) >> 7;
    667            SD0_CardInfo->CSD.CopyFlag = (CSD_Tab[14] & 0x40) >> 6;
    668            SD0_CardInfo->CSD.PermWrProtect = (CSD_Tab[14] & 0x20) >> 5;
    669            SD0_CardInfo->CSD.TempWrProtect = (CSD_Tab[14] & 0x10) >> 4;
    670            SD0_CardInfo->CSD.FileFormat = (CSD_Tab[14] & 0x0C) >> 2;
    671            SD0_CardInfo->CSD.ECC = (CSD_Tab[14] & 0x03);
    672            /* Byte 15 */
    673            SD0_CardInfo->CSD.CSD_CRC = (CSD_Tab[15] & 0xFE) >> 1;
    674            SD0_CardInfo->CSD.Reserved4 = 1;
    675          
    676            if(SD0_CardInfo->CardType == CARDTYPE_SDV2HC)
    677            {
    678          	 /* Byte 7 */
    679          	 SD0_CardInfo->CSD.DeviceSize = (u16)(CSD_Tab[8]) *256;
    680          	 /* Byte 8 */
    681          	 SD0_CardInfo->CSD.DeviceSize += CSD_Tab[9] ;
    682            }
    683          
    684            SD0_CardInfo->Capacity = SD0_CardInfo->CSD.DeviceSize * MSD_BLOCKSIZE * 1024;
    685            SD0_CardInfo->BlockSize = MSD_BLOCKSIZE;
    686          
    687            /* Byte 0 */
    688            SD0_CardInfo->CID.ManufacturerID = CID_Tab[0];
    689            /* Byte 1 */
    690            SD0_CardInfo->CID.OEM_AppliID = CID_Tab[1] << 8;
    691            /* Byte 2 */
    692            SD0_CardInfo->CID.OEM_AppliID |= CID_Tab[2];
    693            /* Byte 3 */
    694            SD0_CardInfo->CID.ProdName1 = CID_Tab[3] << 24;
    695            /* Byte 4 */
    696            SD0_CardInfo->CID.ProdName1 |= CID_Tab[4] << 16;
    697            /* Byte 5 */
    698            SD0_CardInfo->CID.ProdName1 |= CID_Tab[5] << 8;
    699            /* Byte 6 */
    700            SD0_CardInfo->CID.ProdName1 |= CID_Tab[6];
    701            /* Byte 7 */
    702            SD0_CardInfo->CID.ProdName2 = CID_Tab[7];
    703            /* Byte 8 */
    704            SD0_CardInfo->CID.ProdRev = CID_Tab[8];
    705            /* Byte 9 */
    706            SD0_CardInfo->CID.ProdSN = CID_Tab[9] << 24;
    707            /* Byte 10 */
    708            SD0_CardInfo->CID.ProdSN |= CID_Tab[10] << 16;
    709            /* Byte 11 */
    710            SD0_CardInfo->CID.ProdSN |= CID_Tab[11] << 8;
    711            /* Byte 12 */
    712            SD0_CardInfo->CID.ProdSN |= CID_Tab[12];
    713            /* Byte 13 */
    714            SD0_CardInfo->CID.Reserved1 |= (CID_Tab[13] & 0xF0) >> 4;
    715            /* Byte 14 */
    716            SD0_CardInfo->CID.ManufactDate = (CID_Tab[13] & 0x0F) << 8;
    717            /* Byte 15 */
    718            SD0_CardInfo->CID.ManufactDate |= CID_Tab[14];
    719            /* Byte 16 */
    720            SD0_CardInfo->CID.CID_CRC = (CID_Tab[15] & 0xFE) >> 1;
    721            SD0_CardInfo->CID.Reserved2 = 1;
    722          
    723            return 0;
    724          }
    725          
    726          /*******************************************************************************
    727          * Function Name  : MSD0_read_buffer
    728          * Description    : None
    729          * Input          : - *buff:
    730          *				   - len:
    731          *				   - release:
    732          * Output         : None
    733          * Return         : 0£ºNO_ERR; TRUE: Error
    734          * Attention		 : None
    735          *******************************************************************************/
    736          int MSD0_read_buffer(uint8_t *buff, uint16_t len, uint8_t release)
    737          {
    738            uint8_t r1;
    739            register uint16_t retry;
    740          
    741          restart:
    742            /* Card enable, Prepare to read	*/
    743            MSD0_card_enable();
    744          
    745            /* Wait start-token 0xFE */
    746            for(retry=0; retry<2000; retry++)
    747            {
    748          	 r1 = MSD0_spi_read_write(DUMMY_BYTE);
    749          	 if(r1 == 0xFE)
    750          	 {
    751          		 retry = 0;
    752          		 break;
    753          	 }
    754            }
    755          
    756            /* Timeout return	*/
    757            if(retry == 2000)
    758            {
    759          	 MSD0_card_disable();
    760          	 return 1;
    761            }
    762          
    763            /* Start reading */
    764            for(retry=0; retry<len; retry++)
    765            {
    766               *(buff+retry) = MSD0_spi_read_write(DUMMY_BYTE);
    767            }
    768          
    769            uint16_t crc16 = sd_crc16(buff,len);
    770            //printf("CRC == %X\n",crc16);
    771          
    772            /* 2bytes dummy CRC */
    773            uint8_t crc_h,crc_l;
    774            crc_h=MSD0_spi_read_write(DUMMY_BYTE);
    775            crc_l=MSD0_spi_read_write(DUMMY_BYTE);
    776            //printf("CRC: %X/%X\n",crc_h,crc_l);
    777          
    778            /* chip disable and dummy byte */
    779            if(release)
    780            {
    781          	 MSD0_card_disable();
    782          	 MSD0_spi_read_write(DUMMY_BYTE);
    783            }
    784          
    785            if (((crc16>>8)!=crc_h) || ((crc16&0xFF) != crc_l))
    786            {
    787                //printf("CRC ERROR!\n");
    788                goto restart;
    789            }
    790          
    791            return 0;
    792          }
    793          
    794          /*******************************************************************************
    795          * Function Name  : MSD0_ReadSingleBlock
    796          * Description    : None
    797          * Input          : - sector:
    798          *				   - buffer:
    799          * Output         : None
    800          * Return         : None
    801          * Attention		 : None
    802          *******************************************************************************/
    803          int MSD0_ReadSingleBlock(uint32_t sector, uint8_t *buffer)
    804          {
    805            uint8_t r1;
    806          
    807            /* if ver = SD2.0 HC, sector need <<9 */
    808            if(SD0_CardInfo.CardType != CARDTYPE_SDV2HC)
    809            {
    810          	 sector = sector<<9;
    811            }
    812          
    813            if (card_type==9) return SD_ReadBlock(buffer, sector, MSD_BLOCKSIZE);
    814            
    815          
    816            /* Send CMD17 : Read single block command */
    817            r1 = MSD0_send_command(CMD17, sector, (SD0_CardInfo.CardType == CARDTYPE_SDV2HC) ? 0xFF:0);
    818          
    819            if(r1 != 0x00)
    820            {
    821          	 return 1;
    822            }
    823          
    824            /* Start read and return the result */
    825            r1 = MSD0_read_buffer(buffer, MSD_BLOCKSIZE, RELEASE);
    826          
    827            /* Send stop data transmit command - CMD12 */
    828            MSD0_send_command(CMD12, 0, (SD0_CardInfo.CardType == CARDTYPE_SDV2HC) ? 0xFF:0);
    829          
    830            return r1;
    831          }
    832          
    833          /*******************************************************************************
    834          * Function Name  : MSD0_ReadMultiBlock
    835          * Description    : None
    836          * Input          : - sector:
    837          *				   - buffer:
    838          *                  - NbrOfSector:
    839          * Output         : None
    840          * Return         : None
    841          * Attention		 : None
    842          *******************************************************************************/
    843          int MSD0_ReadMultiBlock(uint32_t sector, uint8_t *buffer, uint32_t NbrOfSector)
    844          {
    845            uint8_t r1;
    846            register uint32_t i;
    847          
    848            /* if ver = SD2.0 HC, sector need <<9 */
    849            if(SD0_CardInfo.CardType != CARDTYPE_SDV2HC)
    850            {
    851          	 sector = sector<<9;
    852            }
    853          
    854            /* Send CMD18 : Read multi block command */
    855            r1 = MSD0_send_command(CMD18, sector, (SD0_CardInfo.CardType == CARDTYPE_SDV2HC) ? 0xFF:0);
    856            if(r1 != 0x00)
    857            {
    858               return 1;
    859            }
    860          
    861            /* Start read	*/
    862            for(i=0; i<NbrOfSector; i++)
    863            {
    864               if(MSD0_read_buffer(buffer+i*MSD_BLOCKSIZE, MSD_BLOCKSIZE, HOLD))
    865               {
    866          		 /* Send stop data transmit command - CMD12	*/
    867          		 MSD0_send_command(CMD12, 0, (SD0_CardInfo.CardType == CARDTYPE_SDV2HC) ? 0xFF:0);
    868          		 /* chip disable and dummy byte */
    869          		 MSD0_card_disable();
    870          		 return 2;
    871               }
    872            }
    873          
    874            /* Send stop data transmit command - CMD12 */
    875            MSD0_send_command(CMD12, 0, (SD0_CardInfo.CardType == CARDTYPE_SDV2HC) ? 0xFF:0);
    876          
    877            /* chip disable and dummy byte */
    878            MSD0_card_disable();
    879            MSD0_spi_read_write(DUMMY_BYTE);
    880          
    881            return 0;
    882          }
    883          
    884          /*******************************************************************************
    885          * Function Name  : MSD0_WriteSingleBlock
    886          * Description    : None
    887          * Input          : - sector:
    888          *				   - buffer:
    889          * Output         : None
    890          * Return         : None
    891          * Attention		 : None
    892          *******************************************************************************/
    893          int MSD0_WriteSingleBlock(uint32_t sector, uc8 *buffer)
    894          {
    895            uint8_t r1;
    896            register uint16_t i;
    897            uint32_t retry;
    898          
    899            /* if ver = SD2.0 HC, sector need <<9 */
    900            if(SD0_CardInfo.CardType != CARDTYPE_SDV2HC)
    901            {
    902          	 sector = sector<<9;
    903            }
    904          
    905            /* Send CMD24 : Write single block command */
    906            r1 = MSD0_send_command(CMD24, sector, 0);
    907          
    908            if(r1 != 0x00)
    909            {
    910          	 return 1;
    911            }
    912          
    913            /* Card enable, Prepare to write */
    914            MSD0_card_enable();
    915            MSD0_spi_read_write(DUMMY_BYTE);
    916            MSD0_spi_read_write(DUMMY_BYTE);
    917            MSD0_spi_read_write(DUMMY_BYTE);
    918            /* Start data write token: 0xFE */
    919            MSD0_spi_read_write(0xFE);
    920          
    921            /* Start single block write the data buffer */
    922            for(i=0; i<MSD_BLOCKSIZE; i++)
    923            {
    924              MSD0_spi_read_write(*buffer++);
    925            }
    926          
    927            /* 2Bytes dummy CRC */
    928            MSD0_spi_read_write(DUMMY_BYTE);
    929            MSD0_spi_read_write(DUMMY_BYTE);
    930          
    931            /* MSD card accept the data */
    932            r1 = MSD0_spi_read_write(DUMMY_BYTE);
    933            if((r1&0x1F) != 0x05)
    934            {
    935              MSD0_card_disable();
    936              return 2;
    937            }
    938          
    939            /* Wait all the data programm finished */
    940            retry = 0;
    941            while(MSD0_spi_read_write(DUMMY_BYTE) == 0x00)
    942            {
    943          	 /* Timeout return */
    944          	 if(retry++ == 0x40000)
    945          	 {
    946          	    MSD0_card_disable();
    947          	    return 3;
    948          	 }
    949            }
    950          
    951            /* chip disable and dummy byte */
    952            MSD0_card_disable();
    953            MSD0_spi_read_write(DUMMY_BYTE);
    954          
    955            return 0;
    956          }
    957          
    958          /*******************************************************************************
    959          * Function Name  : MSD0_WriteMultiBlock
    960          * Description    : None
    961          * Input          : - sector:
    962          *				   - buffer:
    963          *                  - NbrOfSector:
    964          * Output         : None
    965          * Return         : None
    966          * Attention		 : None
    967          *******************************************************************************/
    968          int MSD0_WriteMultiBlock(uint32_t sector, uc8 *buffer, uint32_t NbrOfSector)
    969          {
    970            uint8_t r1;
    971            register uint16_t i;
    972            register uint32_t n;
    973            uint32_t retry;
    974          
    975            /* if ver = SD2.0 HC, sector need <<9 */
    976            if(SD0_CardInfo.CardType != CARDTYPE_SDV2HC)
    977            {
    978          	  sector = sector<<9;
    979            }
    980          
    981            /* Send command ACMD23 berfore multi write if is not a MMC card */
    982            if(SD0_CardInfo.CardType != CARDTYPE_MMC)
    983            {
    984          	  MSD0_send_command(ACMD23, NbrOfSector, 0x00);
    985            }
    986          
    987            /* Send CMD25 : Write nulti block command	*/
    988            r1 = MSD0_send_command(CMD25, sector, 0);
    989          
    990            if(r1 != 0x00)
    991            {
    992          	  return 1;
    993            }
    994          
    995            /* Card enable, Prepare to write */
    996            MSD0_card_enable();
    997            MSD0_spi_read_write(DUMMY_BYTE);
    998            //MSD0_spi_read_write(DUMMY_BYTE);
    999            //MSD0_spi_read_write(DUMMY_BYTE);
   1000          
   1001            for(n=0; n<NbrOfSector; n++)
   1002            {
   1003          	 /* Start multi block write token: 0xFC */
   1004          	 MSD0_spi_read_write(0xFC);
   1005          
   1006          	 for(i=0; i<MSD_BLOCKSIZE; i++)
   1007          	 {
   1008          		MSD0_spi_read_write(*buffer++);
   1009          	 }
   1010          
   1011          	 /* 2Bytes dummy CRC */
   1012          	 MSD0_spi_read_write(DUMMY_BYTE);
   1013          	 MSD0_spi_read_write(DUMMY_BYTE);
   1014          
   1015          	 /* MSD card accept the data */
   1016          	 r1 = MSD0_spi_read_write(DUMMY_BYTE);
   1017          	 if((r1&0x1F) != 0x05)
   1018          	 {
   1019          	    MSD0_card_disable();
   1020          	    return 2;
   1021          	 }
   1022          
   1023          	 /* Wait all the data programm finished	*/
   1024          	 retry = 0;
   1025          	 while(MSD0_spi_read_write(DUMMY_BYTE) != 0xFF)
   1026          	 {
   1027          		/* Timeout return */
   1028          		if(retry++ == 0x40000)
   1029          		{
   1030          		   MSD0_card_disable();
   1031          		   return 3;
   1032          		}
   1033          	 }
   1034            }
   1035          
   1036            /* Send end of transmit token: 0xFD */
   1037            r1 = MSD0_spi_read_write(0xFD);
   1038            if(r1 == 0x00)
   1039            {
   1040          	 return 4;
   1041            }
   1042          
   1043            /* Wait all the data programm finished */
   1044            retry = 0;
   1045            while(MSD0_spi_read_write(DUMMY_BYTE) != 0xFF)
   1046            {
   1047          	 /* Timeout return */
   1048          	 if(retry++ == 0x40000)
   1049          	 {
   1050          	     MSD0_card_disable();
   1051          	     return 5;
   1052          	 }
   1053            }
   1054          
   1055            /* chip disable and dummy byte */
   1056            MSD0_card_disable();
   1057            MSD0_spi_read_write(DUMMY_BYTE);
   1058          
   1059            return 0;
   1060          }
   1061          
   1062          
   1063          /*******************************************************************************
   1064          * Function Name  : MSD0_send_command
   1065          * Description    : None
   1066          * Input          : - cmd:
   1067          *				   - arg:
   1068          *                  - crc:
   1069          * Output         : None
   1070          * Return         : R1 value, response from card
   1071          * Attention		 : None
   1072          *******************************************************************************/
   1073          int MSD0_send_command(uint8_t cmd, uint32_t arg, uint8_t crc)
   1074          {
   1075            uint8_t r1;
   1076            uint8_t retry;
   1077          
   1078            /* Dummy byte and chip enable */
   1079            MSD0_spi_read_write(DUMMY_BYTE);
   1080            MSD0_card_enable();
   1081          
   1082            /* Command, argument and crc */
   1083            //crc7=0;
   1084            MSD0_spi_read_write(cmd | 0x40);
   1085            MSD0_spi_read_write(arg >> 24);
   1086            MSD0_spi_read_write(arg >> 16);
   1087            MSD0_spi_read_write(arg >> 8);
   1088            MSD0_spi_read_write(arg);
   1089            MSD0_spi_read_write(crc);
   1090          
   1091            /* Wait response, quit till timeout */
   1092            for(retry=0; retry<50; retry++)
   1093            {
   1094          	 r1 = MSD0_spi_read_write(DUMMY_BYTE);
   1095          	 if(r1 != 0xFF)
   1096          	 {
   1097          		 break;
   1098          	 }
   1099            }
   1100          
   1101            /* Chip disable and dummy byte */
   1102            MSD0_card_disable();
   1103            MSD0_spi_read_write(DUMMY_BYTE);
   1104          
   1105            return r1;
   1106          }
   1107          
   1108          /*******************************************************************************
   1109          * Function Name  : MSD0_send_command_hold
   1110          * Description    : None
   1111          * Input          : - cmd:
   1112          *				   - arg:
   1113          *                  - crc:
   1114          * Output         : None
   1115          * Return         : R1 value, response from card
   1116          * Attention		 : None
   1117          *******************************************************************************/
   1118          int MSD0_send_command_hold(uint8_t cmd, uint32_t arg, uint8_t crc)
   1119          {
   1120            uint8_t r1;
   1121            uint8_t retry;
   1122          
   1123            /* Dummy byte and chip enable */
   1124            MSD0_spi_read_write(DUMMY_BYTE);
   1125            MSD0_card_enable();
   1126          
   1127            /* Command, argument and crc */
   1128            MSD0_spi_read_write(cmd | 0x40);
   1129            MSD0_spi_read_write(arg >> 24);
   1130            MSD0_spi_read_write(arg >> 16);
   1131            MSD0_spi_read_write(arg >> 8);
   1132            MSD0_spi_read_write(arg);
   1133            MSD0_spi_read_write(crc);
   1134          
   1135            /* Wait response, quit till timeout */
   1136            for(retry=0; retry<200; retry++)
   1137            {
   1138          	 r1 = MSD0_spi_read_write(DUMMY_BYTE);
   1139          	 if(r1 != 0xFF)
   1140          	 {
   1141          		 break;
   1142          	 }
   1143            }
   1144          
   1145            return r1;
   1146          }
   1147          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   MSD0_GetCardInfo
        56   -> MSD0_read_buffer
        56   -> MSD0_send_command
      32   MSD0_Init
        32   -> MSD0_Init2
        32   -> MSD0_SPIHighSpeed
        32   -> MSD0_card_disable
        32   -> MSD0_send_command
        32   -> MSD0_send_command_hold
        32   -> MSD0_spi_read_write
        32   -> memset
       8   MSD0_Init2
         8   -> MSD0_card_disable
         8   -> MSD0_card_enable
         8   -> MSD0_send_command_hold
         8   -> MSD0_spi_read_write
      24   MSD0_ReadMultiBlock
        24   -> MSD0_card_disable
        24   -> MSD0_read_buffer
        24   -> MSD0_send_command
        24   -> MSD0_spi_read_write
      16   MSD0_ReadSingleBlock
        16   -> MSD0_read_buffer
        16   -> MSD0_send_command
        16   -> SD_ReadBlock
      32   MSD0_SPIHighSpeed
        32   -> SPI_Init
        32   -> SPI_RxFIFOThresholdConfig
      32   MSD0_SPI_Configuration
        32   -> GPIO_Init
        32   -> GPIO_PinAFConfig
        32   -> MSD0_SPIHighSpeed
        32   -> MSD0_card_disable
        32   -> RCC_AHBPeriphClockCmd
        32   -> RCC_APB2PeriphClockCmd
        32   -> SPI_Cmd
      32   MSD0_WriteMultiBlock
        32   -> MSD0_card_disable
        32   -> MSD0_card_enable
        32   -> MSD0_send_command
        32   -> MSD0_spi_read_write
      16   MSD0_WriteSingleBlock
        16   -> MSD0_card_disable
        16   -> MSD0_card_enable
        16   -> MSD0_send_command
        16   -> MSD0_spi_read_write
       8   MSD0_card_disable
         8   -> GPIO_ResetBits
         8   -> GPIO_SetBits
       8   MSD0_card_enable
         8   -> GPIO_ResetBits
      32   MSD0_read_buffer
        32   -> MSD0_card_disable
        32   -> MSD0_card_enable
        32   -> MSD0_spi_read_write
        32   -> sd_crc16
      16   MSD0_send_command
        16   -> MSD0_card_disable
        16   -> MSD0_card_enable
        16   -> MSD0_spi_read_write
      16   MSD0_send_command_hold
        16   -> MSD0_card_enable
        16   -> MSD0_spi_read_write
      24   MSD0_spi_read_write
        24   -> SPI_I2S_GetFlagStatus
        24   -> SPI_ReceiveData8
        24   -> SPI_SendData8
      12   sd_crc16
      16   update_crc7


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable12_1
       4  ??DataTable12_2
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
     636  MSD0_GetCardInfo
     442  MSD0_Init
      70  MSD0_Init2
     140  MSD0_ReadMultiBlock
     104  MSD0_ReadSingleBlock
     110  MSD0_SPIHighSpeed
     230  MSD0_SPI_Configuration
     222  MSD0_WriteMultiBlock
     156  MSD0_WriteSingleBlock
      44  MSD0_card_disable
      40  MSD0_card_enable
     134  MSD0_read_buffer
      92  MSD0_send_command
      78  MSD0_send_command_hold
      66  MSD0_spi_read_write
      88  SD0_CardInfo
       1  card_type
     512  crc16_table
       1  crc7
      44  sd_crc16
       1  slow_card
      38  update_crc7

 
    91 bytes in section .bss
   512 bytes in section .rodata
 2'694 bytes in section .text
 
 2'694 bytes of CODE  memory
   512 bytes of CONST memory
    91 bytes of DATA  memory

Errors: none
Warnings: 1
